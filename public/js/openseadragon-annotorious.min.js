(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("openseadragon"));
	else if(typeof define === 'function' && define.amd)
		define(["openseadragon"], factory);
	else if(typeof exports === 'object')
		exports["Annotorious"] = factory(require("openseadragon"));
	else
		root["OpenSeadragon"] = root["OpenSeadragon"] || {}, root["OpenSeadragon"]["Annotorious"] = factory(root["OpenSeadragon"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 91);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "useState", function() { return /* reexport */ hooks_module_l; });
__webpack_require__.d(__webpack_exports__, "useReducer", function() { return /* reexport */ hooks_module_p; });
__webpack_require__.d(__webpack_exports__, "useEffect", function() { return /* reexport */ hooks_module_y; });
__webpack_require__.d(__webpack_exports__, "useLayoutEffect", function() { return /* reexport */ hooks_module_h; });
__webpack_require__.d(__webpack_exports__, "useRef", function() { return /* reexport */ hooks_module_s; });
__webpack_require__.d(__webpack_exports__, "useImperativeHandle", function() { return /* reexport */ hooks_module_; });
__webpack_require__.d(__webpack_exports__, "useMemo", function() { return /* reexport */ hooks_module_d; });
__webpack_require__.d(__webpack_exports__, "useCallback", function() { return /* reexport */ hooks_module_A; });
__webpack_require__.d(__webpack_exports__, "useContext", function() { return /* reexport */ F; });
__webpack_require__.d(__webpack_exports__, "useDebugValue", function() { return /* reexport */ hooks_module_T; });
__webpack_require__.d(__webpack_exports__, "useErrorBoundary", function() { return /* reexport */ hooks_module_q; });
__webpack_require__.d(__webpack_exports__, "createElement", function() { return /* reexport */ a; });
__webpack_require__.d(__webpack_exports__, "createContext", function() { return /* reexport */ q; });
__webpack_require__.d(__webpack_exports__, "createRef", function() { return /* reexport */ h; });
__webpack_require__.d(__webpack_exports__, "Fragment", function() { return /* reexport */ y; });
__webpack_require__.d(__webpack_exports__, "Component", function() { return /* reexport */ p; });
__webpack_require__.d(__webpack_exports__, "version", function() { return /* binding */ ln; });
__webpack_require__.d(__webpack_exports__, "Children", function() { return /* binding */ compat_module_k; });
__webpack_require__.d(__webpack_exports__, "render", function() { return /* binding */ compat_module_z; });
__webpack_require__.d(__webpack_exports__, "hydrate", function() { return /* binding */ B; });
__webpack_require__.d(__webpack_exports__, "unmountComponentAtNode", function() { return /* binding */ sn; });
__webpack_require__.d(__webpack_exports__, "createPortal", function() { return /* binding */ compat_module_I; });
__webpack_require__.d(__webpack_exports__, "createFactory", function() { return /* binding */ fn; });
__webpack_require__.d(__webpack_exports__, "cloneElement", function() { return /* binding */ an; });
__webpack_require__.d(__webpack_exports__, "isValidElement", function() { return /* binding */ cn; });
__webpack_require__.d(__webpack_exports__, "findDOMNode", function() { return /* binding */ hn; });
__webpack_require__.d(__webpack_exports__, "PureComponent", function() { return /* binding */ E; });
__webpack_require__.d(__webpack_exports__, "memo", function() { return /* binding */ compat_module_g; });
__webpack_require__.d(__webpack_exports__, "forwardRef", function() { return /* binding */ compat_module_x; });
__webpack_require__.d(__webpack_exports__, "unstable_batchedUpdates", function() { return /* binding */ pn; });
__webpack_require__.d(__webpack_exports__, "StrictMode", function() { return /* binding */ vn; });
__webpack_require__.d(__webpack_exports__, "Suspense", function() { return /* binding */ compat_module_L; });
__webpack_require__.d(__webpack_exports__, "SuspenseList", function() { return /* binding */ compat_module_F; });
__webpack_require__.d(__webpack_exports__, "lazy", function() { return /* binding */ D; });
__webpack_require__.d(__webpack_exports__, "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", function() { return /* binding */ Q; });
__webpack_require__.d(__webpack_exports__, "unstable_ImmediatePriority", function() { return /* binding */ X; });
__webpack_require__.d(__webpack_exports__, "unstable_UserBlockingPriority", function() { return /* binding */ nn; });
__webpack_require__.d(__webpack_exports__, "unstable_NormalPriority", function() { return /* binding */ tn; });
__webpack_require__.d(__webpack_exports__, "unstable_LowPriority", function() { return /* binding */ en; });
__webpack_require__.d(__webpack_exports__, "unstable_IdlePriority", function() { return /* binding */ rn; });
__webpack_require__.d(__webpack_exports__, "unstable_runWithPriority", function() { return /* binding */ un; });
__webpack_require__.d(__webpack_exports__, "unstable_now", function() { return /* binding */ on; });

// CONCATENATED MODULE: ./node_modules/preact/dist/preact.module.js
var preact_module_n,
    l,
    preact_module_u,
    preact_module_i,
    preact_module_t,
    preact_module_o,
    preact_module_r = {},
    f = [],
    preact_module_e = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

function c(n, l) {
  for (var u in l) {
    n[u] = l[u];
  }

  return n;
}

function s(n) {
  var l = n.parentNode;
  l && l.removeChild(n);
}

function a(n, l, u) {
  var i,
      t,
      o,
      r = arguments,
      f = {};

  for (o in l) {
    "key" == o ? i = l[o] : "ref" == o ? t = l[o] : f[o] = l[o];
  }

  if (arguments.length > 3) for (u = [u], o = 3; o < arguments.length; o++) {
    u.push(r[o]);
  }
  if (null != u && (f.children = u), "function" == typeof n && null != n.defaultProps) for (o in n.defaultProps) {
    void 0 === f[o] && (f[o] = n.defaultProps[o]);
  }
  return v(n, f, i, t, null);
}

function v(l, u, i, t, o) {
  var r = {
    type: l,
    props: u,
    key: i,
    ref: t,
    __k: null,
    __: null,
    __b: 0,
    __e: null,
    __d: void 0,
    __c: null,
    __h: null,
    constructor: void 0,
    __v: null == o ? ++preact_module_n.__v : o
  };
  return null != preact_module_n.vnode && preact_module_n.vnode(r), r;
}

function h() {
  return {
    current: null
  };
}

function y(n) {
  return n.children;
}

function p(n, l) {
  this.props = n, this.context = l;
}

function d(n, l) {
  if (null == l) return n.__ ? d(n.__, n.__.__k.indexOf(n) + 1) : null;

  for (var u; l < n.__k.length; l++) {
    if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
  }

  return "function" == typeof n.type ? d(n) : null;
}

function _(n) {
  var l, u;

  if (null != (n = n.__) && null != n.__c) {
    for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {
      if (null != (u = n.__k[l]) && null != u.__e) {
        n.__e = n.__c.base = u.__e;
        break;
      }
    }

    return _(n);
  }
}

function k(l) {
  (!l.__d && (l.__d = !0) && preact_module_u.push(l) && !b.__r++ || preact_module_t !== preact_module_n.debounceRendering) && ((preact_module_t = preact_module_n.debounceRendering) || preact_module_i)(b);
}

function b() {
  for (var n; b.__r = preact_module_u.length;) {
    n = preact_module_u.sort(function (n, l) {
      return n.__v.__b - l.__v.__b;
    }), preact_module_u = [], n.some(function (n) {
      var l, u, i, t, o, r;
      n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = c({}, t)).__v = t.__v + 1, I(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? d(t) : o, t.__h), T(u, t), t.__e != o && _(t)));
    });
  }
}

function m(n, l, u, i, t, o, e, c, s, a) {
  var h,
      p,
      _,
      k,
      b,
      m,
      w,
      A = i && i.__k || f,
      P = A.length;

  for (u.__k = [], h = 0; h < l.length; h++) {
    if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? v(null, k, null, null, k) : Array.isArray(k) ? v(y, {
      children: k
    }, null, null, null) : k.__b > 0 ? v(k.type, k.props, k.key, null, k.__v) : k)) {
      if (k.__ = u, k.__b = u.__b + 1, null === (_ = A[h]) || _ && k.key == _.key && k.type === _.type) A[h] = void 0;else for (p = 0; p < P; p++) {
        if ((_ = A[p]) && k.key == _.key && k.type === _.type) {
          A[p] = void 0;
          break;
        }

        _ = null;
      }
      I(n, k, _ = _ || preact_module_r, t, o, e, c, s, a), b = k.__e, (p = k.ref) && _.ref != p && (w || (w = []), _.ref && w.push(_.ref, null, k), w.push(p, k.__c || b, k)), null != b ? (null == m && (m = b), "function" == typeof k.type && null != k.__k && k.__k === _.__k ? k.__d = s = g(k, s, n) : s = x(n, k, _, A, b, s), a || "option" !== u.type ? "function" == typeof u.type && (u.__d = s) : n.value = "") : s && _.__e == s && s.parentNode != n && (s = d(_));
    }
  }

  for (u.__e = m, h = P; h--;) {
    null != A[h] && ("function" == typeof u.type && null != A[h].__e && A[h].__e == u.__d && (u.__d = d(i, h + 1)), L(A[h], A[h]));
  }

  if (w) for (h = 0; h < w.length; h++) {
    z(w[h], w[++h], w[++h]);
  }
}

function g(n, l, u) {
  var i, t;

  for (i = 0; i < n.__k.length; i++) {
    (t = n.__k[i]) && (t.__ = n, l = "function" == typeof t.type ? g(t, l, u) : x(u, t, t, n.__k, t.__e, l));
  }

  return l;
}

function w(n, l) {
  return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
    w(n, l);
  }) : l.push(n)), l;
}

function x(n, l, u, i, t, o) {
  var r, f, e;
  if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
    for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) {
      if (f == t) break n;
    }

    n.insertBefore(t, o), r = o;
  }
  return void 0 !== r ? r : t.nextSibling;
}

function A(n, l, u, i, t) {
  var o;

  for (o in u) {
    "children" === o || "key" === o || o in l || C(n, o, null, u[o], i);
  }

  for (o in l) {
    t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || C(n, o, l[o], u[o], i);
  }
}

function P(n, l, u) {
  "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || preact_module_e.test(l) ? u : u + "px";
}

function C(n, l, u, i, t) {
  var o;

  n: if ("style" === l) {
    if ("string" == typeof u) n.style.cssText = u;else {
      if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) {
        u && l in u || P(n.style, l, "");
      }
      if (u) for (l in u) {
        i && u[l] === i[l] || P(n.style, l, u[l]);
      }
    }
  } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? H : $, o) : n.removeEventListener(l, o ? H : $, o);else if ("dangerouslySetInnerHTML" !== l) {
    if (t) l = l.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
      n[l] = null == u ? "" : u;
      break n;
    } catch (n) {}
    "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
  }
}

function $(l) {
  this.l[l.type + !1](preact_module_n.event ? preact_module_n.event(l) : l);
}

function H(l) {
  this.l[l.type + !0](preact_module_n.event ? preact_module_n.event(l) : l);
}

function I(l, u, i, t, o, r, f, e, s) {
  var a,
      v,
      h,
      d,
      _,
      k,
      b,
      g,
      w,
      x,
      A,
      P = u.type;

  if (void 0 !== u.constructor) return null;
  null != i.__h && (s = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (a = preact_module_n.__b) && a(u);

  try {
    n: if ("function" == typeof P) {
      if (g = u.props, w = (a = P.contextType) && t[a.__c], x = a ? w ? w.props.value : a.__ : t, i.__c ? b = (v = u.__c = i.__c).__ = v.__E : ("prototype" in P && P.prototype.render ? u.__c = v = new P(g, x) : (u.__c = v = new p(g, x), v.constructor = P, v.render = M), w && w.sub(v), v.props = g, v.state || (v.state = {}), v.context = x, v.__n = t, h = v.__d = !0, v.__h = []), null == v.__s && (v.__s = v.state), null != P.getDerivedStateFromProps && (v.__s == v.state && (v.__s = c({}, v.__s)), c(v.__s, P.getDerivedStateFromProps(g, v.__s))), d = v.props, _ = v.state, h) null == P.getDerivedStateFromProps && null != v.componentWillMount && v.componentWillMount(), null != v.componentDidMount && v.__h.push(v.componentDidMount);else {
        if (null == P.getDerivedStateFromProps && g !== d && null != v.componentWillReceiveProps && v.componentWillReceiveProps(g, x), !v.__e && null != v.shouldComponentUpdate && !1 === v.shouldComponentUpdate(g, v.__s, x) || u.__v === i.__v) {
          v.props = g, v.state = v.__s, u.__v !== i.__v && (v.__d = !1), v.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
            n && (n.__ = u);
          }), v.__h.length && f.push(v);
          break n;
        }

        null != v.componentWillUpdate && v.componentWillUpdate(g, v.__s, x), null != v.componentDidUpdate && v.__h.push(function () {
          v.componentDidUpdate(d, _, k);
        });
      }
      v.context = x, v.props = g, v.state = v.__s, (a = preact_module_n.__r) && a(u), v.__d = !1, v.__v = u, v.__P = l, a = v.render(v.props, v.state, v.context), v.state = v.__s, null != v.getChildContext && (t = c(c({}, t), v.getChildContext())), h || null == v.getSnapshotBeforeUpdate || (k = v.getSnapshotBeforeUpdate(d, _)), A = null != a && a.type === y && null == a.key ? a.props.children : a, m(l, Array.isArray(A) ? A : [A], u, i, t, o, r, f, e, s), v.base = u.__e, u.__h = null, v.__h.length && f.push(v), b && (v.__E = v.__ = null), v.__e = !1;
    } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = j(i.__e, u, i, t, o, r, f, s);

    (a = preact_module_n.diffed) && a(u);
  } catch (l) {
    u.__v = null, (s || null != r) && (u.__e = e, u.__h = !!s, r[r.indexOf(e)] = null), preact_module_n.__e(l, u, i);
  }
}

function T(l, u) {
  preact_module_n.__c && preact_module_n.__c(u, l), l.some(function (u) {
    try {
      l = u.__h, u.__h = [], l.some(function (n) {
        n.call(u);
      });
    } catch (l) {
      preact_module_n.__e(l, u.__v);
    }
  });
}

function j(n, l, u, i, t, o, e, c) {
  var a,
      v,
      h,
      y,
      p = u.props,
      d = l.props,
      _ = l.type,
      k = 0;
  if ("svg" === _ && (t = !0), null != o) for (; k < o.length; k++) {
    if ((a = o[k]) && (a === n || (_ ? a.localName == _ : 3 == a.nodeType))) {
      n = a, o[k] = null;
      break;
    }
  }

  if (null == n) {
    if (null === _) return document.createTextNode(d);
    n = t ? document.createElementNS("http://www.w3.org/2000/svg", _) : document.createElement(_, d.is && d), o = null, c = !1;
  }

  if (null === _) p === d || c && n.data === d || (n.data = d);else {
    if (o = o && f.slice.call(n.childNodes), v = (p = u.props || preact_module_r).dangerouslySetInnerHTML, h = d.dangerouslySetInnerHTML, !c) {
      if (null != o) for (p = {}, y = 0; y < n.attributes.length; y++) {
        p[n.attributes[y].name] = n.attributes[y].value;
      }
      (h || v) && (h && (v && h.__html == v.__html || h.__html === n.innerHTML) || (n.innerHTML = h && h.__html || ""));
    }

    if (A(n, d, p, t, c), h) l.__k = [];else if (k = l.props.children, m(n, Array.isArray(k) ? k : [k], l, u, i, t && "foreignObject" !== _, o, e, n.firstChild, c), null != o) for (k = o.length; k--;) {
      null != o[k] && s(o[k]);
    }
    c || ("value" in d && void 0 !== (k = d.value) && (k !== n.value || "progress" === _ && !k) && C(n, "value", k, p.value, !1), "checked" in d && void 0 !== (k = d.checked) && k !== n.checked && C(n, "checked", k, p.checked, !1));
  }
  return n;
}

function z(l, u, i) {
  try {
    "function" == typeof l ? l(u) : l.current = u;
  } catch (l) {
    preact_module_n.__e(l, i);
  }
}

function L(l, u, i) {
  var t, o, r;

  if (preact_module_n.unmount && preact_module_n.unmount(l), (t = l.ref) && (t.current && t.current !== l.__e || z(t, null, u)), i || "function" == typeof l.type || (i = null != (o = l.__e)), l.__e = l.__d = void 0, null != (t = l.__c)) {
    if (t.componentWillUnmount) try {
      t.componentWillUnmount();
    } catch (l) {
      preact_module_n.__e(l, u);
    }
    t.base = t.__P = null;
  }

  if (t = l.__k) for (r = 0; r < t.length; r++) {
    t[r] && L(t[r], u, i);
  }
  null != o && s(o);
}

function M(n, l, u) {
  return this.constructor(n, u);
}

function preact_module_N(l, u, i) {
  var t, o, e;
  preact_module_n.__ && preact_module_n.__(l, u), o = (t = "function" == typeof i) ? null : i && i.__k || u.__k, e = [], I(u, l = (!t && i || u).__k = a(y, null, [l]), o || preact_module_r, preact_module_r, void 0 !== u.ownerSVGElement, !t && i ? [i] : o ? null : u.firstChild ? f.slice.call(u.childNodes) : null, e, !t && i ? i : o ? o.__e : u.firstChild, t), T(e, l);
}

function O(n, l) {
  preact_module_N(n, l, O);
}

function S(n, l, u) {
  var i,
      t,
      o,
      r = arguments,
      f = c({}, n.props);

  for (o in l) {
    "key" == o ? i = l[o] : "ref" == o ? t = l[o] : f[o] = l[o];
  }

  if (arguments.length > 3) for (u = [u], o = 3; o < arguments.length; o++) {
    u.push(r[o]);
  }
  return null != u && (f.children = u), v(n.type, f, i || n.key, t || n.ref, null);
}

function q(n, l) {
  var u = {
    __c: l = "__cC" + preact_module_o++,
    __: n,
    Consumer: function Consumer(n, l) {
      return n.children(l);
    },
    Provider: function Provider(n) {
      var u, i;
      return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
        return i;
      }, this.shouldComponentUpdate = function (n) {
        this.props.value !== n.value && u.some(k);
      }, this.sub = function (n) {
        u.push(n);
        var l = n.componentWillUnmount;

        n.componentWillUnmount = function () {
          u.splice(u.indexOf(n), 1), l && l.call(n);
        };
      }), n.children;
    }
  };
  return u.Provider.__ = u.Consumer.contextType = u;
}

preact_module_n = {
  __e: function __e(n, l) {
    for (var u, i, t; l = l.__;) {
      if ((u = l.__c) && !u.__) try {
        if ((i = u.constructor) && null != i.getDerivedStateFromError && (u.setState(i.getDerivedStateFromError(n)), t = u.__d), null != u.componentDidCatch && (u.componentDidCatch(n), t = u.__d), t) return u.__E = u;
      } catch (l) {
        n = l;
      }
    }

    throw n;
  },
  __v: 0
}, l = function l(n) {
  return null != n && void 0 === n.constructor;
}, p.prototype.setState = function (n, l) {
  var u;
  u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = c({}, this.state), "function" == typeof n && (n = n(c({}, u), this.props)), n && c(u, n), null != n && this.__v && (l && this.__h.push(l), k(this));
}, p.prototype.forceUpdate = function (n) {
  this.__v && (this.__e = !0, n && this.__h.push(n), k(this));
}, p.prototype.render = y, preact_module_u = [], preact_module_i = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, b.__r = 0, preact_module_o = 0;

// CONCATENATED MODULE: ./node_modules/preact/hooks/dist/hooks.module.js

var hooks_module_t,
    hooks_module_u,
    hooks_module_r,
    hooks_module_o = 0,
    hooks_module_i = [],
    hooks_module_c = preact_module_n.__b,
    hooks_module_f = preact_module_n.__r,
    hooks_module_e = preact_module_n.diffed,
    hooks_module_a = preact_module_n.__c,
    hooks_module_v = preact_module_n.unmount;

function hooks_module_m(t, r) {
  preact_module_n.__h && preact_module_n.__h(hooks_module_u, t, hooks_module_o || r), hooks_module_o = 0;
  var i = hooks_module_u.__H || (hooks_module_u.__H = {
    __: [],
    __h: []
  });
  return t >= i.__.length && i.__.push({}), i.__[t];
}

function hooks_module_l(n) {
  return hooks_module_o = 1, hooks_module_p(hooks_module_w, n);
}

function hooks_module_p(n, r, o) {
  var i = hooks_module_m(hooks_module_t++, 2);
  return i.t = n, i.__c || (i.__ = [o ? o(r) : hooks_module_w(void 0, r), function (n) {
    var t = i.t(i.__[0], n);
    i.__[0] !== t && (i.__ = [t, i.__[1]], i.__c.setState({}));
  }], i.__c = hooks_module_u), i.__;
}

function hooks_module_y(r, o) {
  var i = hooks_module_m(hooks_module_t++, 3);
  !preact_module_n.__s && hooks_module_k(i.__H, o) && (i.__ = r, i.__H = o, hooks_module_u.__H.__h.push(i));
}

function hooks_module_h(r, o) {
  var i = hooks_module_m(hooks_module_t++, 4);
  !preact_module_n.__s && hooks_module_k(i.__H, o) && (i.__ = r, i.__H = o, hooks_module_u.__h.push(i));
}

function hooks_module_s(n) {
  return hooks_module_o = 5, hooks_module_d(function () {
    return {
      current: n
    };
  }, []);
}

function hooks_module_(n, t, u) {
  hooks_module_o = 6, hooks_module_h(function () {
    "function" == typeof n ? n(t()) : n && (n.current = t());
  }, null == u ? u : u.concat(n));
}

function hooks_module_d(n, u) {
  var r = hooks_module_m(hooks_module_t++, 7);
  return hooks_module_k(r.__H, u) && (r.__ = n(), r.__H = u, r.__h = n), r.__;
}

function hooks_module_A(n, t) {
  return hooks_module_o = 8, hooks_module_d(function () {
    return n;
  }, t);
}

function F(n) {
  var r = hooks_module_u.context[n.__c],
      o = hooks_module_m(hooks_module_t++, 9);
  return o.__c = n, r ? (null == o.__ && (o.__ = !0, r.sub(hooks_module_u)), r.props.value) : n.__;
}

function hooks_module_T(t, u) {
  preact_module_n.useDebugValue && preact_module_n.useDebugValue(u ? u(t) : t);
}

function hooks_module_q(n) {
  var r = hooks_module_m(hooks_module_t++, 10),
      o = hooks_module_l();
  return r.__ = n, hooks_module_u.componentDidCatch || (hooks_module_u.componentDidCatch = function (n) {
    r.__ && r.__(n), o[1](n);
  }), [o[0], function () {
    o[1](void 0);
  }];
}

function hooks_module_x() {
  hooks_module_i.forEach(function (t) {
    if (t.__P) try {
      t.__H.__h.forEach(hooks_module_g), t.__H.__h.forEach(hooks_module_j), t.__H.__h = [];
    } catch (u) {
      t.__H.__h = [], preact_module_n.__e(u, t.__v);
    }
  }), hooks_module_i = [];
}

preact_module_n.__b = function (n) {
  hooks_module_u = null, hooks_module_c && hooks_module_c(n);
}, preact_module_n.__r = function (n) {
  hooks_module_f && hooks_module_f(n), hooks_module_t = 0;
  var r = (hooks_module_u = n.__c).__H;
  r && (r.__h.forEach(hooks_module_g), r.__h.forEach(hooks_module_j), r.__h = []);
}, preact_module_n.diffed = function (t) {
  hooks_module_e && hooks_module_e(t);
  var o = t.__c;
  o && o.__H && o.__H.__h.length && (1 !== hooks_module_i.push(o) && hooks_module_r === preact_module_n.requestAnimationFrame || ((hooks_module_r = preact_module_n.requestAnimationFrame) || function (n) {
    var t,
        u = function u() {
      clearTimeout(r), hooks_module_b && cancelAnimationFrame(t), setTimeout(n);
    },
        r = setTimeout(u, 100);

    hooks_module_b && (t = requestAnimationFrame(u));
  })(hooks_module_x)), hooks_module_u = void 0;
}, preact_module_n.__c = function (t, u) {
  u.some(function (t) {
    try {
      t.__h.forEach(hooks_module_g), t.__h = t.__h.filter(function (n) {
        return !n.__ || hooks_module_j(n);
      });
    } catch (r) {
      u.some(function (n) {
        n.__h && (n.__h = []);
      }), u = [], preact_module_n.__e(r, t.__v);
    }
  }), hooks_module_a && hooks_module_a(t, u);
}, preact_module_n.unmount = function (t) {
  hooks_module_v && hooks_module_v(t);
  var u = t.__c;
  if (u && u.__H) try {
    u.__H.__.forEach(hooks_module_g);
  } catch (t) {
    preact_module_n.__e(t, u.__v);
  }
};
var hooks_module_b = "function" == typeof requestAnimationFrame;

function hooks_module_g(n) {
  var t = hooks_module_u;
  "function" == typeof n.__c && n.__c(), hooks_module_u = t;
}

function hooks_module_j(n) {
  var t = hooks_module_u;
  n.__c = n.__(), hooks_module_u = t;
}

function hooks_module_k(n, t) {
  return !n || n.length !== t.length || t.some(function (t, u) {
    return t !== n[u];
  });
}

function hooks_module_w(n, t) {
  return "function" == typeof t ? t(n) : t;
}


// CONCATENATED MODULE: ./node_modules/preact/compat/dist/compat.module.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }






function compat_module_C(n, t) {
  for (var e in t) {
    n[e] = t[e];
  }

  return n;
}

function compat_module_S(n, t) {
  for (var e in n) {
    if ("__source" !== e && !(e in t)) return !0;
  }

  for (var r in t) {
    if ("__source" !== r && n[r] !== t[r]) return !0;
  }

  return !1;
}

function E(n) {
  this.props = n;
}

function compat_module_g(n, t) {
  function e(n) {
    var e = this.props.ref,
        r = e == n.ref;
    return !r && e && (e.call ? e(null) : e.current = null), t ? !t(this.props, n) || !r : compat_module_S(this.props, n);
  }

  function r(t) {
    return this.shouldComponentUpdate = e, a(n, t);
  }

  return r.displayName = "Memo(" + (n.displayName || n.name) + ")", r.prototype.isReactComponent = !0, r.__f = !0, r;
}

(E.prototype = new p()).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function (n, t) {
  return compat_module_S(this.props, n) || compat_module_S(this.state, t);
};
var compat_module_w = preact_module_n.__b;

preact_module_n.__b = function (n) {
  n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), compat_module_w && compat_module_w(n);
};

var R = "undefined" != typeof Symbol && Symbol["for"] && Symbol["for"]("react.forward_ref") || 3911;

function compat_module_x(n) {
  function t(t, e) {
    var r = compat_module_C({}, t);
    return delete r.ref, n(r, (e = t.ref || e) && ("object" != _typeof(e) || "current" in e) ? e : null);
  }

  return t.$$typeof = R, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
}

var compat_module_N = function N(n, t) {
  return null == n ? null : w(w(n).map(t));
},
    compat_module_k = {
  map: compat_module_N,
  forEach: compat_module_N,
  count: function count(n) {
    return n ? w(n).length : 0;
  },
  only: function only(n) {
    var t = w(n);
    if (1 !== t.length) throw "Children.only";
    return t[0];
  },
  toArray: w
},
    compat_module_A = preact_module_n.__e;

preact_module_n.__e = function (n, t, e) {
  if (n.then) for (var r, u = t; u = u.__;) {
    if ((r = u.__c) && r.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), r.__c(n, t);
  }
  compat_module_A(n, t, e);
};

var compat_module_O = preact_module_n.unmount;

function compat_module_L() {
  this.__u = 0, this.t = null, this.__b = null;
}

function U(n) {
  var t = n.__.__c;
  return t && t.__e && t.__e(n);
}

function D(n) {
  var t, e, r;

  function u(u) {
    if (t || (t = n()).then(function (n) {
      e = n["default"] || n;
    }, function (n) {
      r = n;
    }), r) throw r;
    if (!e) throw t;
    return a(e, u);
  }

  return u.displayName = "Lazy", u.__f = !0, u;
}

function compat_module_F() {
  this.u = null, this.o = null;
}

preact_module_n.unmount = function (n) {
  var t = n.__c;
  t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), compat_module_O && compat_module_O(n);
}, (compat_module_L.prototype = new p()).__c = function (n, t) {
  var e = t.__c,
      r = this;
  null == r.t && (r.t = []), r.t.push(e);

  var u = U(r.__v),
      o = !1,
      i = function i() {
    o || (o = !0, e.__R = null, u ? u(l) : l());
  };

  e.__R = i;

  var l = function l() {
    if (! --r.__u) {
      if (r.state.__e) {
        var n = r.state.__e;

        r.__v.__k[0] = function n(t, e, r) {
          return t && (t.__v = null, t.__k = t.__k && t.__k.map(function (t) {
            return n(t, e, r);
          }), t.__c && t.__c.__P === e && (t.__e && r.insertBefore(t.__e, t.__d), t.__c.__e = !0, t.__c.__P = r)), t;
        }(n, n.__c.__P, n.__c.__O);
      }

      var t;

      for (r.setState({
        __e: r.__b = null
      }); t = r.t.pop();) {
        t.forceUpdate();
      }
    }
  },
      f = !0 === t.__h;

  r.__u++ || f || r.setState({
    __e: r.__b = r.__v.__k[0]
  }), n.then(i, i);
}, compat_module_L.prototype.componentWillUnmount = function () {
  this.t = [];
}, compat_module_L.prototype.render = function (n, t) {
  if (this.__b) {
    if (this.__v.__k) {
      var e = document.createElement("div"),
          r = this.__v.__k[0].__c;

      this.__v.__k[0] = function n(t, e, r) {
        return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach(function (n) {
          "function" == typeof n.__c && n.__c();
        }), t.__c.__H = null), null != (t = compat_module_C({}, t)).__c && (t.__c.__P === r && (t.__c.__P = e), t.__c = null), t.__k = t.__k && t.__k.map(function (t) {
          return n(t, e, r);
        })), t;
      }(this.__b, e, r.__O = r.__P);
    }

    this.__b = null;
  }

  var u = t.__e && a(y, null, n.fallback);
  return u && (u.__h = null), [a(y, null, t.__e ? null : n.children), u];
};

var compat_module_M = function M(n, t, e) {
  if (++e[1] === e[0] && n.o["delete"](t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
    for (; e.length > 3;) {
      e.pop()();
    }

    if (e[1] < e[0]) break;
    n.u = e = e[2];
  }
};

function compat_module_T(n) {
  return this.getChildContext = function () {
    return n.context;
  }, n.children;
}

function compat_module_j(n) {
  var t = this,
      e = n.i;
  t.componentWillUnmount = function () {
    preact_module_N(null, t.l), t.l = null, t.i = null;
  }, t.i && t.i !== e && t.componentWillUnmount(), n.__v ? (t.l || (t.i = e, t.l = {
    nodeType: 1,
    parentNode: e,
    childNodes: [],
    appendChild: function appendChild(n) {
      this.childNodes.push(n), t.i.appendChild(n);
    },
    insertBefore: function insertBefore(n, e) {
      this.childNodes.push(n), t.i.appendChild(n);
    },
    removeChild: function removeChild(n) {
      this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), t.i.removeChild(n);
    }
  }), preact_module_N(a(compat_module_T, {
    context: t.context
  }, n.__v), t.l)) : t.l && t.componentWillUnmount();
}

function compat_module_I(n, t) {
  return a(compat_module_j, {
    __v: n,
    i: t
  });
}

(compat_module_F.prototype = new p()).__e = function (n) {
  var t = this,
      e = U(t.__v),
      r = t.o.get(n);
  return r[0]++, function (u) {
    var o = function o() {
      t.props.revealOrder ? (r.push(u), compat_module_M(t, n, r)) : u();
    };

    e ? e(o) : o();
  };
}, compat_module_F.prototype.render = function (n) {
  this.u = null, this.o = new Map();
  var t = w(n.children);
  n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

  for (var e = t.length; e--;) {
    this.o.set(t[e], this.u = [1, 0, this.u]);
  }

  return n.children;
}, compat_module_F.prototype.componentDidUpdate = compat_module_F.prototype.componentDidMount = function () {
  var n = this;
  this.o.forEach(function (t, e) {
    compat_module_M(n, e, t);
  });
};

var W = "undefined" != typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103,
    compat_module_P = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
    V = function V(n) {
  return ("undefined" != typeof Symbol && "symbol" == _typeof(Symbol()) ? /fil|che|rad/i : /fil|che|ra/i).test(n);
};

function compat_module_z(n, t, e) {
  return null == t.__k && (t.textContent = ""), preact_module_N(n, t), "function" == typeof e && e(), n ? n.__c : null;
}

function B(n, t, e) {
  return O(n, t), "function" == typeof e && e(), n ? n.__c : null;
}

p.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (n) {
  Object.defineProperty(p.prototype, n, {
    configurable: !0,
    get: function get() {
      return this["UNSAFE_" + n];
    },
    set: function set(t) {
      Object.defineProperty(this, n, {
        configurable: !0,
        writable: !0,
        value: t
      });
    }
  });
});
var compat_module_H = preact_module_n.event;

function Z() {}

function Y() {
  return this.cancelBubble;
}

function compat_module_$() {
  return this.defaultPrevented;
}

preact_module_n.event = function (n) {
  return compat_module_H && (n = compat_module_H(n)), n.persist = Z, n.isPropagationStopped = Y, n.isDefaultPrevented = compat_module_$, n.nativeEvent = n;
};

var compat_module_q,
    G = {
  configurable: !0,
  get: function get() {
    return this["class"];
  }
},
    J = preact_module_n.vnode;

preact_module_n.vnode = function (n) {
  var t = n.type,
      e = n.props,
      r = e;

  if ("string" == typeof t) {
    for (var u in r = {}, e) {
      var o = e[u];
      "value" === u && "defaultValue" in e && null == o || ("defaultValue" === u && "value" in e && null == e.value ? u = "value" : "download" === u && !0 === o ? o = "" : /ondoubleclick/i.test(u) ? u = "ondblclick" : /^onchange(textarea|input)/i.test(u + t) && !V(e.type) ? u = "oninput" : /^on(Ani|Tra|Tou|BeforeInp)/.test(u) ? u = u.toLowerCase() : compat_module_P.test(u) ? u = u.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === o && (o = void 0), r[u] = o);
    }

    "select" == t && r.multiple && Array.isArray(r.value) && (r.value = w(e.children).forEach(function (n) {
      n.props.selected = -1 != r.value.indexOf(n.props.value);
    })), "select" == t && null != r.defaultValue && (r.value = w(e.children).forEach(function (n) {
      n.props.selected = r.multiple ? -1 != r.defaultValue.indexOf(n.props.value) : r.defaultValue == n.props.value;
    })), n.props = r;
  }

  t && e["class"] != e.className && (G.enumerable = "className" in e, null != e.className && (r["class"] = e.className), Object.defineProperty(r, "className", G)), n.$$typeof = W, J && J(n);
};

var K = preact_module_n.__r;

preact_module_n.__r = function (n) {
  K && K(n), compat_module_q = n.__c;
};

var Q = {
  ReactCurrentDispatcher: {
    current: {
      readContext: function readContext(n) {
        return compat_module_q.__n[n.__c].props.value;
      }
    }
  }
},
    X = 1,
    nn = 2,
    tn = 3,
    en = 4,
    rn = 5;

function un(n, t) {
  return t();
}

var on = "object" == (typeof performance === "undefined" ? "undefined" : _typeof(performance)) && "function" == typeof performance.now ? performance.now.bind(performance) : function () {
  return Date.now();
},
    ln = "16.8.0";

function fn(n) {
  return a.bind(null, n);
}

function cn(n) {
  return !!n && n.$$typeof === W;
}

function an(n) {
  return cn(n) ? S.apply(null, arguments) : n;
}

function sn(n) {
  return !!n.__k && (preact_module_N(null, n), !0);
}

function hn(n) {
  return n && (n.base || 1 === n.nodeType && n) || null;
}

var pn = function pn(n, t) {
  return n(t);
},
    vn = y;

/* harmony default export */ var compat_module = __webpack_exports__["default"] = ({
  useState: hooks_module_l,
  useReducer: hooks_module_p,
  useEffect: hooks_module_y,
  useLayoutEffect: hooks_module_h,
  useRef: hooks_module_s,
  useImperativeHandle: hooks_module_,
  useMemo: hooks_module_d,
  useCallback: hooks_module_A,
  useContext: F,
  useDebugValue: hooks_module_T,
  version: "16.8.0",
  Children: compat_module_k,
  render: compat_module_z,
  hydrate: B,
  unmountComponentAtNode: sn,
  createPortal: compat_module_I,
  createElement: a,
  createContext: q,
  createFactory: fn,
  cloneElement: an,
  createRef: h,
  Fragment: y,
  isValidElement: cn,
  findDOMNode: hn,
  Component: p,
  PureComponent: E,
  memo: compat_module_g,
  forwardRef: compat_module_x,
  unstable_batchedUpdates: pn,
  StrictMode: y,
  Suspense: compat_module_L,
  SuspenseList: compat_module_F,
  lazy: D,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: Q
});


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(41)();
}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function E() {// Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
  on: function on(name, callback, ctx) {
    var e = this.e || (this.e = {});
    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });
    return this;
  },
  once: function once(name, callback, ctx) {
    var self = this;

    function listener() {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    }

    ;
    listener._ = callback;
    return this.on(name, listener, ctx);
  },
  emit: function emit(name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },
  off: function off(name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
      }
    } // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910


    liveEvents.length ? e[name] = liveEvents : delete e[name];
    return this;
  }
};
module.exports = E;
module.exports.TinyEmitter = E;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__3__;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findInArray = findInArray;
exports.isFunction = isFunction;
exports.isNum = isNum;
exports["int"] = _int;
exports.dontSetMe = dontSetMe; // @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc

function findInArray(array
/*: Array<any> | TouchList*/
, callback
/*: Function*/
)
/*: any*/
{
  for (var i = 0, length = array.length; i < length; i++) {
    if (callback.apply(callback, [array[i], i, array])) return array[i];
  }
}

function isFunction(func
/*: any*/
)
/*: boolean %checks*/
{
  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
}

function isNum(num
/*: any*/
)
/*: boolean %checks*/
{
  return typeof num === 'number' && !isNaN(num);
}

function _int(a
/*: string*/
)
/*: number*/
{
  return parseInt(a, 10);
}

function dontSetMe(props
/*: Object*/
, propName
/*: string*/
, componentName
/*: string*/
) {
  if (props[propName]) {
    return new Error("Invalid prop ".concat(propName, " passed to ").concat(componentName, " - do not set this, set it on the child."));
  }
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var undefined;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError; // eslint-disable-next-line consistent-return

var getEvalledConstructor = function getEvalledConstructor(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;

if ($gOPD) {
  try {
    $gOPD({}, '');
  } catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
  }
}

var throwTypeError = function throwTypeError() {
  throw new $TypeError();
};

var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here

    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;

var hasSymbols = __webpack_require__(51)();

var getProto = Object.getPrototypeOf || function (x) {
  return x.__proto__;
}; // eslint-disable-line no-proto


var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': needsEval,
  '%AsyncGenerator%': needsEval,
  '%AsyncGeneratorFunction%': needsEval,
  '%AsyncIteratorPrototype%': needsEval,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': EvalError,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
  '%Function%': $Function,
  '%GeneratorFunction%': needsEval,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': (typeof JSON === "undefined" ? "undefined" : _typeof(JSON)) === 'object' ? JSON : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': Object,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': RangeError,
  '%ReferenceError%': ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SyntaxError%': $SyntaxError,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypeError%': $TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%URIError%': URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
  var value;

  if (name === '%AsyncFunction%') {
    value = getEvalledConstructor('async function () {}');
  } else if (name === '%GeneratorFunction%') {
    value = getEvalledConstructor('function* () {}');
  } else if (name === '%AsyncGeneratorFunction%') {
    value = getEvalledConstructor('async function* () {}');
  } else if (name === '%AsyncGenerator%') {
    var fn = doEval('%AsyncGeneratorFunction%');

    if (fn) {
      value = fn.prototype;
    }
  } else if (name === '%AsyncIteratorPrototype%') {
    var gen = doEval('%AsyncGenerator%');

    if (gen) {
      value = getProto(gen.prototype);
    }
  }

  INTRINSICS[name] = value;
  return value;
};

var LEGACY_ALIASES = {
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(8);

var hasOwn = __webpack_require__(15);

var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */

var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
/** Used to match backslashes in property paths. */

var stringToPath = function stringToPath(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);

  if (first === '%' && last !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  } else if (last === '%' && first !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  }

  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */


var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;

  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }

  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];

    if (value === needsEval) {
      value = doEval(intrinsicName);
    }

    if (typeof value === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }

    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }

  throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $TypeError('intrinsic name must be a non-empty string');
  }

  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }

  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;

  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }

  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);

    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
      throw new $SyntaxError('property names with quotes must have matching quotes');
    }

    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }

    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';

    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }

        return void undefined;
      }

      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc; // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.

        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }

      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }

  return value;
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // do not edit .js files directly - edit src/index.jst

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && _typeof(a) == 'object' && _typeof(b) == 'object') {
    if (a.constructor !== b.constructor) return false;
    var length, i, keys;

    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;

      for (i = length; i-- !== 0;) {
        if (!equal(a[i], b[i])) return false;
      }

      return true;
    }

    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
    }

    for (i = length; i-- !== 0;) {
      var key = keys[i];
      if (!equal(a[key], b[key])) return false;
    }

    return true;
  } // true if both NaN, false otherwise


  return a !== a && b !== b;
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchesSelector = matchesSelector;
exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
exports.addEvent = addEvent;
exports.removeEvent = removeEvent;
exports.outerHeight = outerHeight;
exports.outerWidth = outerWidth;
exports.innerHeight = innerHeight;
exports.innerWidth = innerWidth;
exports.offsetXYFromParent = offsetXYFromParent;
exports.createCSSTransform = createCSSTransform;
exports.createSVGTransform = createSVGTransform;
exports.getTranslation = getTranslation;
exports.getTouch = getTouch;
exports.getTouchIdentifier = getTouchIdentifier;
exports.addUserSelectStyles = addUserSelectStyles;
exports.removeUserSelectStyles = removeUserSelectStyles;
exports.addClassName = addClassName;
exports.removeClassName = removeClassName;

var _shims = __webpack_require__(4);

var _getPrefix = _interopRequireWildcard(__webpack_require__(44));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var matchesSelectorFunc = '';

function matchesSelector(el
/*: Node*/
, selector
/*: string*/
)
/*: boolean*/
{
  if (!matchesSelectorFunc) {
    matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {
      // $FlowIgnore: Doesn't think elements are indexable
      return (0, _shims.isFunction)(el[method]);
    });
  } // Might not be found entirely (not an Element?) - in that case, bail
  // $FlowIgnore: Doesn't think elements are indexable


  if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false; // $FlowIgnore: Doesn't think elements are indexable

  return el[matchesSelectorFunc](selector);
} // Works up the tree to the draggable itself attempting to match selector.


function matchesSelectorAndParentsTo(el
/*: Node*/
, selector
/*: string*/
, baseNode
/*: Node*/
)
/*: boolean*/
{
  var node = el;

  do {
    if (matchesSelector(node, selector)) return true;
    if (node === baseNode) return false;
    node = node.parentNode;
  } while (node);

  return false;
}

function addEvent(el
/*: ?Node*/
, event
/*: string*/
, handler
/*: Function*/
, inputOptions
/*: Object*/
)
/*: void*/
{
  if (!el) return;

  var options = _objectSpread({
    capture: true
  }, inputOptions);

  if (el.addEventListener) {
    el.addEventListener(event, handler, options);
  } else if (el.attachEvent) {
    el.attachEvent('on' + event, handler);
  } else {
    // $FlowIgnore: Doesn't think elements are indexable
    el['on' + event] = handler;
  }
}

function removeEvent(el
/*: ?Node*/
, event
/*: string*/
, handler
/*: Function*/
, inputOptions
/*: Object*/
)
/*: void*/
{
  if (!el) return;

  var options = _objectSpread({
    capture: true
  }, inputOptions);

  if (el.removeEventListener) {
    el.removeEventListener(event, handler, options);
  } else if (el.detachEvent) {
    el.detachEvent('on' + event, handler);
  } else {
    // $FlowIgnore: Doesn't think elements are indexable
    el['on' + event] = null;
  }
}

function outerHeight(node
/*: HTMLElement*/
)
/*: number*/
{
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetTop which is including margin. See getBoundPosition
  var height = node.clientHeight;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  height += (0, _shims["int"])(computedStyle.borderTopWidth);
  height += (0, _shims["int"])(computedStyle.borderBottomWidth);
  return height;
}

function outerWidth(node
/*: HTMLElement*/
)
/*: number*/
{
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetLeft which is including margin. See getBoundPosition
  var width = node.clientWidth;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  width += (0, _shims["int"])(computedStyle.borderLeftWidth);
  width += (0, _shims["int"])(computedStyle.borderRightWidth);
  return width;
}

function innerHeight(node
/*: HTMLElement*/
)
/*: number*/
{
  var height = node.clientHeight;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  height -= (0, _shims["int"])(computedStyle.paddingTop);
  height -= (0, _shims["int"])(computedStyle.paddingBottom);
  return height;
}

function innerWidth(node
/*: HTMLElement*/
)
/*: number*/
{
  var width = node.clientWidth;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  width -= (0, _shims["int"])(computedStyle.paddingLeft);
  width -= (0, _shims["int"])(computedStyle.paddingRight);
  return width;
} // Get from offsetParent


function offsetXYFromParent(evt
/*: {clientX: number, clientY: number}*/
, offsetParent
/*: HTMLElement*/
, scale
/*: number*/
)
/*: ControlPosition*/
{
  var isBody = offsetParent === offsetParent.ownerDocument.body;
  var offsetParentRect = isBody ? {
    left: 0,
    top: 0
  } : offsetParent.getBoundingClientRect();
  var x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
  var y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
  return {
    x: x,
    y: y
  };
}

function createCSSTransform(controlPos
/*: ControlPosition*/
, positionOffset
/*: PositionOffsetControlPosition*/
)
/*: Object*/
{
  var translation = getTranslation(controlPos, positionOffset, 'px');
  return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)('transform', _getPrefix["default"]), translation);
}

function createSVGTransform(controlPos
/*: ControlPosition*/
, positionOffset
/*: PositionOffsetControlPosition*/
)
/*: string*/
{
  var translation = getTranslation(controlPos, positionOffset, '');
  return translation;
}

function getTranslation(_ref2, positionOffset
/*: PositionOffsetControlPosition*/
, unitSuffix
/*: string*/
)
/*: string*/
{
  var x = _ref2.x,
      y = _ref2.y;
  var translation = "translate(".concat(x).concat(unitSuffix, ",").concat(y).concat(unitSuffix, ")");

  if (positionOffset) {
    var defaultX = "".concat(typeof positionOffset.x === 'string' ? positionOffset.x : positionOffset.x + unitSuffix);
    var defaultY = "".concat(typeof positionOffset.y === 'string' ? positionOffset.y : positionOffset.y + unitSuffix);
    translation = "translate(".concat(defaultX, ", ").concat(defaultY, ")") + translation;
  }

  return translation;
}

function getTouch(e
/*: MouseTouchEvent*/
, identifier
/*: number*/
)
/*: ?{clientX: number, clientY: number}*/
{
  return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, function (t) {
    return identifier === t.identifier;
  }) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, function (t) {
    return identifier === t.identifier;
  });
}

function getTouchIdentifier(e
/*: MouseTouchEvent*/
)
/*: ?number*/
{
  if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
  if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
} // User-select Hacks:
//
// Useful for preventing blue highlights all over everything when dragging.
// Note we're passing `document` b/c we could be iframed


function addUserSelectStyles(doc
/*: ?Document*/
) {
  if (!doc) return;
  var styleEl = doc.getElementById('react-draggable-style-el');

  if (!styleEl) {
    styleEl = doc.createElement('style');
    styleEl.type = 'text/css';
    styleEl.id = 'react-draggable-style-el';
    styleEl.innerHTML = '.react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n';
    styleEl.innerHTML += '.react-draggable-transparent-selection *::selection {all: inherit;}\n';
    doc.getElementsByTagName('head')[0].appendChild(styleEl);
  }

  if (doc.body) addClassName(doc.body, 'react-draggable-transparent-selection');
}

function removeUserSelectStyles(doc
/*: ?Document*/
) {
  if (!doc) return;

  try {
    if (doc.body) removeClassName(doc.body, 'react-draggable-transparent-selection'); // $FlowIgnore: IE

    if (doc.selection) {
      // $FlowIgnore: IE
      doc.selection.empty();
    } else {
      // Remove selection caused by scroll, unless it's a focused input
      // (we use doc.defaultView in case we're in an iframe)
      var selection = (doc.defaultView || window).getSelection();

      if (selection && selection.type !== 'Caret') {
        selection.removeAllRanges();
      }
    }
  } catch (e) {// probably IE
  }
}

function addClassName(el
/*: HTMLElement*/
, className
/*: string*/
) {
  if (el.classList) {
    el.classList.add(className);
  } else {
    if (!el.className.match(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)")))) {
      el.className += " ".concat(className);
    }
  }
}

function removeClassName(el
/*: HTMLElement*/
, className
/*: string*/
) {
  if (el.classList) {
    el.classList.remove(className);
  } else {
    el.className = el.className.replace(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)"), 'g'), '');
  }
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(49);

module.exports = Function.prototype.bind || implementation;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _objectWithoutProperties(obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var sizerStyle = {
  position: 'absolute',
  top: 0,
  left: 0,
  visibility: 'hidden',
  height: 0,
  overflow: 'scroll',
  whiteSpace: 'pre'
};
var INPUT_PROPS_BLACKLIST = ['extraWidth', 'injectStyles', 'inputClassName', 'inputRef', 'inputStyle', 'minWidth', 'onAutosize', 'placeholderIsMinWidth'];

var cleanInputProps = function cleanInputProps(inputProps) {
  INPUT_PROPS_BLACKLIST.forEach(function (field) {
    return delete inputProps[field];
  });
  return inputProps;
};

var copyStyles = function copyStyles(styles, node) {
  node.style.fontSize = styles.fontSize;
  node.style.fontFamily = styles.fontFamily;
  node.style.fontWeight = styles.fontWeight;
  node.style.fontStyle = styles.fontStyle;
  node.style.letterSpacing = styles.letterSpacing;
  node.style.textTransform = styles.textTransform;
};

var isIE = typeof window !== 'undefined' && window.navigator ? /MSIE |Trident\/|Edge\//.test(window.navigator.userAgent) : false;

var generateId = function generateId() {
  // we only need an auto-generated ID for stylesheet injection, which is only
  // used for IE. so if the browser is not IE, this should return undefined.
  return isIE ? '_' + Math.random().toString(36).substr(2, 12) : undefined;
};

var AutosizeInput = function (_Component) {
  _inherits(AutosizeInput, _Component);

  _createClass(AutosizeInput, null, [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      var id = props.id;
      return id !== state.prevId ? {
        inputId: id || generateId(),
        prevId: id
      } : null;
    }
  }]);

  function AutosizeInput(props) {
    _classCallCheck(this, AutosizeInput);

    var _this = _possibleConstructorReturn(this, (AutosizeInput.__proto__ || Object.getPrototypeOf(AutosizeInput)).call(this, props));

    _this.inputRef = function (el) {
      _this.input = el;

      if (typeof _this.props.inputRef === 'function') {
        _this.props.inputRef(el);
      }
    };

    _this.placeHolderSizerRef = function (el) {
      _this.placeHolderSizer = el;
    };

    _this.sizerRef = function (el) {
      _this.sizer = el;
    };

    _this.state = {
      inputWidth: props.minWidth,
      inputId: props.id || generateId(),
      prevId: props.id
    };
    return _this;
  }

  _createClass(AutosizeInput, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.mounted = true;
      this.copyInputStyles();
      this.updateInputWidth();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (prevState.inputWidth !== this.state.inputWidth) {
        if (typeof this.props.onAutosize === 'function') {
          this.props.onAutosize(this.state.inputWidth);
        }
      }

      this.updateInputWidth();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.mounted = false;
    }
  }, {
    key: 'copyInputStyles',
    value: function copyInputStyles() {
      if (!this.mounted || !window.getComputedStyle) {
        return;
      }

      var inputStyles = this.input && window.getComputedStyle(this.input);

      if (!inputStyles) {
        return;
      }

      copyStyles(inputStyles, this.sizer);

      if (this.placeHolderSizer) {
        copyStyles(inputStyles, this.placeHolderSizer);
      }
    }
  }, {
    key: 'updateInputWidth',
    value: function updateInputWidth() {
      if (!this.mounted || !this.sizer || typeof this.sizer.scrollWidth === 'undefined') {
        return;
      }

      var newInputWidth = void 0;

      if (this.props.placeholder && (!this.props.value || this.props.value && this.props.placeholderIsMinWidth)) {
        newInputWidth = Math.max(this.sizer.scrollWidth, this.placeHolderSizer.scrollWidth) + 2;
      } else {
        newInputWidth = this.sizer.scrollWidth + 2;
      } // add extraWidth to the detected width. for number types, this defaults to 16 to allow for the stepper UI


      var extraWidth = this.props.type === 'number' && this.props.extraWidth === undefined ? 16 : parseInt(this.props.extraWidth) || 0;
      newInputWidth += extraWidth;

      if (newInputWidth < this.props.minWidth) {
        newInputWidth = this.props.minWidth;
      }

      if (newInputWidth !== this.state.inputWidth) {
        this.setState({
          inputWidth: newInputWidth
        });
      }
    }
  }, {
    key: 'getInput',
    value: function getInput() {
      return this.input;
    }
  }, {
    key: 'focus',
    value: function focus() {
      this.input.focus();
    }
  }, {
    key: 'blur',
    value: function blur() {
      this.input.blur();
    }
  }, {
    key: 'select',
    value: function select() {
      this.input.select();
    }
  }, {
    key: 'renderStyles',
    value: function renderStyles() {
      // this method injects styles to hide IE's clear indicator, which messes
      // with input size detection. the stylesheet is only injected when the
      // browser is IE, and can also be disabled by the `injectStyles` prop.
      var injectStyles = this.props.injectStyles;
      return isIE && injectStyles ? _react2["default"].createElement('style', {
        dangerouslySetInnerHTML: {
          __html: 'input#' + this.state.inputId + '::-ms-clear {display: none;}'
        }
      }) : null;
    }
  }, {
    key: 'render',
    value: function render() {
      var sizerValue = [this.props.defaultValue, this.props.value, ''].reduce(function (previousValue, currentValue) {
        if (previousValue !== null && previousValue !== undefined) {
          return previousValue;
        }

        return currentValue;
      });

      var wrapperStyle = _extends({}, this.props.style);

      if (!wrapperStyle.display) wrapperStyle.display = 'inline-block';

      var inputStyle = _extends({
        boxSizing: 'content-box',
        width: this.state.inputWidth + 'px'
      }, this.props.inputStyle);

      var inputProps = _objectWithoutProperties(this.props, []);

      cleanInputProps(inputProps);
      inputProps.className = this.props.inputClassName;
      inputProps.id = this.state.inputId;
      inputProps.style = inputStyle;
      return _react2["default"].createElement('div', {
        className: this.props.className,
        style: wrapperStyle
      }, this.renderStyles(), _react2["default"].createElement('input', _extends({}, inputProps, {
        ref: this.inputRef
      })), _react2["default"].createElement('div', {
        ref: this.sizerRef,
        style: sizerStyle
      }, sizerValue), this.props.placeholder ? _react2["default"].createElement('div', {
        ref: this.placeHolderSizerRef,
        style: sizerStyle
      }, this.props.placeholder) : null);
    }
  }]);

  return AutosizeInput;
}(_react.Component);

AutosizeInput.propTypes = {
  className: _propTypes2["default"].string,
  // className for the outer element
  defaultValue: _propTypes2["default"].any,
  // default field value
  extraWidth: _propTypes2["default"].oneOfType([// additional width for input element
  _propTypes2["default"].number, _propTypes2["default"].string]),
  id: _propTypes2["default"].string,
  // id to use for the input, can be set for consistent snapshots
  injectStyles: _propTypes2["default"].bool,
  // inject the custom stylesheet to hide clear UI, defaults to true
  inputClassName: _propTypes2["default"].string,
  // className for the input element
  inputRef: _propTypes2["default"].func,
  // ref callback for the input element
  inputStyle: _propTypes2["default"].object,
  // css styles for the input element
  minWidth: _propTypes2["default"].oneOfType([// minimum width for input element
  _propTypes2["default"].number, _propTypes2["default"].string]),
  onAutosize: _propTypes2["default"].func,
  // onAutosize handler: function(newWidth) {}
  onChange: _propTypes2["default"].func,
  // onChange handler: function(event) {}
  placeholder: _propTypes2["default"].string,
  // placeholder text
  placeholderIsMinWidth: _propTypes2["default"].bool,
  // don't collapse size to less than the placeholder
  style: _propTypes2["default"].object,
  // css styles for the outer element
  value: _propTypes2["default"].any // field value

};
AutosizeInput.defaultProps = {
  minWidth: 1,
  injectStyles: true
};
exports["default"] = AutosizeInput;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var reactIs = __webpack_require__(88);
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(90);
} else {}

/***/ }),
/* 12 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBoundPosition = getBoundPosition;
exports.snapToGrid = snapToGrid;
exports.canDragX = canDragX;
exports.canDragY = canDragY;
exports.getControlPosition = getControlPosition;
exports.createCoreData = createCoreData;
exports.createDraggableData = createDraggableData;

var _shims = __webpack_require__(4);

var _domFns = __webpack_require__(7);

function getBoundPosition(draggable
/*: Draggable*/
, x
/*: number*/
, y
/*: number*/
)
/*: [number, number]*/
{
  // If no bounds, short-circuit and move on
  if (!draggable.props.bounds) return [x, y]; // Clone new bounds

  var bounds = draggable.props.bounds;
  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);
  var node = findDOMNode(draggable);

  if (typeof bounds === 'string') {
    var ownerDocument = node.ownerDocument;
    var ownerWindow = ownerDocument.defaultView;
    var boundNode;

    if (bounds === 'parent') {
      boundNode = node.parentNode;
    } else {
      boundNode = ownerDocument.querySelector(bounds);
    }

    if (!(boundNode instanceof ownerWindow.HTMLElement)) {
      throw new Error('Bounds selector "' + bounds + '" could not find an element.');
    }

    var nodeStyle = ownerWindow.getComputedStyle(node);
    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode); // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.

    bounds = {
      left: -node.offsetLeft + (0, _shims["int"])(boundNodeStyle.paddingLeft) + (0, _shims["int"])(nodeStyle.marginLeft),
      top: -node.offsetTop + (0, _shims["int"])(boundNodeStyle.paddingTop) + (0, _shims["int"])(nodeStyle.marginTop),
      right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims["int"])(boundNodeStyle.paddingRight) - (0, _shims["int"])(nodeStyle.marginRight),
      bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims["int"])(boundNodeStyle.paddingBottom) - (0, _shims["int"])(nodeStyle.marginBottom)
    };
  } // Keep x and y below right and bottom limits...


  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom); // But above left and top limits.

  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);
  return [x, y];
}

function snapToGrid(grid
/*: [number, number]*/
, pendingX
/*: number*/
, pendingY
/*: number*/
)
/*: [number, number]*/
{
  var x = Math.round(pendingX / grid[0]) * grid[0];
  var y = Math.round(pendingY / grid[1]) * grid[1];
  return [x, y];
}

function canDragX(draggable
/*: Draggable*/
)
/*: boolean*/
{
  return draggable.props.axis === 'both' || draggable.props.axis === 'x';
}

function canDragY(draggable
/*: Draggable*/
)
/*: boolean*/
{
  return draggable.props.axis === 'both' || draggable.props.axis === 'y';
} // Get {x, y} positions from event.


function getControlPosition(e
/*: MouseTouchEvent*/
, touchIdentifier
/*: ?number*/
, draggableCore
/*: DraggableCore*/
)
/*: ?ControlPosition*/
{
  var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch

  var node = findDOMNode(draggableCore); // User can provide an offsetParent if desired.

  var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);
} // Create an data object exposed by <DraggableCore>'s events


function createCoreData(draggable
/*: DraggableCore*/
, x
/*: number*/
, y
/*: number*/
)
/*: DraggableData*/
{
  var state = draggable.state;
  var isStart = !(0, _shims.isNum)(state.lastX);
  var node = findDOMNode(draggable);

  if (isStart) {
    // If this is our first move, use the x and y as last coords.
    return {
      node: node,
      deltaX: 0,
      deltaY: 0,
      lastX: x,
      lastY: y,
      x: x,
      y: y
    };
  } else {
    // Otherwise calculate proper values.
    return {
      node: node,
      deltaX: x - state.lastX,
      deltaY: y - state.lastY,
      lastX: state.lastX,
      lastY: state.lastY,
      x: x,
      y: y
    };
  }
} // Create an data exposed by <Draggable>'s events


function createDraggableData(draggable
/*: Draggable*/
, coreData
/*: DraggableData*/
)
/*: DraggableData*/
{
  var scale = draggable.props.scale;
  return {
    node: coreData.node,
    x: draggable.state.x + coreData.deltaX / scale,
    y: draggable.state.y + coreData.deltaY / scale,
    deltaX: coreData.deltaX / scale,
    deltaY: coreData.deltaY / scale,
    lastX: draggable.state.x,
    lastY: draggable.state.y
  };
} // A lot faster than stringify/parse


function cloneBounds(bounds
/*: Bounds*/
)
/*: Bounds*/
{
  return {
    left: bounds.left,
    top: bounds.top,
    right: bounds.right,
    bottom: bounds.bottom
  };
}

function findDOMNode(draggable
/*: Draggable | DraggableCore*/
)
/*: HTMLElement*/
{
  var node = draggable.findDOMNode();

  if (!node) {
    throw new Error('<DraggableCore>: Unmounted during event!');
  } // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME


  return node;
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = log;
/*eslint no-console:0*/

function log() {
  var _console;

  if (undefined) (_console = console).log.apply(_console, arguments);
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(8);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(8);

var GetIntrinsic = __webpack_require__(5);

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
  try {
    $defineProperty({}, 'a', {
      value: 1
    });
  } catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = null;
  }
}

module.exports = function callBind(originalFunction) {
  var func = $reflectApply(bind, $call, arguments);

  if ($gOPD && $defineProperty) {
    var desc = $gOPD(func, 'length');

    if (desc.configurable) {
      // original length, plus the receiver, minus any additional arguments (after the receiver)
      $defineProperty(func, 'length', {
        value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
      });
    }
  }

  return func;
};

var applyBind = function applyBind() {
  return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
  $defineProperty(module.exports, 'apply', {
    value: applyBind
  });
} else {
  module.exports.apply = applyBind;
}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var keys = __webpack_require__(53);

var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol('foo')) === 'symbol';
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function isFunction(fn) {
  return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function arePropertyDescriptorsSupported() {
  var obj = {};

  try {
    origDefineProperty(obj, 'x', {
      enumerable: false,
      value: obj
    }); // eslint-disable-next-line no-unused-vars, no-restricted-syntax

    for (var _ in obj) {
      // jscs:ignore disallowUnusedVariables
      return false;
    }

    return obj.x === obj;
  } catch (e) {
    /* this is IE 8. */
    return false;
  }
};

var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function defineProperty(object, name, value, predicate) {
  if (name in object && (!isFunction(predicate) || !predicate())) {
    return;
  }

  if (supportsDescriptors) {
    origDefineProperty(object, name, {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    });
  } else {
    object[name] = value;
  }
};

var defineProperties = function defineProperties(object, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys(map);

  if (hasSymbols) {
    props = concat.call(props, Object.getOwnPropertySymbols(map));
  }

  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
  }
};

defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
  var str = toStr.call(value);
  var isArgs = str === '[object Arguments]';

  if (!isArgs) {
    isArgs = str !== '[object Array]' && value !== null && _typeof(value) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
  }

  return isArgs;
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var RequireObjectCoercible = __webpack_require__(55);

var ToString = __webpack_require__(57);

var callBound = __webpack_require__(58);

var $replace = callBound('String.prototype.replace');
/* eslint-disable no-control-regex */

var leftWhitespace = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/;
var rightWhitespace = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;
/* eslint-enable no-control-regex */

module.exports = function trim() {
  var S = ToString(RequireObjectCoercible(this));
  return $replace($replace(S, leftWhitespace, ''), rightWhitespace, '');
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(19);

var zeroWidthSpace = "\u200B";

module.exports = function getPolyfill() {
  if (String.prototype.trim && zeroWidthSpace.trim() === zeroWidthSpace) {
    return String.prototype.trim;
  }

  return implementation;
};

/***/ }),
/* 21 */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _extends.apply(this, arguments);
}

module.exports = _extends;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _require = __webpack_require__(40),
    Draggable = _require["default"],
    DraggableCore = _require.DraggableCore; // Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.
// See https://github.com/mzabriskie/react-draggable/pull/254
// and https://github.com/mzabriskie/react-draggable/issues/266


module.exports = Draggable;
module.exports["default"] = Draggable;
module.exports.DraggableCore = DraggableCore;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
//     (c) 2012-2018 Airbnb, Inc.
//
//     polyglot.js may be freely distributed under the terms of the BSD
//     license. For all licensing information, details, and documention:
//     http://airbnb.github.com/polyglot.js
//
//
// Polyglot.js is an I18n helper library written in JavaScript, made to
// work both in the browser and in Node. It provides a simple solution for
// interpolation and pluralization, based off of Airbnb's
// experience adding I18n functionality to its Backbone.js and Node apps.
//
// Polylglot is agnostic to your translation backend. It doesn't perform any
// translation; it simply gives you a way to manage translated phrases from
// your client- or server-side JavaScript application.
//


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var forEach = __webpack_require__(46);

var warning = __webpack_require__(48);

var has = __webpack_require__(15);

var trim = __webpack_require__(50);

var warn = function warn(message) {
  warning(false, message);
};

var replace = String.prototype.replace;
var split = String.prototype.split; // #### Pluralization methods
// The string that separates the different phrase possibilities.

var delimiter = '||||';

var russianPluralGroups = function russianPluralGroups(n) {
  var lastTwo = n % 100;
  var end = lastTwo % 10;

  if (lastTwo !== 11 && end === 1) {
    return 0;
  }

  if (2 <= end && end <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) {
    return 1;
  }

  return 2;
};

var defaultPluralRules = {
  // Mapping from pluralization group plural logic.
  pluralTypes: {
    arabic: function arabic(n) {
      // http://www.arabeyes.org/Plural_Forms
      if (n < 3) {
        return n;
      }

      var lastTwo = n % 100;
      if (lastTwo >= 3 && lastTwo <= 10) return 3;
      return lastTwo >= 11 ? 4 : 5;
    },
    bosnian_serbian: russianPluralGroups,
    chinese: function chinese() {
      return 0;
    },
    croatian: russianPluralGroups,
    french: function french(n) {
      return n > 1 ? 1 : 0;
    },
    german: function german(n) {
      return n !== 1 ? 1 : 0;
    },
    russian: russianPluralGroups,
    lithuanian: function lithuanian(n) {
      if (n % 10 === 1 && n % 100 !== 11) {
        return 0;
      }

      return n % 10 >= 2 && n % 10 <= 9 && (n % 100 < 11 || n % 100 > 19) ? 1 : 2;
    },
    czech: function czech(n) {
      if (n === 1) {
        return 0;
      }

      return n >= 2 && n <= 4 ? 1 : 2;
    },
    polish: function polish(n) {
      if (n === 1) {
        return 0;
      }

      var end = n % 10;
      return 2 <= end && end <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
    },
    icelandic: function icelandic(n) {
      return n % 10 !== 1 || n % 100 === 11 ? 1 : 0;
    },
    slovenian: function slovenian(n) {
      var lastTwo = n % 100;

      if (lastTwo === 1) {
        return 0;
      }

      if (lastTwo === 2) {
        return 1;
      }

      if (lastTwo === 3 || lastTwo === 4) {
        return 2;
      }

      return 3;
    }
  },
  // Mapping from pluralization group to individual language codes/locales.
  // Will look up based on exact match, if not found and it's a locale will parse the locale
  // for language code, and if that does not exist will default to 'en'
  pluralTypeToLanguages: {
    arabic: ['ar'],
    bosnian_serbian: ['bs-Latn-BA', 'bs-Cyrl-BA', 'srl-RS', 'sr-RS'],
    chinese: ['id', 'id-ID', 'ja', 'ko', 'ko-KR', 'lo', 'ms', 'th', 'th-TH', 'zh'],
    croatian: ['hr', 'hr-HR'],
    german: ['fa', 'da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hi-IN', 'hu', 'hu-HU', 'it', 'nl', 'no', 'pt', 'sv', 'tr'],
    french: ['fr', 'tl', 'pt-br'],
    russian: ['ru', 'ru-RU'],
    lithuanian: ['lt'],
    czech: ['cs', 'cs-CZ', 'sk'],
    polish: ['pl'],
    icelandic: ['is'],
    slovenian: ['sl-SL']
  }
};

function langToTypeMap(mapping) {
  var ret = {};
  forEach(mapping, function (langs, type) {
    forEach(langs, function (lang) {
      ret[lang] = type;
    });
  });
  return ret;
}

function pluralTypeName(pluralRules, locale) {
  var langToPluralType = langToTypeMap(pluralRules.pluralTypeToLanguages);
  return langToPluralType[locale] || langToPluralType[split.call(locale, /-/, 1)[0]] || langToPluralType.en;
}

function pluralTypeIndex(pluralRules, locale, count) {
  return pluralRules.pluralTypes[pluralTypeName(pluralRules, locale)](count);
}

function escape(token) {
  return token.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function constructTokenRegex(opts) {
  var prefix = opts && opts.prefix || '%{';
  var suffix = opts && opts.suffix || '}';

  if (prefix === delimiter || suffix === delimiter) {
    throw new RangeError('"' + delimiter + '" token is reserved for pluralization');
  }

  return new RegExp(escape(prefix) + '(.*?)' + escape(suffix), 'g');
}

var defaultTokenRegex = /%\{(.*?)\}/g; // ### transformPhrase(phrase, substitutions, locale)
//
// Takes a phrase string and transforms it by choosing the correct
// plural form and interpolating it.
//
//     transformPhrase('Hello, %{name}!', {name: 'Spike'});
//     // "Hello, Spike!"
//
// The correct plural form is selected if substitutions.smart_count
// is set. You can pass in a number instead of an Object as `substitutions`
// as a shortcut for `smart_count`.
//
//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 1}, 'en');
//     // "1 new message"
//
//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 2}, 'en');
//     // "2 new messages"
//
//     transformPhrase('%{smart_count} new messages |||| 1 new message', 5, 'en');
//     // "5 new messages"
//
// You should pass in a third argument, the locale, to specify the correct plural type.
// It defaults to `'en'` with 2 plural forms.

function transformPhrase(phrase, substitutions, locale, tokenRegex, pluralRules) {
  if (typeof phrase !== 'string') {
    throw new TypeError('Polyglot.transformPhrase expects argument #1 to be string');
  }

  if (substitutions == null) {
    return phrase;
  }

  var result = phrase;
  var interpolationRegex = tokenRegex || defaultTokenRegex;
  var pluralRulesOrDefault = pluralRules || defaultPluralRules; // allow number as a pluralization shortcut

  var options = typeof substitutions === 'number' ? {
    smart_count: substitutions
  } : substitutions; // Select plural form: based on a phrase text that contains `n`
  // plural forms separated by `delimiter`, a `locale`, and a `substitutions.smart_count`,
  // choose the correct plural form. This is only done if `count` is set.

  if (options.smart_count != null && result) {
    var texts = split.call(result, delimiter);
    result = trim(texts[pluralTypeIndex(pluralRulesOrDefault, locale || 'en', options.smart_count)] || texts[0]);
  } // Interpolate: Creates a `RegExp` object for each interpolation placeholder.


  result = replace.call(result, interpolationRegex, function (expression, argument) {
    if (!has(options, argument) || options[argument] == null) {
      return expression;
    }

    return options[argument];
  });
  return result;
} // ### Polyglot class constructor


function Polyglot(options) {
  var opts = options || {};
  this.phrases = {};
  this.extend(opts.phrases || {});
  this.currentLocale = opts.locale || 'en';
  var allowMissing = opts.allowMissing ? transformPhrase : null;
  this.onMissingKey = typeof opts.onMissingKey === 'function' ? opts.onMissingKey : allowMissing;
  this.warn = opts.warn || warn;
  this.tokenRegex = constructTokenRegex(opts.interpolation);
  this.pluralRules = opts.pluralRules || defaultPluralRules;
} // ### polyglot.locale([locale])
//
// Get or set locale. Internally, Polyglot only uses locale for pluralization.


Polyglot.prototype.locale = function (newLocale) {
  if (newLocale) this.currentLocale = newLocale;
  return this.currentLocale;
}; // ### polyglot.extend(phrases)
//
// Use `extend` to tell Polyglot how to translate a given key.
//
//     polyglot.extend({
//       "hello": "Hello",
//       "hello_name": "Hello, %{name}"
//     });
//
// The key can be any string.  Feel free to call `extend` multiple times;
// it will override any phrases with the same key, but leave existing phrases
// untouched.
//
// It is also possible to pass nested phrase objects, which get flattened
// into an object with the nested keys concatenated using dot notation.
//
//     polyglot.extend({
//       "nav": {
//         "hello": "Hello",
//         "hello_name": "Hello, %{name}",
//         "sidebar": {
//           "welcome": "Welcome"
//         }
//       }
//     });
//
//     console.log(polyglot.phrases);
//     // {
//     //   'nav.hello': 'Hello',
//     //   'nav.hello_name': 'Hello, %{name}',
//     //   'nav.sidebar.welcome': 'Welcome'
//     // }
//
// `extend` accepts an optional second argument, `prefix`, which can be used
// to prefix every key in the phrases object with some string, using dot
// notation.
//
//     polyglot.extend({
//       "hello": "Hello",
//       "hello_name": "Hello, %{name}"
//     }, "nav");
//
//     console.log(polyglot.phrases);
//     // {
//     //   'nav.hello': 'Hello',
//     //   'nav.hello_name': 'Hello, %{name}'
//     // }
//
// This feature is used internally to support nested phrase objects.


Polyglot.prototype.extend = function (morePhrases, prefix) {
  forEach(morePhrases, function (phrase, key) {
    var prefixedKey = prefix ? prefix + '.' + key : key;

    if (_typeof(phrase) === 'object') {
      this.extend(phrase, prefixedKey);
    } else {
      this.phrases[prefixedKey] = phrase;
    }
  }, this);
}; // ### polyglot.unset(phrases)
// Use `unset` to selectively remove keys from a polyglot instance.
//
//     polyglot.unset("some_key");
//     polyglot.unset({
//       "hello": "Hello",
//       "hello_name": "Hello, %{name}"
//     });
//
// The unset method can take either a string (for the key), or an object hash with
// the keys that you would like to unset.


Polyglot.prototype.unset = function (morePhrases, prefix) {
  if (typeof morePhrases === 'string') {
    delete this.phrases[morePhrases];
  } else {
    forEach(morePhrases, function (phrase, key) {
      var prefixedKey = prefix ? prefix + '.' + key : key;

      if (_typeof(phrase) === 'object') {
        this.unset(phrase, prefixedKey);
      } else {
        delete this.phrases[prefixedKey];
      }
    }, this);
  }
}; // ### polyglot.clear()
//
// Clears all phrases. Useful for special cases, such as freeing
// up memory if you have lots of phrases but no longer need to
// perform any translation. Also used internally by `replace`.


Polyglot.prototype.clear = function () {
  this.phrases = {};
}; // ### polyglot.replace(phrases)
//
// Completely replace the existing phrases with a new set of phrases.
// Normally, just use `extend` to add more phrases, but under certain
// circumstances, you may want to make sure no old phrases are lying around.


Polyglot.prototype.replace = function (newPhrases) {
  this.clear();
  this.extend(newPhrases);
}; // ### polyglot.t(key, options)
//
// The most-used method. Provide a key, and `t` will return the
// phrase.
//
//     polyglot.t("hello");
//     => "Hello"
//
// The phrase value is provided first by a call to `polyglot.extend()` or
// `polyglot.replace()`.
//
// Pass in an object as the second argument to perform interpolation.
//
//     polyglot.t("hello_name", {name: "Spike"});
//     => "Hello, Spike"
//
// If you like, you can provide a default value in case the phrase is missing.
// Use the special option key "_" to specify a default.
//
//     polyglot.t("i_like_to_write_in_language", {
//       _: "I like to write in %{language}.",
//       language: "JavaScript"
//     });
//     => "I like to write in JavaScript."
//


Polyglot.prototype.t = function (key, options) {
  var phrase, result;
  var opts = options == null ? {} : options;

  if (typeof this.phrases[key] === 'string') {
    phrase = this.phrases[key];
  } else if (typeof opts._ === 'string') {
    phrase = opts._;
  } else if (this.onMissingKey) {
    var onMissingKey = this.onMissingKey;
    result = onMissingKey(key, opts, this.currentLocale, this.tokenRegex, this.pluralRules);
  } else {
    this.warn('Missing translation for key: "' + key + '"');
    result = key;
  }

  if (typeof phrase === 'string') {
    result = transformPhrase(phrase, opts, this.currentLocale, this.tokenRegex, this.pluralRules);
  }

  return result;
}; // ### polyglot.has(key)
//
// Check if polyglot has a translation for given key


Polyglot.prototype.has = function (key) {
  return has(this.phrases, key);
}; // export transformPhrase


Polyglot.transformPhrase = function transform(phrase, substitutions, locale) {
  return transformPhrase(phrase, substitutions, locale);
};

module.exports = Polyglot;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var timeTypes = [['', '', '%s ', '%s '], ['', '', '%s ', '%s '], ['', '', '%s ', '%s '], ['', '', '%s ', '%s '], ['', '', '%s ', '%s '], ['', '', '%s ', '%s '], ['', '', '%s ', '%s ']];

function formatTime(type, n) {
  if (n < 3) return timeTypes[type][n - 1];
  if (n >= 3 && n <= 10) return timeTypes[type][2];
  return timeTypes[type][3];
}

function default_1(number, index) {
  if (index === 0) {
    return [' ', ' '];
  }

  var timeStr = formatTime(Math.floor(index / 2), number);
  return ['' + ' ' + timeStr, '' + ' ' + timeStr];
}

exports["default"] = default_1;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function default_1(number, index) {
  var inflectionIndex = 0;
  var isInflectionNeeded = index == 1 || index == 3 || index == 5 || index == 7 || index == 9 || index == 11 || index == 13;

  if (isInflectionNeeded && number >= 5) {
    inflectionIndex = 1;
  }

  return [[['prv te', 'prv te']], [['ped %s vteinami', 'za %s vteiny'], ['ped %s vteinami', 'za %s vtein']], [['ped minutou', 'za minutu']], [['ped %s minutami', 'za %s minuty'], ['ped %s minutami', 'za %s minut']], [['ped hodinou', 'za hodinu']], [['ped %s hodinami', 'za %s hodiny'], ['ped %s hodinami', 'za %s hodin']], [['vera', 'ztra']], [['ped %s dny', 'za %s dny'], ['ped %s dny', 'za %s dn']], [['minul tden', 'pt tden']], [['ped %s tdny', 'za %s tdny'], ['ped %s tdny', 'za %s tdn']], [['minul msc', 'pst msc']], [['ped %s msci', 'za %s msce'], ['ped %s msci', 'za %s msc']], [['ped rokem', 'pst rok']], [['ped %s lety', 'za %s roky'], ['ped %s lety', 'za %s let']]][index][inflectionIndex];
}

exports["default"] = default_1;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function default_1(number, index) {
  return [['gerade eben', 'vor einer Weile'], ['vor %s Sekunden', 'in %s Sekunden'], ['vor 1 Minute', 'in 1 Minute'], ['vor %s Minuten', 'in %s Minuten'], ['vor 1 Stunde', 'in 1 Stunde'], ['vor %s Stunden', 'in %s Stunden'], ['vor 1 Tag', 'in 1 Tag'], ['vor %s Tagen', 'in %s Tagen'], ['vor 1 Woche', 'in 1 Woche'], ['vor %s Wochen', 'in %s Wochen'], ['vor 1 Monat', 'in 1 Monat'], ['vor %s Monaten', 'in %s Monaten'], ['vor 1 Jahr', 'in 1 Jahr'], ['vor %s Jahren', 'in %s Jahren']][index];
}

exports["default"] = default_1;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function default_1(number, index) {
  return [[' ', ' '], ['%s  ', ' %s '], ['1  ', ' 1 '], ['%s  ', ' %s '], ['1  ', ' 1 '], ['%s  ', ' %s '], ['1  ', ' 1 '], ['%s  ', ' %s '], ['1  ', ' 1 '], ['%s  ', ' %s '], ['1  ', ' 1 '], ['%s  ', ' %s '], ['1  ', ' 1 '], ['%s  ', ' %s ']][index];
}

exports["default"] = default_1;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function default_1(number, index) {
  return [['justo ahora', 'en un rato'], ['hace %s segundos', 'en %s segundos'], ['hace 1 minuto', 'en 1 minuto'], ['hace %s minutos', 'en %s minutos'], ['hace 1 hora', 'en 1 hora'], ['hace %s horas', 'en %s horas'], ['hace 1 da', 'en 1 da'], ['hace %s das', 'en %s das'], ['hace 1 semana', 'en 1 semana'], ['hace %s semanas', 'en %s semanas'], ['hace 1 mes', 'en 1 mes'], ['hace %s meses', 'en %s meses'], ['hace 1 ao', 'en 1 ao'], ['hace %s aos', 'en %s aos']][index];
}

exports["default"] = default_1;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function default_1(number, index) {
  return [['xusto agora', 'daqu a un pouco'], ['hai %s segundos', 'en %s segundos'], ['hai 1 minuto', 'nun minuto'], ['hai %s minutos', 'en %s minutos'], ['hai 1 hora', 'nunha hora'], ['hai %s horas', 'en %s horas'], ['hai 1 da', 'nun da'], ['hai %s das', 'en %s das'], ['hai 1 semana', 'nunha semana'], ['hai %s semanas', 'en %s semanas'], ['hai 1 mes', 'nun mes'], ['hai %s meses', 'en %s meses'], ['hai 1 ano', 'nun ano'], ['hai %s anos', 'en %s anos']][index];
}

exports["default"] = default_1;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
}); // Hindi (India)

function default_1(number, index) {
  return [['', ' '], ['%s  ', '%s  '], ['1  ', '1  '], ['%s  ', '%s  '], ['1  ', '1  '], ['%s  ', '%s  '], ['1  ', '1  '], ['%s  ', '%s  '], ['1  ', '1  '], ['%s  ', '%s  '], ['1  ', '1  '], ['%s  ', '%s  '], ['1  ', '1  '], ['%s  ', '%s  ']][index];
}

exports["default"] = default_1;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function default_1(number, index) {
  return [['poco fa', 'fra poco'], ['%s secondi fa', 'fra %s secondi'], ['un minuto fa', 'fra un minuto'], ['%s minuti fa', 'fra %s minuti'], ["un'ora fa", "fra un'ora"], ['%s ore fa', 'fra %s ore'], ['un giorno fa', 'fra un giorno'], ['%s giorni fa', 'fra %s giorni'], ['una settimana fa', 'fra una settimana'], ['%s settimane fa', 'fra %s settimane'], ['un mese fa', 'fra un mese'], ['%s mesi fa', 'fra %s mesi'], ['un anno fa', 'fra un anno'], ['%s anni fa', 'fra %s anni']][index];
}

exports["default"] = default_1;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function default_1(number, index) {
  return [['recent', 'binnenkort'], ['%s seconden geleden', 'binnen %s seconden'], ['1 minuut geleden', 'binnen 1 minuut'], ['%s minuten geleden', 'binnen %s minuten'], ['1 uur geleden', 'binnen 1 uur'], ['%s uur geleden', 'binnen %s uur'], ['1 dag geleden', 'binnen 1 dag'], ['%s dagen geleden', 'binnen %s dagen'], ['1 week geleden', 'binnen 1 week'], ['%s weken geleden', 'binnen %s weken'], ['1 maand geleden', 'binnen 1 maand'], ['%s maanden geleden', 'binnen %s maanden'], ['1 jaar geleden', 'binnen 1 jaar'], ['%s jaar geleden', 'binnen %s jaar']][index];
}

exports["default"] = default_1;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function default_1(number, index) {
  return [['agora mesmo', 'agora'], ['h %s segundos', 'em %s segundos'], ['h um minuto', 'em um minuto'], ['h %s minutos', 'em %s minutos'], ['h uma hora', 'em uma hora'], ['h %s horas', 'em %s horas'], ['h um dia', 'em um dia'], ['h %s dias', 'em %s dias'], ['h uma semana', 'em uma semana'], ['h %s semanas', 'em %s semanas'], ['h um ms', 'em um ms'], ['h %s meses', 'em %s meses'], ['h um ano', 'em um ano'], ['h %s anos', 'em %s anos']][index];
}

exports["default"] = default_1;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function default_1(number, index) {
  return [['just nu', 'om en stund'], ['%s sekunder sedan', 'om %s sekunder'], ['1 minut sedan', 'om 1 minut'], ['%s minuter sedan', 'om %s minuter'], ['1 timme sedan', 'om 1 timme'], ['%s timmar sedan', 'om %s timmar'], ['1 dag sedan', 'om 1 dag'], ['%s dagar sedan', 'om %s dagar'], ['1 vecka sedan', 'om 1 vecka'], ['%s veckor sedan', 'om %s veckor'], ['1 mnad sedan', 'om 1 mnad'], ['%s mnader sedan', 'om %s mnader'], ['1 r sedan', 'om 1 r'], ['%s r sedan', 'om %s r']][index];
}

exports["default"] = default_1;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function default_1(number, index) {
  return [['az nce', 'imdi'], ['%s saniye nce', '%s saniye iinde'], ['1 dakika nce', '1 dakika iinde'], ['%s dakika nce', '%s dakika iinde'], ['1 saat nce', '1 saat iinde'], ['%s saat nce', '%s saat iinde'], ['1 gn nce', '1 gn iinde'], ['%s gn nce', '%s gn iinde'], ['1 hafta nce', '1 hafta iinde'], ['%s hafta nce', '%s hafta iinde'], ['1 ay nce', '1 ay iinde'], ['%s ay nce', '%s ay iinde'], ['1 yl nce', '1 yl iinde'], ['%s yl nce', '%s yl iinde']][index];
}

exports["default"] = default_1;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var TextareaAutosize_1 = __webpack_require__(74);

exports["default"] = TextareaAutosize_1.TextareaAutosize;

/***/ }),
/* 38 */,
/* 39 */,
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DraggableCore", {
  enumerable: true,
  get: function get() {
    return _DraggableCore["default"];
  }
});
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__(0));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

var _reactDom = _interopRequireDefault(__webpack_require__(0));

var _classnames = _interopRequireDefault(__webpack_require__(43));

var _domFns = __webpack_require__(7);

var _positionFns = __webpack_require__(13);

var _shims = __webpack_require__(4);

var _DraggableCore = _interopRequireDefault(__webpack_require__(45));

var _log = _interopRequireDefault(__webpack_require__(14));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} //
// Define <Draggable>
//


var Draggable = /*#__PURE__*/function (_React$Component) {
  _inherits(Draggable, _React$Component);

  var _super = _createSuper(Draggable);

  _createClass(Draggable, null, [{
    key: "getDerivedStateFromProps",
    // React 16.3+
    // Arity (props, state)
    value: function getDerivedStateFromProps(_ref, _ref2) {
      var position = _ref.position;
      var prevPropsPosition = _ref2.prevPropsPosition; // Set x/y if a new position is provided in props that is different than the previous.

      if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {
        (0, _log["default"])('Draggable: getDerivedStateFromProps %j', {
          position: position,
          prevPropsPosition: prevPropsPosition
        });
        return {
          x: position.x,
          y: position.y,
          prevPropsPosition: _objectSpread({}, position)
        };
      }

      return null;
    }
  }]);

  function Draggable(props
  /*: DraggableProps*/
  ) {
    var _this;

    _classCallCheck(this, Draggable);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "onDragStart", function (e, coreData) {
      (0, _log["default"])('Draggable: onDragStart: %j', coreData); // Short-circuit if user's callback killed it.

      var shouldStart = _this.props.onStart(e, (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData)); // Kills start event on core as well, so move handlers are never bound.


      if (shouldStart === false) return false;

      _this.setState({
        dragging: true,
        dragged: true
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onDrag", function (e, coreData) {
      if (!_this.state.dragging) return false;
      (0, _log["default"])('Draggable: onDrag: %j', coreData);
      var uiData = (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData);
      var newState
      /*: $Shape<DraggableState>*/
      = {
        x: uiData.x,
        y: uiData.y
      }; // Keep within bounds.

      if (_this.props.bounds) {
        // Save original x and y.
        var x = newState.x,
            y = newState.y; // Add slack to the values used to calculate bound position. This will ensure that if
        // we start removing slack, the element won't react to it right away until it's been
        // completely removed.

        newState.x += _this.state.slackX;
        newState.y += _this.state.slackY; // Get bound position. This will ceil/floor the x and y within the boundaries.

        var _getBoundPosition = (0, _positionFns.getBoundPosition)(_assertThisInitialized(_this), newState.x, newState.y),
            _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2),
            newStateX = _getBoundPosition2[0],
            newStateY = _getBoundPosition2[1];

        newState.x = newStateX;
        newState.y = newStateY; // Recalculate slack by noting how much was shaved by the boundPosition handler.

        newState.slackX = _this.state.slackX + (x - newState.x);
        newState.slackY = _this.state.slackY + (y - newState.y); // Update the event we fire to reflect what really happened after bounds took effect.

        uiData.x = newState.x;
        uiData.y = newState.y;
        uiData.deltaX = newState.x - _this.state.x;
        uiData.deltaY = newState.y - _this.state.y;
      } // Short-circuit if user's callback killed it.


      var shouldUpdate = _this.props.onDrag(e, uiData);

      if (shouldUpdate === false) return false;

      _this.setState(newState);
    });

    _defineProperty(_assertThisInitialized(_this), "onDragStop", function (e, coreData) {
      if (!_this.state.dragging) return false; // Short-circuit if user's callback killed it.

      var shouldContinue = _this.props.onStop(e, (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData));

      if (shouldContinue === false) return false;
      (0, _log["default"])('Draggable: onDragStop: %j', coreData);
      var newState
      /*: $Shape<DraggableState>*/
      = {
        dragging: false,
        slackX: 0,
        slackY: 0
      }; // If this is a controlled component, the result of this operation will be to
      // revert back to the old position. We expect a handler on `onDragStop`, at the least.

      var controlled = Boolean(_this.props.position);

      if (controlled) {
        var _this$props$position = _this.props.position,
            x = _this$props$position.x,
            y = _this$props$position.y;
        newState.x = x;
        newState.y = y;
      }

      _this.setState(newState);
    });

    _this.state = {
      // Whether or not we are currently dragging.
      dragging: false,
      // Whether or not we have been dragged before.
      dragged: false,
      // Current transform x and y.
      x: props.position ? props.position.x : props.defaultPosition.x,
      y: props.position ? props.position.y : props.defaultPosition.y,
      prevPropsPosition: _objectSpread({}, props.position),
      // Used for compensating for out-of-bounds drags
      slackX: 0,
      slackY: 0,
      // Can only determine if SVG after mounting
      isElementSVG: false
    };

    if (props.position && !(props.onDrag || props.onStop)) {
      // eslint-disable-next-line no-console
      console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');
    }

    return _this;
  }

  _createClass(Draggable, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // Check to see if the element passed is an instanceof SVGElement
      if (typeof window.SVGElement !== 'undefined' && this.findDOMNode() instanceof window.SVGElement) {
        this.setState({
          isElementSVG: true
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.setState({
        dragging: false
      }); // prevents invariant if unmounted while dragging
    } // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.

  }, {
    key: "findDOMNode",
    value: function findDOMNode()
    /*: ?HTMLElement*/
    {
      return this.props.nodeRef ? this.props.nodeRef.current : _reactDom["default"].findDOMNode(this);
    }
  }, {
    key: "render",
    value: function render()
    /*: ReactElement<any>*/
    {
      var _classNames;

      var _this$props = this.props,
          axis = _this$props.axis,
          bounds = _this$props.bounds,
          children = _this$props.children,
          defaultPosition = _this$props.defaultPosition,
          defaultClassName = _this$props.defaultClassName,
          defaultClassNameDragging = _this$props.defaultClassNameDragging,
          defaultClassNameDragged = _this$props.defaultClassNameDragged,
          position = _this$props.position,
          positionOffset = _this$props.positionOffset,
          scale = _this$props.scale,
          draggableCoreProps = _objectWithoutProperties(_this$props, ["axis", "bounds", "children", "defaultPosition", "defaultClassName", "defaultClassNameDragging", "defaultClassNameDragged", "position", "positionOffset", "scale"]);

      var style = {};
      var svgTransform = null; // If this is controlled, we don't want to move it - unless it's dragging.

      var controlled = Boolean(position);
      var draggable = !controlled || this.state.dragging;
      var validPosition = position || defaultPosition;
      var transformOpts = {
        // Set left if horizontal drag is enabled
        x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,
        // Set top if vertical drag is enabled
        y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y
      }; // If this element was SVG, we use the `transform` attribute.

      if (this.state.isElementSVG) {
        svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);
      } else {
        // Add a CSS transform to move the element around. This allows us to move the element around
        // without worrying about whether or not it is relatively or absolutely positioned.
        // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
        // has a clean slate.
        style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);
      } // Mark with class while dragging


      var className = (0, _classnames["default"])(children.props.className || '', defaultClassName, (_classNames = {}, _defineProperty(_classNames, defaultClassNameDragging, this.state.dragging), _defineProperty(_classNames, defaultClassNameDragged, this.state.dragged), _classNames)); // Reuse the child provided
      // This makes it flexible to use whatever element is wanted (div, ul, etc)

      return /*#__PURE__*/React.createElement(_DraggableCore["default"], _extends({}, draggableCoreProps, {
        onStart: this.onDragStart,
        onDrag: this.onDrag,
        onStop: this.onDragStop
      }), React.cloneElement(React.Children.only(children), {
        className: className,
        style: _objectSpread(_objectSpread({}, children.props.style), style),
        transform: svgTransform
      }));
    }
  }]);

  return Draggable;
}(React.Component);

exports["default"] = Draggable;

_defineProperty(Draggable, "displayName", 'Draggable');

_defineProperty(Draggable, "propTypes", _objectSpread(_objectSpread({}, _DraggableCore["default"].propTypes), {}, {
  /**
   * `axis` determines which axis the draggable can move.
   *
   *  Note that all callbacks will still return data as normal. This only
   *  controls flushing to the DOM.
   *
   * 'both' allows movement horizontally and vertically.
   * 'x' limits movement to horizontal axis.
   * 'y' limits movement to vertical axis.
   * 'none' limits all movement.
   *
   * Defaults to 'both'.
   */
  axis: _propTypes["default"].oneOf(['both', 'x', 'y', 'none']),

  /**
   * `bounds` determines the range of movement available to the element.
   * Available values are:
   *
   * 'parent' restricts movement within the Draggable's parent node.
   *
   * Alternatively, pass an object with the following properties, all of which are optional:
   *
   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
   *
   * All values are in px.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable bounds={{right: 300, bottom: 300}}>
   *              <div>Content</div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  bounds: _propTypes["default"].oneOfType([_propTypes["default"].shape({
    left: _propTypes["default"].number,
    right: _propTypes["default"].number,
    top: _propTypes["default"].number,
    bottom: _propTypes["default"].number
  }), _propTypes["default"].string, _propTypes["default"].oneOf([false])]),
  defaultClassName: _propTypes["default"].string,
  defaultClassNameDragging: _propTypes["default"].string,
  defaultClassNameDragged: _propTypes["default"].string,

  /**
   * `defaultPosition` specifies the x and y that the dragged item should start at
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */
  defaultPosition: _propTypes["default"].shape({
    x: _propTypes["default"].number,
    y: _propTypes["default"].number
  }),
  positionOffset: _propTypes["default"].shape({
    x: _propTypes["default"].oneOfType([_propTypes["default"].number, _propTypes["default"].string]),
    y: _propTypes["default"].oneOfType([_propTypes["default"].number, _propTypes["default"].string])
  }),

  /**
   * `position`, if present, defines the current position of the element.
   *
   *  This is similar to how form elements in React work - if no `position` is supplied, the component
   *  is uncontrolled.
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable position={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */
  position: _propTypes["default"].shape({
    x: _propTypes["default"].number,
    y: _propTypes["default"].number
  }),

  /**
   * These properties should be defined on the child, not here.
   */
  className: _shims.dontSetMe,
  style: _shims.dontSetMe,
  transform: _shims.dontSetMe
}));

_defineProperty(Draggable, "defaultProps", _objectSpread(_objectSpread({}, _DraggableCore["default"].defaultProps), {}, {
  axis: 'both',
  bounds: false,
  defaultClassName: 'react-draggable',
  defaultClassNameDragging: 'react-draggable-dragging',
  defaultClassNameDragged: 'react-draggable-dragged',
  defaultPosition: {
    x: 0,
    y: 0
  },
  position: null,
  scale: 1
}));

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var ReactPropTypesSecret = __webpack_require__(42);

function emptyFunction() {}

function emptyFunctionWithReset() {}

emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }

    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    err.name = 'Invariant Violation';
    throw err;
  }

  ;
  shim.isRequired = shim;

  function getShim() {
    return shim;
  }

  ; // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
module.exports = ReactPropTypesSecret;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

/* global define */
(function () {
  'use strict';

  var hasOwn = {}.hasOwnProperty;

  function classNames() {
    var classes = [];

    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (!arg) continue;

      var argType = _typeof(arg);

      if (argType === 'string' || argType === 'number') {
        classes.push(arg);
      } else if (Array.isArray(arg)) {
        if (arg.length) {
          var inner = classNames.apply(null, arg);

          if (inner) {
            classes.push(inner);
          }
        }
      } else if (argType === 'object') {
        if (arg.toString === Object.prototype.toString) {
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        } else {
          classes.push(arg.toString());
        }
      }
    }

    return classes.join(' ');
  }

  if ( true && module.exports) {
    classNames["default"] = classNames;
    module.exports = classNames;
  } else if ( true && _typeof(__webpack_require__(12)) === 'object' && __webpack_require__(12)) {
    // register as 'classnames', consistent with npm package name
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return classNames;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    window.classNames = classNames;
  }
})();

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPrefix = getPrefix;
exports.browserPrefixToKey = browserPrefixToKey;
exports.browserPrefixToStyle = browserPrefixToStyle;
exports["default"] = void 0;
var prefixes = ['Moz', 'Webkit', 'O', 'ms'];

function getPrefix()
/*: string*/
{
  var prop
  /*: string*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform'; // Checking specifically for 'window.document' is for pseudo-browser server-side
  // environments that define 'window' as the global context.
  // E.g. React-rails (see https://github.com/reactjs/react-rails/pull/84)

  if (typeof window === 'undefined' || typeof window.document === 'undefined') return '';
  var style = window.document.documentElement.style;
  if (prop in style) return '';

  for (var i = 0; i < prefixes.length; i++) {
    if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
  }

  return '';
}

function browserPrefixToKey(prop
/*: string*/
, prefix
/*: string*/
)
/*: string*/
{
  return prefix ? "".concat(prefix).concat(kebabToTitleCase(prop)) : prop;
}

function browserPrefixToStyle(prop
/*: string*/
, prefix
/*: string*/
)
/*: string*/
{
  return prefix ? "-".concat(prefix.toLowerCase(), "-").concat(prop) : prop;
}

function kebabToTitleCase(str
/*: string*/
)
/*: string*/
{
  var out = '';
  var shouldCapitalize = true;

  for (var i = 0; i < str.length; i++) {
    if (shouldCapitalize) {
      out += str[i].toUpperCase();
      shouldCapitalize = false;
    } else if (str[i] === '-') {
      shouldCapitalize = true;
    } else {
      out += str[i];
    }
  }

  return out;
} // Default export is the prefix itself, like 'Moz', 'Webkit', etc
// Note that you may have to re-test for certain things; for instance, Chrome 50
// can handle unprefixed `transform`, but not unprefixed `user-select`


var _default = getPrefix();

exports["default"] = _default;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__(0));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

var _reactDom = _interopRequireDefault(__webpack_require__(0));

var _domFns = __webpack_require__(7);

var _positionFns = __webpack_require__(13);

var _shims = __webpack_require__(4);

var _log = _interopRequireDefault(__webpack_require__(14));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} // Simple abstraction for dragging events names.


var eventsFor = {
  touch: {
    start: 'touchstart',
    move: 'touchmove',
    stop: 'touchend'
  },
  mouse: {
    start: 'mousedown',
    move: 'mousemove',
    stop: 'mouseup'
  }
}; // Default to mouse events.

var dragEventFor = eventsFor.mouse;
/*:: type DraggableCoreState = {
  dragging: boolean,
  lastX: number,
  lastY: number,
  touchIdentifier: ?number
};*/

/*:: export type DraggableData = {
  node: HTMLElement,
  x: number, y: number,
  deltaX: number, deltaY: number,
  lastX: number, lastY: number,
};*/

/*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void;*/

/*:: export type ControlPosition = {x: number, y: number};*/

/*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/

/*:: export type DraggableCoreProps = {
  allowAnyClick: boolean,
  cancel: string,
  children: ReactElement<any>,
  disabled: boolean,
  enableUserSelectHack: boolean,
  offsetParent: HTMLElement,
  grid: [number, number],
  handle: string,
  nodeRef?: ?React.ElementRef<any>,
  onStart: DraggableEventHandler,
  onDrag: DraggableEventHandler,
  onStop: DraggableEventHandler,
  onMouseDown: (e: MouseEvent) => void,
  scale: number,
};*/
//
// Define <DraggableCore>.
//
// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can
// work well with libraries that require more control over the element.
//

var DraggableCore = /*#__PURE__*/function (_React$Component) {
  _inherits(DraggableCore, _React$Component);

  var _super = _createSuper(DraggableCore);

  function DraggableCore() {
    var _this;

    _classCallCheck(this, DraggableCore);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      dragging: false,
      // Used while dragging to determine deltas.
      lastX: NaN,
      lastY: NaN,
      touchIdentifier: null
    });

    _defineProperty(_assertThisInitialized(_this), "mounted", false);

    _defineProperty(_assertThisInitialized(_this), "handleDragStart", function (e) {
      // Make it possible to attach event handlers on top of this one.
      _this.props.onMouseDown(e); // Only accept left-clicks.


      if (!_this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false; // Get nodes. Be sure to grab relative document (could be iframed)

      var thisNode = _this.findDOMNode();

      if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
        throw new Error('<DraggableCore> not mounted on DragStart!');
      }

      var ownerDocument = thisNode.ownerDocument; // Short circuit if handle or cancel prop was provided and selector doesn't match.

      if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.handle, thisNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.cancel, thisNode)) {
        return;
      } // Prevent scrolling on mobile devices, like ipad/iphone.
      // Important that this is after handle/cancel.


      if (e.type === 'touchstart') e.preventDefault(); // Set touch identifier in component state if this is a touch event. This allows us to
      // distinguish between individual touches on multitouch screens by identifying which
      // touchpoint was set to this element.

      var touchIdentifier = (0, _domFns.getTouchIdentifier)(e);

      _this.setState({
        touchIdentifier: touchIdentifier
      }); // Get the current drag point from the event. This is used as the offset.


      var position = (0, _positionFns.getControlPosition)(e, touchIdentifier, _assertThisInitialized(_this));
      if (position == null) return; // not possible but satisfies flow

      var x = position.x,
          y = position.y; // Create an event object with all the data parents need to make a decision here.

      var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x, y);
      (0, _log["default"])('DraggableCore: handleDragStart: %j', coreEvent); // Call event handler. If it returns explicit false, cancel.

      (0, _log["default"])('calling', _this.props.onStart);

      var shouldUpdate = _this.props.onStart(e, coreEvent);

      if (shouldUpdate === false || _this.mounted === false) return; // Add a style to the body to disable user-select. This prevents text from
      // being selected all over the page.

      if (_this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument); // Initiate dragging. Set the current x and y as offsets
      // so we know how much we've moved during the drag. This allows us
      // to drag elements around even if they have been moved, without issue.

      _this.setState({
        dragging: true,
        lastX: x,
        lastY: y
      }); // Add events to the document directly so we catch when the user's mouse/touch moves outside of
      // this element. We use different events depending on whether or not we have detected that this
      // is a touch-capable device.


      (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
      (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
    });

    _defineProperty(_assertThisInitialized(_this), "handleDrag", function (e) {
      // Get the current drag point from the event. This is used as the offset.
      var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _assertThisInitialized(_this));
      if (position == null) return;
      var x = position.x,
          y = position.y; // Snap to grid if prop has been provided

      if (Array.isArray(_this.props.grid)) {
        var deltaX = x - _this.state.lastX,
            deltaY = y - _this.state.lastY;

        var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);

        var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);

        deltaX = _snapToGrid2[0];
        deltaY = _snapToGrid2[1];
        if (!deltaX && !deltaY) return; // skip useless drag

        x = _this.state.lastX + deltaX, y = _this.state.lastY + deltaY;
      }

      var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x, y);
      (0, _log["default"])('DraggableCore: handleDrag: %j', coreEvent); // Call event handler. If it returns explicit false, trigger end.

      var shouldUpdate = _this.props.onDrag(e, coreEvent);

      if (shouldUpdate === false || _this.mounted === false) {
        try {
          // $FlowIgnore
          _this.handleDragStop(new MouseEvent('mouseup'));
        } catch (err) {
          // Old browsers
          var event = document.createEvent('MouseEvents')
          /*: any*/
          ; // I see why this insanity was deprecated
          // $FlowIgnore

          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);

          _this.handleDragStop(event);
        }

        return;
      }

      _this.setState({
        lastX: x,
        lastY: y
      });
    });

    _defineProperty(_assertThisInitialized(_this), "handleDragStop", function (e) {
      if (!_this.state.dragging) return;
      var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _assertThisInitialized(_this));
      if (position == null) return;
      var x = position.x,
          y = position.y;
      var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x, y); // Call event handler

      var shouldContinue = _this.props.onStop(e, coreEvent);

      if (shouldContinue === false || _this.mounted === false) return false;

      var thisNode = _this.findDOMNode();

      if (thisNode) {
        // Remove user-select hack
        if (_this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);
      }

      (0, _log["default"])('DraggableCore: handleDragStop: %j', coreEvent); // Reset the el.

      _this.setState({
        dragging: false,
        lastX: NaN,
        lastY: NaN
      });

      if (thisNode) {
        // Remove event handlers
        (0, _log["default"])('DraggableCore: Removing handlers');
        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, _this.handleDrag);
        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, _this.handleDragStop);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseDown", function (e) {
      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse

      return _this.handleDragStart(e);
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseUp", function (e) {
      dragEventFor = eventsFor.mouse;
      return _this.handleDragStop(e);
    });

    _defineProperty(_assertThisInitialized(_this), "onTouchStart", function (e) {
      // We're on a touch device now, so change the event handlers
      dragEventFor = eventsFor.touch;
      return _this.handleDragStart(e);
    });

    _defineProperty(_assertThisInitialized(_this), "onTouchEnd", function (e) {
      // We're on a touch device now, so change the event handlers
      dragEventFor = eventsFor.touch;
      return _this.handleDragStop(e);
    });

    return _this;
  }

  _createClass(DraggableCore, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.mounted = true; // Touch handlers must be added with {passive: false} to be cancelable.
      // https://developers.google.com/web/updates/2017/01/scrolling-intervention

      var thisNode = this.findDOMNode();

      if (thisNode) {
        (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
          passive: false
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.mounted = false; // Remove any leftover event handlers. Remove both touch and mouse handlers in case
      // some browser quirk caused a touch event to fire during a mouse move, or vice versa.

      var thisNode = this.findDOMNode();

      if (thisNode) {
        var ownerDocument = thisNode.ownerDocument;
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
          passive: false
        });
        if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);
      }
    } // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.

  }, {
    key: "findDOMNode",
    value: function findDOMNode()
    /*: ?HTMLElement*/
    {
      return this.props.nodeRef ? this.props.nodeRef.current : _reactDom["default"].findDOMNode(this);
    }
  }, {
    key: "render",
    value: function render() {
      // Reuse the child provided
      // This makes it flexible to use whatever element is wanted (div, ul, etc)
      return React.cloneElement(React.Children.only(this.props.children), {
        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        // onTouchStart is added on `componentDidMount` so they can be added with
        // {passive: false}, which allows it to cancel. See 
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        onTouchEnd: this.onTouchEnd
      });
    }
  }]);

  return DraggableCore;
}(React.Component);

exports["default"] = DraggableCore;

_defineProperty(DraggableCore, "displayName", 'DraggableCore');

_defineProperty(DraggableCore, "propTypes", {
  /**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */
  allowAnyClick: _propTypes["default"].bool,

  /**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */
  disabled: _propTypes["default"].bool,

  /**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */
  enableUserSelectHack: _propTypes["default"].bool,

  /**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */
  offsetParent: function offsetParent(props
  /*: DraggableCoreProps*/
  , propName
  /*: $Keys<DraggableCoreProps>*/
  ) {
    if (props[propName] && props[propName].nodeType !== 1) {
      throw new Error('Draggable\'s offsetParent must be a DOM Node.');
    }
  },

  /**
   * `grid` specifies the x and y that dragging should snap to.
   */
  grid: _propTypes["default"].arrayOf(_propTypes["default"].number),

  /**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  handle: _propTypes["default"].string,

  /**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */
  cancel: _propTypes["default"].string,

  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
   * Unfortunately, in order for <Draggable> to work properly, we need raw access
   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
   * as in this example:
   *
   * function MyComponent() {
   *   const nodeRef = React.useRef(null);
   *   return (
   *     <Draggable nodeRef={nodeRef}>
   *       <div ref={nodeRef}>Example Target</div>
   *     </Draggable>
   *   );
   * }
   *
   * This can be used for arbitrarily nested components, so long as the ref ends up
   * pointing to the actual child DOM node and not a custom component.
   */
  nodeRef: _propTypes["default"].object,

  /**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onStart: _propTypes["default"].func,

  /**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onDrag: _propTypes["default"].func,

  /**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */
  onStop: _propTypes["default"].func,

  /**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */
  onMouseDown: _propTypes["default"].func,

  /**
   * `scale`, if set, applies scaling while dragging an element
   */
  scale: _propTypes["default"].number,

  /**
   * These properties should be defined on the child, not here.
   */
  className: _shims.dontSetMe,
  style: _shims.dontSetMe,
  transform: _shims.dontSetMe
});

_defineProperty(DraggableCore, "defaultProps", {
  allowAnyClick: false,
  // by default only accept left click
  cancel: null,
  disabled: false,
  enableUserSelectHack: true,
  offsetParent: null,
  handle: null,
  grid: null,
  transform: null,
  onStart: function onStart() {},
  onDrag: function onDrag() {},
  onStop: function onStop() {},
  onMouseDown: function onMouseDown() {},
  scale: 1
});

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isCallable = __webpack_require__(47);

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (hasOwnProperty.call(array, i)) {
      if (receiver == null) {
        iterator(array[i], i, array);
      } else {
        iterator.call(receiver, array[i], i, array);
      }
    }
  }
};

var forEachString = function forEachString(string, iterator, receiver) {
  for (var i = 0, len = string.length; i < len; i++) {
    // no such thing as a sparse string.
    if (receiver == null) {
      iterator(string.charAt(i), i, string);
    } else {
      iterator.call(receiver, string.charAt(i), i, string);
    }
  }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
  for (var k in object) {
    if (hasOwnProperty.call(object, k)) {
      if (receiver == null) {
        iterator(object[k], k, object);
      } else {
        iterator.call(receiver, object[k], k, object);
      }
    }
  }
};

var forEach = function forEach(list, iterator, thisArg) {
  if (!isCallable(iterator)) {
    throw new TypeError('iterator must be a function');
  }

  var receiver;

  if (arguments.length >= 3) {
    receiver = thisArg;
  }

  if (toStr.call(list) === '[object Array]') {
    forEachArray(list, iterator, receiver);
  } else if (typeof list === 'string') {
    forEachString(list, iterator, receiver);
  } else {
    forEachObject(list, iterator, receiver);
  }
};

module.exports = forEach;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var fnToStr = Function.prototype.toString;
var reflectApply = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;

if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
  try {
    badArrayLike = Object.defineProperty({}, 'length', {
      get: function get() {
        throw isCallableMarker;
      }
    });
    isCallableMarker = {}; // eslint-disable-next-line no-throw-literal

    reflectApply(function () {
      throw 42;
    }, null, badArrayLike);
  } catch (_) {
    if (_ !== isCallableMarker) {
      reflectApply = null;
    }
  }
} else {
  reflectApply = null;
}

var constructorRegex = /^\s*class\b/;

var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr.call(value);
    return constructorRegex.test(fnStr);
  } catch (e) {
    return false; // not a function
  }
};

var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }

    fnToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};

var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';
/* globals document: false */

var documentDotAll = (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && typeof document.all === 'undefined' && document.all !== undefined ? document.all : {};
module.exports = reflectApply ? function isCallable(value) {
  if (value === documentDotAll) {
    return true;
  }

  if (!value) {
    return false;
  }

  if (typeof value !== 'function' && _typeof(value) !== 'object') {
    return false;
  }

  if (typeof value === 'function' && !value.prototype) {
    return true;
  }

  try {
    reflectApply(value, null, badArrayLike);
  } catch (e) {
    if (e !== isCallableMarker) {
      return false;
    }
  }

  return !isES6ClassFn(value);
} : function isCallable(value) {
  if (value === documentDotAll) {
    return true;
  }

  if (!value) {
    return false;
  }

  if (typeof value !== 'function' && _typeof(value) !== 'object') {
    return false;
  }

  if (typeof value === 'function' && !value.prototype) {
    return true;
  }

  if (hasToStringTag) {
    return tryFunctionObject(value);
  }

  if (isES6ClassFn(value)) {
    return false;
  }

  var strClass = toStr.call(value);
  return strClass === fnClass || strClass === genClass;
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = "production" !== 'production';

var warning = function warning() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 1 ? len - 1 : 0);

    for (var key = 1; key < len; key++) {
      args[key - 1] = arguments[key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });

    if (typeof console !== 'undefined') {
      console.error(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);

    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }

    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
  var target = this;

  if (typeof target !== 'function' || toStr.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }

  var args = slice.call(arguments, 1);
  var bound;

  var binder = function binder() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice.call(arguments)));

      if (Object(result) === result) {
        return result;
      }

      return this;
    } else {
      return target.apply(that, args.concat(slice.call(arguments)));
    }
  };

  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];

  for (var i = 0; i < boundLength; i++) {
    boundArgs.push('$' + i);
  }

  bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

  if (target.prototype) {
    var Empty = function Empty() {};

    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }

  return bound;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var callBind = __webpack_require__(16);

var define = __webpack_require__(17);

var implementation = __webpack_require__(19);

var getPolyfill = __webpack_require__(20);

var shim = __webpack_require__(59);

var boundTrim = callBind(getPolyfill());
define(boundTrim, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = boundTrim;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var origSymbol = typeof Symbol !== 'undefined' && Symbol;

var hasSymbolSham = __webpack_require__(52);

module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }

  if (typeof Symbol !== 'function') {
    return false;
  }

  if (_typeof(origSymbol('foo')) !== 'symbol') {
    return false;
  }

  if (_typeof(Symbol('bar')) !== 'symbol') {
    return false;
  }

  return hasSymbolSham();
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint complexity: [2, 18], max-statements: [2, 33] */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }

  if (_typeof(Symbol.iterator) === 'symbol') {
    return true;
  }

  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);

  if (typeof sym === 'string') {
    return false;
  }

  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }

  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  } // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }
  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }


  var symVal = 42;
  obj[sym] = symVal;

  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop


  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }

  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }

  var syms = Object.getOwnPropertySymbols(obj);

  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }

  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }

  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);

    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }

  return true;
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var slice = Array.prototype.slice;

var isArgs = __webpack_require__(18);

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : __webpack_require__(54);
var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function () {
      // Safari 5.0 bug
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);

    if (!keysWorksWithArguments) {
      Object.keys = function keys(object) {
        // eslint-disable-line func-name-matching
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }

        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }

  return Object.keys || keysShim;
};

module.exports = keysShim;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var keysShim;

if (!Object.keys) {
  // modified from https://github.com/es-shims/es5-shim
  var has = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;

  var isArgs = __webpack_require__(18); // eslint-disable-line global-require


  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var hasDontEnumBug = !isEnumerable.call({
    toString: null
  }, 'toString');
  var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
  var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];

  var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };

  var excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };

  var hasAutomationEqualityBug = function () {
    /* global window */
    if (typeof window === 'undefined') {
      return false;
    }

    for (var k in window) {
      try {
        if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && _typeof(window[k]) === 'object') {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }

    return false;
  }();

  var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
    /* global window */
    if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }

    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };

  keysShim = function keys(object) {
    var isObject = object !== null && _typeof(object) === 'object';
    var isFunction = toStr.call(object) === '[object Function]';
    var isArguments = isArgs(object);
    var isString = isObject && toStr.call(object) === '[object String]';
    var theKeys = [];

    if (!isObject && !isFunction && !isArguments) {
      throw new TypeError('Object.keys called on a non-object');
    }

    var skipProto = hasProtoEnumBug && isFunction;

    if (isString && object.length > 0 && !has.call(object, 0)) {
      for (var i = 0; i < object.length; ++i) {
        theKeys.push(String(i));
      }
    }

    if (isArguments && object.length > 0) {
      for (var j = 0; j < object.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name in object) {
        if (!(skipProto && name === 'prototype') && has.call(object, name)) {
          theKeys.push(String(name));
        }
      }
    }

    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }

    return theKeys;
  };
}

module.exports = keysShim;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(56);

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(5);

var $TypeError = GetIntrinsic('%TypeError%'); // http://262.ecma-international.org/5.1/#sec-9.10

module.exports = function CheckObjectCoercible(value, optMessage) {
  if (value == null) {
    throw new $TypeError(optMessage || 'Cannot call method on ' + value);
  }

  return value;
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var GetIntrinsic = __webpack_require__(5);

var $String = GetIntrinsic('%String%');
var $TypeError = GetIntrinsic('%TypeError%'); // https://ecma-international.org/ecma-262/6.0/#sec-tostring

module.exports = function ToString(argument) {
  if (_typeof(argument) === 'symbol') {
    throw new $TypeError('Cannot convert a Symbol value to a string');
  }

  return $String(argument);
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(5);

var callBind = __webpack_require__(16);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic(name, !!allowMissing);

  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    return callBind(intrinsic);
  }

  return intrinsic;
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(17);

var getPolyfill = __webpack_require__(20);

module.exports = function shimStringTrim() {
  var polyfill = getPolyfill();
  define(String.prototype, {
    trim: polyfill
  }, {
    trim: function testTrim() {
      return String.prototype.trim !== polyfill;
    }
  });
  return polyfill;
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./messages_ar.json": 61,
	"./messages_cs.json": 62,
	"./messages_de.json": 63,
	"./messages_el.json": 64,
	"./messages_es.json": 65,
	"./messages_gl.json": 66,
	"./messages_hi.json": 67,
	"./messages_it.json": 68,
	"./messages_nl.json": 69,
	"./messages_pt.json": 70,
	"./messages_sv.json": 71,
	"./messages_tr.json": 72,
	"./messages_ur.json": 73
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 60;

/***/ }),
/* 61 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\" \",\"Add a reply...\":\" \",\"Add tag...\":\" \",\"Cancel\":\"\",\"Close\":\"\",\"Edit\":\"Edit\",\"Delete\":\"Delete\",\"Ok\":\"\"}");

/***/ }),
/* 62 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\"Napsat koment...\",\"Add a reply...\":\"Odpovdt...\",\"Add tag...\":\"Pidat ttek...\",\"Cancel\":\"Zruit\",\"Close\":\"Zavt\",\"Edit\":\"Upravit\",\"Delete\":\"Smazat\",\"Ok\":\"Ok\"}");

/***/ }),
/* 63 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\"Kommentar schreiben...\",\"Add a reply...\":\"Antwort schreiben...\",\"Add tag...\":\"Tag...\",\"Cancel\":\"Abbrechen\",\"Close\":\"Schliessen\",\"Edit\":\"Bearbeiten\",\"Delete\":\"Lschen\",\"Ok\":\"Ok\"}");

/***/ }),
/* 64 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\"...\",\"Add a reply...\":\"...\",\"Add tag...\":\" tag...\",\"Cancel\":\"\",\"Close\":\"\",\"Edit\":\"\",\"Delete\":\"\",\"Ok\":\"Ok\"}");

/***/ }),
/* 65 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\"Agregar un comentario...\",\"Add a reply...\":\"Agregar una respuesta...\",\"Add tag...\":\"Etiquetar...\",\"Cancel\":\"Cancelar\",\"Close\":\"Cerrar\",\"Edit\":\"Editar\",\"Delete\":\"Eliminar\",\"Ok\":\"Ok\"}");

/***/ }),
/* 66 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\"Engadir un comentario...\",\"Add a reply...\":\"Engadir unha resposta...\",\"Add tag...\":\"Etiquetar...\",\"Cancel\":\"Cancelar\",\"Close\":\"Pechar\",\"Edit\":\"Edit\",\"Delete\":\"Delete\",\"Ok\":\"Ok\"}");

/***/ }),
/* 67 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\" \",\"Add a reply...\":\" \",\"Add tag...\":\" \",\"Cancel\":\" \",\"Close\":\" \",\"Edit\":\" \",\"Delete\":\"\",\"Ok\":\" \"}");

/***/ }),
/* 68 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\"Commenta...\",\"Add a reply...\":\"Rispondi...\",\"Add tag...\":\"Aggiungi tag...\",\"Cancel\":\"Annulla\",\"Close\":\"Chiudi\",\"Edit\":\"Edit\",\"Delete\":\"Delete\",\"Ok\":\"Ok\"}");

/***/ }),
/* 69 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\"Commentaar toevoegen...\",\"Add a reply...\":\"Antwoord toevoegen...\",\"Add tag...\":\"Tag toevoegen...\",\"Cancel\":\"Afbreken\",\"Close\":\"Sluiten\",\"Edit\":\"Bewerken\",\"Delete\":\"Verwijderen\",\"Ok\":\"Ok\"}");

/***/ }),
/* 70 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\"Adicionar um comentrio...\",\"Add a reply...\":\"Adicionar uma resposta...\",\"Add tag...\":\"Etiquetar...\",\"Cancel\":\"Cancelar\",\"Close\":\"Fechar\",\"Edit\":\"Editar\",\"Delete\":\"Apagar\",\"Ok\":\"Ok\"}");

/***/ }),
/* 71 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\"Skriv en kommentar...\",\"Add a reply...\":\"Skriv ett svar...\",\"Add tag...\":\"Tagg...\",\"Cancel\":\"Cancel\",\"Close\":\"Stng\",\"Edit\":\"Edit\",\"Delete\":\"Delete\",\"Ok\":\"Ok\"}");

/***/ }),
/* 72 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\"Yorum ekle...\",\"Add a reply...\":\"Cevap ekle...\",\"Add tag...\":\"Tag Ekle...\",\"Cancel\":\"ptal\",\"Close\":\"Kapat\",\"Edit\":\"Dzenle\",\"Delete\":\"Sil\",\"Ok\":\"Tamam\"}");

/***/ }),
/* 73 */
/***/ (function(module) {

module.exports = JSON.parse("{\"Add a comment...\":\" \",\"Add a reply...\":\" \",\"Add tag...\":\" \",\"Cancel\":\" \",\"Close\":\" \",\"Edit\":\" \",\"Delete\":\"\",\"Ok\":\" \"}");

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function () {
  var extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (b.hasOwnProperty(p)) d[p] = b[p];
    }
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = this && this.__assign || Object.assign || function (t) {
  for (var s, i = 1, n = arguments.length; i < n; i++) {
    s = arguments[i];

    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
  }

  return t;
};

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
  }
  return t;
};

exports.__esModule = true;

var React = __webpack_require__(0);

var PropTypes = __webpack_require__(1);

var autosize = __webpack_require__(75);

var _getLineHeight = __webpack_require__(76);

var getLineHeight = _getLineHeight;
var RESIZED = "autosize:resized";
/**
 * A light replacement for built-in textarea component
 * which automaticaly adjusts its height to match the content
 */

var TextareaAutosizeClass =
/** @class */
function (_super) {
  __extends(TextareaAutosizeClass, _super);

  function TextareaAutosizeClass() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = {
      lineHeight: null
    };
    _this.textarea = null;

    _this.onResize = function (e) {
      if (_this.props.onResize) {
        _this.props.onResize(e);
      }
    };

    _this.updateLineHeight = function () {
      if (_this.textarea) {
        _this.setState({
          lineHeight: getLineHeight(_this.textarea)
        });
      }
    };

    _this.onChange = function (e) {
      var onChange = _this.props.onChange;
      _this.currentValue = e.currentTarget.value;
      onChange && onChange(e);
    };

    return _this;
  }

  TextareaAutosizeClass.prototype.componentDidMount = function () {
    var _this = this;

    var _a = this.props,
        maxRows = _a.maxRows,
        async = _a.async;

    if (typeof maxRows === "number") {
      this.updateLineHeight();
    }

    if (typeof maxRows === "number" || async) {
      /*
        the defer is needed to:
          - force "autosize" to activate the scrollbar when this.props.maxRows is passed
          - support StyledComponents (see #71)
      */
      setTimeout(function () {
        return _this.textarea && autosize(_this.textarea);
      });
    } else {
      this.textarea && autosize(this.textarea);
    }

    if (this.textarea) {
      this.textarea.addEventListener(RESIZED, this.onResize);
    }
  };

  TextareaAutosizeClass.prototype.componentWillUnmount = function () {
    if (this.textarea) {
      this.textarea.removeEventListener(RESIZED, this.onResize);
      autosize.destroy(this.textarea);
    }
  };

  TextareaAutosizeClass.prototype.render = function () {
    var _this = this;

    var _a = this,
        _b = _a.props,
        onResize = _b.onResize,
        maxRows = _b.maxRows,
        onChange = _b.onChange,
        style = _b.style,
        innerRef = _b.innerRef,
        children = _b.children,
        props = __rest(_b, ["onResize", "maxRows", "onChange", "style", "innerRef", "children"]),
        lineHeight = _a.state.lineHeight;

    var maxHeight = maxRows && lineHeight ? lineHeight * maxRows : null;
    return React.createElement("textarea", __assign({}, props, {
      onChange: this.onChange,
      style: maxHeight ? __assign({}, style, {
        maxHeight: maxHeight
      }) : style,
      ref: function ref(element) {
        _this.textarea = element;

        if (typeof _this.props.innerRef === 'function') {
          _this.props.innerRef(element);
        } else if (_this.props.innerRef) {
          _this.props.innerRef.current = element;
        }
      }
    }), children);
  };

  TextareaAutosizeClass.prototype.componentDidUpdate = function () {
    this.textarea && autosize.update(this.textarea);
  };

  TextareaAutosizeClass.defaultProps = {
    rows: 1,
    async: false
  };
  TextareaAutosizeClass.propTypes = {
    rows: PropTypes.number,
    maxRows: PropTypes.number,
    onResize: PropTypes.func,
    innerRef: PropTypes.any,
    async: PropTypes.bool
  };
  return TextareaAutosizeClass;
}(React.Component);

exports.TextareaAutosize = React.forwardRef(function (props, ref) {
  return React.createElement(TextareaAutosizeClass, __assign({}, props, {
    innerRef: ref
  }));
});

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	autosize 4.0.4
	license: MIT
	http://www.jacklmoore.com/autosize
*/
(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (module, exports) {
  'use strict';

  var map = typeof Map === "function" ? new Map() : function () {
    var keys = [];
    var values = [];
    return {
      has: function has(key) {
        return keys.indexOf(key) > -1;
      },
      get: function get(key) {
        return values[keys.indexOf(key)];
      },
      set: function set(key, value) {
        if (keys.indexOf(key) === -1) {
          keys.push(key);
          values.push(value);
        }
      },
      "delete": function _delete(key) {
        var index = keys.indexOf(key);

        if (index > -1) {
          keys.splice(index, 1);
          values.splice(index, 1);
        }
      }
    };
  }();

  var createEvent = function createEvent(name) {
    return new Event(name, {
      bubbles: true
    });
  };

  try {
    new Event('test');
  } catch (e) {
    // IE does not support `new Event()`
    createEvent = function createEvent(name) {
      var evt = document.createEvent('Event');
      evt.initEvent(name, true, false);
      return evt;
    };
  }

  function assign(ta) {
    if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;
    var heightOffset = null;
    var clientWidth = null;
    var cachedHeight = null;

    function init() {
      var style = window.getComputedStyle(ta, null);

      if (style.resize === 'vertical') {
        ta.style.resize = 'none';
      } else if (style.resize === 'both') {
        ta.style.resize = 'horizontal';
      }

      if (style.boxSizing === 'content-box') {
        heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
      } else {
        heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
      } // Fix when a textarea is not on document body and heightOffset is Not a Number


      if (isNaN(heightOffset)) {
        heightOffset = 0;
      }

      update();
    }

    function changeOverflow(value) {
      {
        // Chrome/Safari-specific fix:
        // When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
        // made available by removing the scrollbar. The following forces the necessary text reflow.
        var width = ta.style.width;
        ta.style.width = '0px'; // Force reflow:

        /* jshint ignore:start */

        ta.offsetWidth;
        /* jshint ignore:end */

        ta.style.width = width;
      }
      ta.style.overflowY = value;
    }

    function getParentOverflows(el) {
      var arr = [];

      while (el && el.parentNode && el.parentNode instanceof Element) {
        if (el.parentNode.scrollTop) {
          arr.push({
            node: el.parentNode,
            scrollTop: el.parentNode.scrollTop
          });
        }

        el = el.parentNode;
      }

      return arr;
    }

    function resize() {
      if (ta.scrollHeight === 0) {
        // If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
        return;
      }

      var overflows = getParentOverflows(ta);
      var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)

      ta.style.height = '';
      ta.style.height = ta.scrollHeight + heightOffset + 'px'; // used to check if an update is actually necessary on window.resize

      clientWidth = ta.clientWidth; // prevents scroll-position jumping

      overflows.forEach(function (el) {
        el.node.scrollTop = el.scrollTop;
      });

      if (docTop) {
        document.documentElement.scrollTop = docTop;
      }
    }

    function update() {
      resize();
      var styleHeight = Math.round(parseFloat(ta.style.height));
      var computed = window.getComputedStyle(ta, null); // Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box

      var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight; // The actual height not matching the style height (set via the resize method) indicates that 
      // the max-height has been exceeded, in which case the overflow should be allowed.

      if (actualHeight < styleHeight) {
        if (computed.overflowY === 'hidden') {
          changeOverflow('scroll');
          resize();
          actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
        }
      } else {
        // Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.
        if (computed.overflowY !== 'hidden') {
          changeOverflow('hidden');
          resize();
          actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
        }
      }

      if (cachedHeight !== actualHeight) {
        cachedHeight = actualHeight;
        var evt = createEvent('autosize:resized');

        try {
          ta.dispatchEvent(evt);
        } catch (err) {// Firefox will throw an error on dispatchEvent for a detached element
          // https://bugzilla.mozilla.org/show_bug.cgi?id=889376
        }
      }
    }

    var pageResize = function pageResize() {
      if (ta.clientWidth !== clientWidth) {
        update();
      }
    };

    var destroy = function (style) {
      window.removeEventListener('resize', pageResize, false);
      ta.removeEventListener('input', update, false);
      ta.removeEventListener('keyup', update, false);
      ta.removeEventListener('autosize:destroy', destroy, false);
      ta.removeEventListener('autosize:update', update, false);
      Object.keys(style).forEach(function (key) {
        ta.style[key] = style[key];
      });
      map["delete"](ta);
    }.bind(ta, {
      height: ta.style.height,
      resize: ta.style.resize,
      overflowY: ta.style.overflowY,
      overflowX: ta.style.overflowX,
      wordWrap: ta.style.wordWrap
    });

    ta.addEventListener('autosize:destroy', destroy, false); // IE9 does not fire onpropertychange or oninput for deletions,
    // so binding to onkeyup to catch most of those events.
    // There is no way that I know of to detect something like 'cut' in IE9.

    if ('onpropertychange' in ta && 'oninput' in ta) {
      ta.addEventListener('keyup', update, false);
    }

    window.addEventListener('resize', pageResize, false);
    ta.addEventListener('input', update, false);
    ta.addEventListener('autosize:update', update, false);
    ta.style.overflowX = 'hidden';
    ta.style.wordWrap = 'break-word';
    map.set(ta, {
      destroy: destroy,
      update: update
    });
    init();
  }

  function destroy(ta) {
    var methods = map.get(ta);

    if (methods) {
      methods.destroy();
    }
  }

  function update(ta) {
    var methods = map.get(ta);

    if (methods) {
      methods.update();
    }
  }

  var autosize = null; // Do nothing in Node.js environment and IE8 (or lower)

  if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
    autosize = function autosize(el) {
      return el;
    };

    autosize.destroy = function (el) {
      return el;
    };

    autosize.update = function (el) {
      return el;
    };
  } else {
    autosize = function autosize(el, options) {
      if (el) {
        Array.prototype.forEach.call(el.length ? el : [el], function (x) {
          return assign(x, options);
        });
      }

      return el;
    };

    autosize.destroy = function (el) {
      if (el) {
        Array.prototype.forEach.call(el.length ? el : [el], destroy);
      }

      return el;
    };

    autosize.update = function (el) {
      if (el) {
        Array.prototype.forEach.call(el.length ? el : [el], update);
      }

      return el;
    };
  }

  exports["default"] = autosize;
  module.exports = exports['default'];
});

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

// Load in dependencies
var computedStyle = __webpack_require__(77);
/**
 * Calculate the `line-height` of a given node
 * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.
 * @returns {Number} `line-height` of the element in pixels
 */


function lineHeight(node) {
  // Grab the line-height via style
  var lnHeightStr = computedStyle(node, 'line-height');
  var lnHeight = parseFloat(lnHeightStr, 10); // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')

  if (lnHeightStr === lnHeight + '') {
    // Save the old lineHeight style and update the em unit to the element
    var _lnHeightStyle = node.style.lineHeight;
    node.style.lineHeight = lnHeightStr + 'em'; // Calculate the em based height

    lnHeightStr = computedStyle(node, 'line-height');
    lnHeight = parseFloat(lnHeightStr, 10); // Revert the lineHeight style

    if (_lnHeightStyle) {
      node.style.lineHeight = _lnHeightStyle;
    } else {
      delete node.style.lineHeight;
    }
  } // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)
  // DEV: `em` units are converted to `pt` in IE6
  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length


  if (lnHeightStr.indexOf('pt') !== -1) {
    lnHeight *= 4;
    lnHeight /= 3; // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)
  } else if (lnHeightStr.indexOf('mm') !== -1) {
    lnHeight *= 96;
    lnHeight /= 25.4; // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)
  } else if (lnHeightStr.indexOf('cm') !== -1) {
    lnHeight *= 96;
    lnHeight /= 2.54; // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)
  } else if (lnHeightStr.indexOf('in') !== -1) {
    lnHeight *= 96; // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)
  } else if (lnHeightStr.indexOf('pc') !== -1) {
    lnHeight *= 16;
  } // Continue our computation


  lnHeight = Math.round(lnHeight); // If the line-height is "normal", calculate by font-size

  if (lnHeightStr === 'normal') {
    // Create a temporary node
    var nodeName = node.nodeName;

    var _node = document.createElement(nodeName);

    _node.innerHTML = '&nbsp;'; // If we have a text area, reset it to only 1 row
    // https://github.com/twolfson/line-height/issues/4

    if (nodeName.toUpperCase() === 'TEXTAREA') {
      _node.setAttribute('rows', '1');
    } // Set the font-size of the element


    var fontSizeStr = computedStyle(node, 'font-size');
    _node.style.fontSize = fontSizeStr; // Remove default padding/border which can affect offset height
    // https://github.com/twolfson/line-height/issues/4
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight

    _node.style.padding = '0px';
    _node.style.border = '0px'; // Append it to the body

    var body = document.body;
    body.appendChild(_node); // Assume the line height of the element is the height

    var height = _node.offsetHeight;
    lnHeight = height; // Remove our child from the DOM

    body.removeChild(_node);
  } // Return the calculated height


  return lnHeight;
} // Export lineHeight


module.exports = lineHeight;

/***/ }),
/* 77 */
/***/ (function(module, exports) {

// This code has been refactored for 140 bytes
// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js
var computedStyle = function computedStyle(el, prop, getComputedStyle) {
  getComputedStyle = window.getComputedStyle; // In one fell swoop

  return ( // If we have getComputedStyle
  getComputedStyle ? // Query it
  // TODO: From CSS-Query notes, we might need (node, null) for FF
  getComputedStyle(el) : // Otherwise, we are in IE and use currentStyle
  el.currentStyle)[// Switch to camelCase for CSSOM
  // DEV: Grabbed from jQuery
  // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194
  // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597
  prop.replace(/-(\w)/gi, function (word, letter) {
    return letter.toUpperCase();
  })];
};

module.exports = computedStyle;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(79);

var iterableToArray = __webpack_require__(80);

var unsupportedIterableToArray = __webpack_require__(81);

var nonIterableSpread = __webpack_require__(82);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(22);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 80 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(22);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 82 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var objectWithoutPropertiesLoose = __webpack_require__(84);

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 84 */
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 85 */
/***/ (function(module, exports) {

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

module.exports = _taggedTemplateLiteral;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 86 */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 87 */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(89);
} else {}

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var b = "function" === typeof Symbol && Symbol["for"],
    c = b ? Symbol["for"]("react.element") : 60103,
    d = b ? Symbol["for"]("react.portal") : 60106,
    e = b ? Symbol["for"]("react.fragment") : 60107,
    f = b ? Symbol["for"]("react.strict_mode") : 60108,
    g = b ? Symbol["for"]("react.profiler") : 60114,
    h = b ? Symbol["for"]("react.provider") : 60109,
    k = b ? Symbol["for"]("react.context") : 60110,
    l = b ? Symbol["for"]("react.async_mode") : 60111,
    m = b ? Symbol["for"]("react.concurrent_mode") : 60111,
    n = b ? Symbol["for"]("react.forward_ref") : 60112,
    p = b ? Symbol["for"]("react.suspense") : 60113,
    q = b ? Symbol["for"]("react.suspense_list") : 60120,
    r = b ? Symbol["for"]("react.memo") : 60115,
    t = b ? Symbol["for"]("react.lazy") : 60116,
    v = b ? Symbol["for"]("react.block") : 60121,
    w = b ? Symbol["for"]("react.fundamental") : 60117,
    x = b ? Symbol["for"]("react.responder") : 60118,
    y = b ? Symbol["for"]("react.scope") : 60119;

function z(a) {
  if ("object" === _typeof(a) && null !== a) {
    var u = a.$$typeof;

    switch (u) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;

          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;

              default:
                return u;
            }

        }

      case d:
        return u;
    }
  }
}

function A(a) {
  return z(a) === m;
}

exports.AsyncMode = l;
exports.ConcurrentMode = m;
exports.ContextConsumer = k;
exports.ContextProvider = h;
exports.Element = c;
exports.ForwardRef = n;
exports.Fragment = e;
exports.Lazy = t;
exports.Memo = r;
exports.Portal = d;
exports.Profiler = g;
exports.StrictMode = f;
exports.Suspense = p;

exports.isAsyncMode = function (a) {
  return A(a) || z(a) === l;
};

exports.isConcurrentMode = A;

exports.isContextConsumer = function (a) {
  return z(a) === k;
};

exports.isContextProvider = function (a) {
  return z(a) === h;
};

exports.isElement = function (a) {
  return "object" === _typeof(a) && null !== a && a.$$typeof === c;
};

exports.isForwardRef = function (a) {
  return z(a) === n;
};

exports.isFragment = function (a) {
  return z(a) === e;
};

exports.isLazy = function (a) {
  return z(a) === t;
};

exports.isMemo = function (a) {
  return z(a) === r;
};

exports.isPortal = function (a) {
  return z(a) === d;
};

exports.isProfiler = function (a) {
  return z(a) === g;
};

exports.isStrictMode = function (a) {
  return z(a) === f;
};

exports.isSuspense = function (a) {
  return z(a) === p;
};

exports.isValidElementType = function (a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === _typeof(a) && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};

exports.typeOf = z;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var b = 60103,
    c = 60106,
    d = 60107,
    e = 60108,
    f = 60114,
    g = 60109,
    h = 60110,
    k = 60112,
    l = 60113,
    m = 60120,
    n = 60115,
    p = 60116,
    q = 60121,
    r = 60122,
    u = 60117,
    v = 60129,
    w = 60131;

if ("function" === typeof Symbol && Symbol["for"]) {
  var x = Symbol["for"];
  b = x("react.element");
  c = x("react.portal");
  d = x("react.fragment");
  e = x("react.strict_mode");
  f = x("react.profiler");
  g = x("react.provider");
  h = x("react.context");
  k = x("react.forward_ref");
  l = x("react.suspense");
  m = x("react.suspense_list");
  n = x("react.memo");
  p = x("react.lazy");
  q = x("react.block");
  r = x("react.server.block");
  u = x("react.fundamental");
  v = x("react.debug_trace_mode");
  w = x("react.legacy_hidden");
}

function y(a) {
  if ("object" === _typeof(a) && null !== a) {
    var t = a.$$typeof;

    switch (t) {
      case b:
        switch (a = a.type, a) {
          case d:
          case f:
          case e:
          case l:
          case m:
            return a;

          default:
            switch (a = a && a.$$typeof, a) {
              case h:
              case k:
              case p:
              case n:
              case g:
                return a;

              default:
                return t;
            }

        }

      case c:
        return t;
    }
  }
}

var z = g,
    A = b,
    B = k,
    C = d,
    D = p,
    E = n,
    F = c,
    G = f,
    H = e,
    I = l;
exports.ContextConsumer = h;
exports.ContextProvider = z;
exports.Element = A;
exports.ForwardRef = B;
exports.Fragment = C;
exports.Lazy = D;
exports.Memo = E;
exports.Portal = F;
exports.Profiler = G;
exports.StrictMode = H;
exports.Suspense = I;

exports.isAsyncMode = function () {
  return !1;
};

exports.isConcurrentMode = function () {
  return !1;
};

exports.isContextConsumer = function (a) {
  return y(a) === h;
};

exports.isContextProvider = function (a) {
  return y(a) === g;
};

exports.isElement = function (a) {
  return "object" === _typeof(a) && null !== a && a.$$typeof === b;
};

exports.isForwardRef = function (a) {
  return y(a) === k;
};

exports.isFragment = function (a) {
  return y(a) === d;
};

exports.isLazy = function (a) {
  return y(a) === p;
};

exports.isMemo = function (a) {
  return y(a) === n;
};

exports.isPortal = function (a) {
  return y(a) === c;
};

exports.isProfiler = function (a) {
  return y(a) === f;
};

exports.isStrictMode = function (a) {
  return y(a) === e;
};

exports.isSuspense = function (a) {
  return y(a) === l;
};

exports.isValidElementType = function (a) {
  return "string" === typeof a || "function" === typeof a || a === d || a === f || a === v || a === e || a === l || a === m || a === w || "object" === _typeof(a) && null !== a && (a.$$typeof === p || a.$$typeof === n || a.$$typeof === g || a.$$typeof === h || a.$$typeof === k || a.$$typeof === u || a.$$typeof === q || a[0] === r) ? !0 : !1;
};

exports.typeOf = y;

/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/preact/compat/dist/compat.module.js + 2 modules
var compat_module = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js
var tiny_emitter = __webpack_require__(2);
var tiny_emitter_default = /*#__PURE__*/__webpack_require__.n(tiny_emitter);

// EXTERNAL MODULE: ./node_modules/react-draggable/build/cjs/cjs.js
var cjs = __webpack_require__(23);
var cjs_default = /*#__PURE__*/__webpack_require__.n(cjs);

// CONCATENATED MODULE: ./node_modules/timeago.js/esm/lang/en_US.js
var EN_US = ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'];
/* harmony default export */ var en_US = (function (diff, idx) {
  if (idx === 0) return ['just now', 'right now'];
  var unit = EN_US[Math.floor(idx / 2)];
  if (diff > 1) unit += 's';
  return [diff + " " + unit + " ago", "in " + diff + " " + unit];
});
// CONCATENATED MODULE: ./node_modules/timeago.js/esm/lang/zh_CN.js
var ZH_CN = ['', '', '', '', '', '', ''];
/* harmony default export */ var zh_CN = (function (diff, idx) {
  if (idx === 0) return ['', ''];
  var unit = ZH_CN[~~(idx / 2)];
  return [diff + " " + unit + "\u524D", diff + " " + unit + "\u540E"];
});
// CONCATENATED MODULE: ./node_modules/timeago.js/esm/register.js
/**
 * Created by hustcc on 18/5/20.
 * Contract: i@hust.cc
 */

/**
 * All supported locales
 */
var Locales = {};
/**
 * register a locale
 * @param locale
 * @param func
 */

var register = function register(locale, func) {
  Locales[locale] = func;
};
/**
 * get a locale, default is en_US
 * @param locale
 * @returns {*}
 */

var getLocale = function getLocale(locale) {
  return Locales[locale] || Locales['en_US'];
};
// CONCATENATED MODULE: ./node_modules/timeago.js/esm/utils/date.js
/**
 * Created by hustcc on 18/5/20.
 * Contract: i@hust.cc
 */
var SEC_ARRAY = [60, 60, 24, 7, 365 / 7 / 12, 12];
/**
 * format Date / string / timestamp to timestamp
 * @param input
 * @returns {*}
 */

function toDate(input) {
  if (input instanceof Date) return input; // @ts-ignore

  if (!isNaN(input) || /^\d+$/.test(input)) return new Date(parseInt(input));
  input = (input || ''). // @ts-ignore
  trim().replace(/\.\d+/, '') // remove milliseconds
  .replace(/-/, '/').replace(/-/, '/').replace(/(\d)T(\d)/, '$1 $2').replace(/Z/, ' UTC') // 2017-2-5T3:57:52Z -> 2017-2-5 3:57:52UTC
  .replace(/([+-]\d\d):?(\d\d)/, ' $1$2'); // -04:00 -> -0400

  return new Date(input);
}
/**
 * format the diff second to *** time ago, with setting locale
 * @param diff
 * @param localeFunc
 * @returns
 */

function formatDiff(diff, localeFunc) {
  /**
   * if locale is not exist, use defaultLocale.
   * if defaultLocale is not exist, use build-in `en`.
   * be sure of no error when locale is not exist.
   *
   * If `time in`, then 1
   * If `time ago`, then 0
   */
  var agoIn = diff < 0 ? 1 : 0;
  /**
   * Get absolute value of number (|diff| is non-negative) value of x
   * |diff| = diff if diff is positive
   * |diff| = -diff if diff is negative
   * |0| = 0
   */

  diff = Math.abs(diff);
  /**
   * Time in seconds
   */

  var totalSec = diff;
  /**
   * Unit of time
   */

  var idx = 0;

  for (; diff >= SEC_ARRAY[idx] && idx < SEC_ARRAY.length; idx++) {
    diff /= SEC_ARRAY[idx];
  }
  /**
   * Math.floor() is alternative of ~~
   *
   * The differences and bugs:
   * Math.floor(3.7) -> 4 but ~~3.7 -> 3
   * Math.floor(1559125440000.6) -> 1559125440000 but ~~1559125440000.6 -> 52311552
   *
   * More information about the performance of algebraic:
   * https://www.youtube.com/watch?v=65-RbBwZQdU
   */


  diff = Math.floor(diff);
  idx *= 2;
  if (diff > (idx === 0 ? 9 : 1)) idx += 1;
  return localeFunc(diff, idx, totalSec)[agoIn].replace('%s', diff.toString());
}
/**
 * calculate the diff second between date to be formatted an now date.
 * @param date
 * @param relativeDate
 * @returns {number}
 */

function diffSec(date, relativeDate) {
  var relDate = relativeDate ? toDate(relativeDate) : new Date();
  return (+relDate - +toDate(date)) / 1000;
}
/**
 * nextInterval: calculate the next interval time.
 * - diff: the diff sec between now and date to be formatted.
 *
 * What's the meaning?
 * diff = 61 then return 59
 * diff = 3601 (an hour + 1 second), then return 3599
 * make the interval with high performance.
 **/

function nextInterval(diff) {
  var rst = 1,
      i = 0,
      d = Math.abs(diff);

  for (; diff >= SEC_ARRAY[i] && i < SEC_ARRAY.length; i++) {
    diff /= SEC_ARRAY[i];
    rst *= SEC_ARRAY[i];
  }

  d = d % rst;
  d = d ? rst - d : rst;
  return Math.ceil(d);
}
// CONCATENATED MODULE: ./node_modules/timeago.js/esm/format.js


/**
 * format a TDate into string
 * @param date
 * @param locale
 * @param opts
 */

var format_format = function format(date, locale, opts) {
  // diff seconds
  var sec = diffSec(date, opts && opts.relativeDate); // format it with locale

  return formatDiff(sec, getLocale(locale));
};
// CONCATENATED MODULE: ./node_modules/timeago.js/esm/utils/dom.js
var ATTR_TIMEAGO_TID = 'timeago-id';
/**
 * get the datetime attribute, `datetime` are supported.
 * @param node
 * @returns {*}
 */

function getDateAttribute(node) {
  return node.getAttribute('datetime');
}
/**
 * set the node attribute, native DOM
 * @param node
 * @param timerId
 * @returns {*}
 */

function setTimerId(node, timerId) {
  // @ts-ignore
  node.setAttribute(ATTR_TIMEAGO_TID, timerId);
}
/**
 * get the timer id
 * @param node
 */

function getTimerId(node) {
  return parseInt(node.getAttribute(ATTR_TIMEAGO_TID));
}
// CONCATENATED MODULE: ./node_modules/timeago.js/esm/realtime.js


 // all realtime timer

var TIMER_POOL = {};
/**
 * clear a timer from pool
 * @param tid
 */

var clear = function clear(tid) {
  clearTimeout(tid);
  delete TIMER_POOL[tid];
}; // run with timer(setTimeout)


function run(node, date, localeFunc, opts) {
  // clear the node's exist timer
  clear(getTimerId(node));
  var relativeDate = opts.relativeDate,
      minInterval = opts.minInterval; // get diff seconds

  var diff = diffSec(date, relativeDate); // render

  node.innerText = formatDiff(diff, localeFunc);
  var tid = setTimeout(function () {
    run(node, date, localeFunc, opts);
  }, Math.min(Math.max(nextInterval(diff), minInterval || 1) * 1000, 0x7fffffff)); // there is no need to save node in object. Just save the key

  TIMER_POOL[tid] = 0;
  setTimerId(node, tid);
}
/**
 * cancel a timer or all timers
 * @param node - node hosting the time string
 */


function cancel(node) {
  // cancel one
  if (node) clear(getTimerId(node)); // cancel all
  // @ts-ignore
  else Object.keys(TIMER_POOL).forEach(clear);
}
/**
 * render a dom realtime
 * @param nodes
 * @param locale
 * @param opts
 */

function realtime_render(nodes, locale, opts) {
  // by .length
  // @ts-ignore
  var nodeList = nodes.length ? nodes : [nodes];
  nodeList.forEach(function (node) {
    run(node, getDateAttribute(node), getLocale(locale), opts || {});
  });
  return nodeList;
}
// CONCATENATED MODULE: ./node_modules/timeago.js/esm/index.js
/**
 * Created by hustcc on 18/5/20.
 * Contract: i@hust.cc
 */



register('en_US', en_US);
register('zh_CN', zh_CN);



// CONCATENATED MODULE: ./node_modules/timeago-react/esm/timeago-react.js
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = undefined && undefined.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



/**
 * Convert input to a valid datetime string of <time> tag
 * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time
 * @param input
 * @returns datetime string
 */

var toDateTime = function toDateTime(input) {
  // let date: Date = new Date();
  // if (input instanceof Date) {
  //   date = input;
  //   //@ts-ignore
  // } else if (!isNaN(input) || /^\d+$/.test(input)) {
  //   //@ts-ignore
  //   date = new Date(parseInt(input));
  // } else {
  //   date = new Date(input);
  // }
  // try {
  //   return date.toISOString();
  // } catch (e) {
  //   console.error('invalid datetime');
  //   return '';
  // }
  return '' + (input instanceof Date ? input.getTime() : input);
};

var timeago_react_TimeAgo =
/** @class */
function (_super) {
  __extends(TimeAgo, _super);

  function TimeAgo() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.dom = null;
    return _this;
  }

  TimeAgo.prototype.componentDidMount = function () {
    // fixed #6 https://github.com/hustcc/timeago-react/issues/6
    // to reduce the file size.
    // const { locale } = this.props;
    // if (locale !== 'en' && locale !== 'zh_CN') {
    //   timeago.register(locale, require('timeago.js/locales/' + locale));
    // }
    // render it.
    this.renderTimeAgo();
  };

  TimeAgo.prototype.componentDidUpdate = function () {
    this.renderTimeAgo();
  };

  TimeAgo.prototype.renderTimeAgo = function () {
    var _a = this.props,
        live = _a.live,
        datetime = _a.datetime,
        locale = _a.locale,
        opts = _a.opts; // cancel all the interval

    cancel(this.dom); // if is live

    if (live !== false) {
      // live render
      this.dom.setAttribute('datetime', toDateTime(datetime));
      realtime_render(this.dom, locale, opts);
    }
  }; // remove


  TimeAgo.prototype.componentWillUnmount = function () {
    cancel(this.dom);
  }; // for render


  TimeAgo.prototype.render = function () {
    var _this = this; // eslint-disable-next-line @typescript-eslint/no-unused-vars


    var _a = this.props,
        datetime = _a.datetime,
        live = _a.live,
        locale = _a.locale,
        opts = _a.opts,
        others = __rest(_a, ["datetime", "live", "locale", "opts"]);

    return /*#__PURE__*/compat_module["createElement"]("time", __assign({
      ref: function ref(c) {
        _this.dom = c;
      }
    }, others), format_format(datetime, locale, opts));
  };

  TimeAgo.defaultProps = {
    live: true,
    className: ''
  };
  return TimeAgo;
}(compat_module["Component"]);

/* harmony default export */ var timeago_react = (timeago_react_TimeAgo);
// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/editor/useClickOutside.js

function useClickOutside(ref, callback) {
  var onClickOutside = function onClickOutside(_) {
    if (ref.current && !ref.current.contains(event.target)) callback();
  };

  Object(compat_module["useEffect"])(function () {
    document.addEventListener('mousedown', onClickOutside);
    return function () {
      return document.removeEventListener('mousedown', onClickOutside);
    };
  });
}
// EXTERNAL MODULE: ./node_modules/node-polyglot/index.js
var node_polyglot = __webpack_require__(24);
var node_polyglot_default = /*#__PURE__*/__webpack_require__.n(node_polyglot);

// EXTERNAL MODULE: ./node_modules/timeago.js/lib/lang/ar.js
var ar = __webpack_require__(25);
var ar_default = /*#__PURE__*/__webpack_require__.n(ar);

// EXTERNAL MODULE: ./node_modules/timeago.js/lib/lang/cs.js
var cs = __webpack_require__(26);
var cs_default = /*#__PURE__*/__webpack_require__.n(cs);

// EXTERNAL MODULE: ./node_modules/timeago.js/lib/lang/de.js
var de = __webpack_require__(27);
var de_default = /*#__PURE__*/__webpack_require__.n(de);

// EXTERNAL MODULE: ./node_modules/timeago.js/lib/lang/el.js
var lang_el = __webpack_require__(28);
var el_default = /*#__PURE__*/__webpack_require__.n(lang_el);

// EXTERNAL MODULE: ./node_modules/timeago.js/lib/lang/es.js
var es = __webpack_require__(29);
var es_default = /*#__PURE__*/__webpack_require__.n(es);

// EXTERNAL MODULE: ./node_modules/timeago.js/lib/lang/gl.js
var gl = __webpack_require__(30);
var gl_default = /*#__PURE__*/__webpack_require__.n(gl);

// EXTERNAL MODULE: ./node_modules/timeago.js/lib/lang/hi_IN.js
var hi_IN = __webpack_require__(31);
var hi_IN_default = /*#__PURE__*/__webpack_require__.n(hi_IN);

// EXTERNAL MODULE: ./node_modules/timeago.js/lib/lang/it.js
var it = __webpack_require__(32);
var it_default = /*#__PURE__*/__webpack_require__.n(it);

// EXTERNAL MODULE: ./node_modules/timeago.js/lib/lang/nl.js
var nl = __webpack_require__(33);
var nl_default = /*#__PURE__*/__webpack_require__.n(nl);

// EXTERNAL MODULE: ./node_modules/timeago.js/lib/lang/pt_BR.js
var pt_BR = __webpack_require__(34);
var pt_BR_default = /*#__PURE__*/__webpack_require__.n(pt_BR);

// EXTERNAL MODULE: ./node_modules/timeago.js/lib/lang/sv.js
var sv = __webpack_require__(35);
var sv_default = /*#__PURE__*/__webpack_require__.n(sv);

// EXTERNAL MODULE: ./node_modules/timeago.js/lib/lang/tr.js
var tr = __webpack_require__(36);
var tr_default = /*#__PURE__*/__webpack_require__.n(tr);

// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/i18n/index.js


var i18n = new node_polyglot_default.a({
  allowMissing: true
});

i18n.init = function (lang, opt_messages) {
  if (lang) {
    i18n.locale(lang);
    i18n.extend(__webpack_require__(60)("./messages_".concat(lang, ".json")));
  }

  if (opt_messages) i18n.extend(opt_messages);
};
/** Load and register TimeAgo locales **/













 // import ur from 'timeago.js/lib/lang/ur'; // Not currently supported by TimeAgo 

register('ar', ar_default.a);
register('cs', cs_default.a);
register('de', de_default.a);
register('el', el_default.a);
register('es', es_default.a);
register('gl', gl_default.a);
register('hi', hi_IN_default.a);
register('it', it_default.a);
register('nl', nl_default.a);
register('pt', pt_BR_default.a);
register('sv', sv_default.a);
register('tr', tr_default.a);
/* harmony default export */ var src_i18n = (i18n);
// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/editor/widgets/comment/DropdownMenu.jsx




var DropdownMenu_DropdownMenu = function DropdownMenu(props) {
  var ref = Object(compat_module["useRef"])(); // Custom hook that notifies when clicked outside this component

  useClickOutside(ref, function () {
    return props.onClickOutside();
  });
  return /*#__PURE__*/compat_module["default"].createElement("ul", {
    ref: ref,
    className: "r6o-comment-dropdown-menu r6o-nodrag"
  }, /*#__PURE__*/compat_module["default"].createElement("li", {
    onClick: props.onEdit
  }, src_i18n.t('Edit')), /*#__PURE__*/compat_module["default"].createElement("li", {
    onClick: props.onDelete
  }, src_i18n.t('Delete')));
};

/* harmony default export */ var comment_DropdownMenu = (DropdownMenu_DropdownMenu);
// EXTERNAL MODULE: ./node_modules/react-autosize-textarea/lib/index.js
var lib = __webpack_require__(37);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/editor/widgets/comment/TextEntryField.jsx
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/** 
 * A basic text entry field, for reuse in different widgets.
 */

var TextEntryField_TextEntryField = /*#__PURE__*/function (_Component) {
  _inherits(TextEntryField, _Component);

  var _super = _createSuper(TextEntryField);

  function TextEntryField(props) {
    var _this;

    _classCallCheck(this, TextEntryField);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "onKeyDown", function (evt) {
      if (evt.which === 13 && evt.ctrlKey) _this.props.onSaveAndClose();
    });

    _this.element = /*#__PURE__*/Object(compat_module["createRef"])();
    return _this;
  } // CTRL+Enter functions as Ok


  _createClass(TextEntryField, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.focus && this.element.current) this.element.current.focus({
        preventScroll: true
      });
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/compat_module["default"].createElement(lib_default.a, {
        ref: this.element,
        className: this.props.editable ? 'r6o-editable-text r6o-nodrag' : 'r6o-editable-text',
        value: this.props.content,
        placeholder: this.props.placeholder || src_i18n.t('Add a comment...'),
        disabled: !this.props.editable,
        onChange: this.props.onChange,
        onKeyDown: this.onKeyDown
      });
    }
  }]);

  return TextEntryField;
}(compat_module["Component"]);


// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}
// CONCATENATED MODULE: ./node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
/*

Based off glamor's StyleSheet, thanks Sunil 

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}

var StyleSheet = /*#__PURE__*/function () {
  function StyleSheet(options) {
    var _this = this;

    this._insertTag = function (tag) {
      var before;

      if (_this.tags.length === 0) {
        before = _this.prepend ? _this.container.firstChild : _this.before;
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }

      _this.container.insertBefore(tag, before);

      _this.tags.push(tag);
    };

    this.isSpeedy = options.speedy === undefined ? "production" === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }

    var tag = this.tags[this.tags.length - 1];

    if (false) { var isImportRule; }

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (false) {}
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;

    if (false) {}
  };

  return StyleSheet;
}();


// CONCATENATED MODULE: ./node_modules/stylis/dist/stylis.mjs
var e="-ms-";var stylis_r="-moz-";var stylis_a="-webkit-";var stylis_c="comm";var stylis_n="rule";var t="decl";var s="@page";var u="@media";var stylis_i="@import";var f="@charset";var stylis_o="@viewport";var stylis_l="@supports";var stylis_v="@document";var stylis_h="@namespace";var stylis_p="@keyframes";var stylis_b="@font-face";var stylis_w="@counter-style";var $="@font-feature-values";var k=Math.abs;var d=String.fromCharCode;function m(e,r){return(((r<<2^z(e,0))<<2^z(e,1))<<2^z(e,2))<<2^z(e,3)}function stylis_g(e){return e.trim()}function stylis_x(e,r){return(e=r.exec(e))?e[0]:e}function stylis_y(e,r,a){return e.replace(r,a)}function j(e,r){return e.indexOf(r)}function z(e,r){return e.charCodeAt(r)|0}function C(e,r,a){return e.slice(r,a)}function A(e){return e.length}function M(e){return e.length}function O(e,r){return r.push(e),e}function S(e,r){return e.map(r).join("")}var q=1;var B=1;var D=0;var E=0;var F=0;var G="";function H(e,r,a,c,n,t,s){return{value:e,root:r,parent:a,type:c,props:n,children:t,line:q,column:B,length:s,return:""}}function I(e,r,a){return H(e,r.root,r.parent,a,r.props,r.children,0)}function J(){return F}function K(){F=E>0?z(G,--E):0;if(B--,F===10)B=1,q--;return F}function L(){F=E<D?z(G,E++):0;if(B++,F===10)B=1,q++;return F}function N(){return z(G,E)}function P(){return E}function Q(e,r){return C(G,e,r)}function R(e){switch(e){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function T(e){return q=B=1,D=A(G=e),E=0,[]}function U(e){return G="",e}function V(e){return stylis_g(Q(E-1,stylis_(e===91?e+2:e===40?e+1:e)))}function W(e){return U(Y(T(e)))}function X(e){while(F=N())if(F<33)L();else break;return R(e)>2||R(F)>3?"":" "}function Y(e){while(L())switch(R(F)){case 0:O(re(E-1),e);break;case 2:O(V(F),e);break;default:O(d(F),e)}return e}function Z(e,r){while(--r&&L())if(F<48||F>102||F>57&&F<65||F>70&&F<97)break;return Q(e,P()+(r<6&&N()==32&&L()==32))}function stylis_(e){while(L())switch(F){case e:return E;case 34:case 39:return stylis_(e===34||e===39?e:F);case 40:if(e===41)stylis_(e);break;case 92:L();break}return E}function ee(e,r){while(L())if(e+F===47+10)break;else if(e+F===42+42&&N()===47)break;return"/*"+Q(r,E-1)+"*"+d(e===47?e:L())}function re(e){while(!R(N()))L();return Q(e,E)}function ae(e){return U(ce("",null,null,null,[""],e=T(e),0,[0],e))}function ce(e,r,a,c,n,t,s,u,i){var f=0;var o=0;var l=s;var v=0;var h=0;var p=0;var b=1;var w=1;var $=1;var k=0;var m="";var g=n;var x=t;var j=c;var z=m;while(w)switch(p=k,k=L()){case 34:case 39:case 91:case 40:z+=V(k);break;case 9:case 10:case 13:case 32:z+=X(p);break;case 92:z+=Z(P()-1,7);continue;case 47:switch(N()){case 42:case 47:O(te(ee(L(),P()),r,a),i);break;default:z+="/"}break;case 123*b:u[f++]=A(z)*$;case 125*b:case 59:case 0:switch(k){case 0:case 125:w=0;case 59+o:if(h>0&&A(z)-l)O(h>32?se(z+";",c,a,l-1):se(stylis_y(z," ","")+";",c,a,l-2),i);break;case 59:z+=";";default:O(j=ne(z,r,a,f,o,n,u,m,g=[],x=[],l),t);if(k===123)if(o===0)ce(z,r,j,j,g,t,l,u,x);else switch(v){case 100:case 109:case 115:ce(e,j,j,c&&O(ne(e,j,j,0,0,n,u,m,n,g=[],l),x),n,x,l,u,c?g:x);break;default:ce(z,j,j,j,[""],x,l,u,x)}}f=o=h=0,b=$=1,m=z="",l=s;break;case 58:l=1+A(z),h=p;default:if(b<1)if(k==123)--b;else if(k==125&&b++==0&&K()==125)continue;switch(z+=d(k),k*b){case 38:$=o>0?1:(z+="\f",-1);break;case 44:u[f++]=(A(z)-1)*$,$=1;break;case 64:if(N()===45)z+=V(L());v=N(),o=A(m=z+=re(P())),k++;break;case 45:if(p===45&&A(z)==2)b=0}}return t}function ne(e,r,a,c,t,s,u,i,f,o,l){var v=t-1;var h=t===0?s:[""];var p=M(h);for(var b=0,w=0,$=0;b<c;++b)for(var d=0,m=C(e,v+1,v=k(w=u[b])),x=e;d<p;++d)if(x=stylis_g(w>0?h[d]+" "+m:stylis_y(m,/&\f/g,h[d])))f[$++]=x;return H(e,r,a,t===0?stylis_n:i,f,o,l)}function te(e,r,a){return H(e,r,a,stylis_c,d(J()),C(e,2,-2),0)}function se(e,r,a,c){return H(e,r,a,t,C(e,0,c),C(e,c+1,-1),c)}function ue(c,n){switch(m(c,n)){case 5103:return stylis_a+"print-"+c+c;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return stylis_a+c+c;case 5349:case 4246:case 4810:case 6968:case 2756:return stylis_a+c+stylis_r+c+e+c+c;case 6828:case 4268:return stylis_a+c+e+c+c;case 6165:return stylis_a+c+e+"flex-"+c+c;case 5187:return stylis_a+c+stylis_y(c,/(\w+).+(:[^]+)/,stylis_a+"box-$1$2"+e+"flex-$1$2")+c;case 5443:return stylis_a+c+e+"flex-item-"+stylis_y(c,/flex-|-self/,"")+c;case 4675:return stylis_a+c+e+"flex-line-pack"+stylis_y(c,/align-content|flex-|-self/,"")+c;case 5548:return stylis_a+c+e+stylis_y(c,"shrink","negative")+c;case 5292:return stylis_a+c+e+stylis_y(c,"basis","preferred-size")+c;case 6060:return stylis_a+"box-"+stylis_y(c,"-grow","")+stylis_a+c+e+stylis_y(c,"grow","positive")+c;case 4554:return stylis_a+stylis_y(c,/([^-])(transform)/g,"$1"+stylis_a+"$2")+c;case 6187:return stylis_y(stylis_y(stylis_y(c,/(zoom-|grab)/,stylis_a+"$1"),/(image-set)/,stylis_a+"$1"),c,"")+c;case 5495:case 3959:return stylis_y(c,/(image-set\([^]*)/,stylis_a+"$1"+"$`$1");case 4968:return stylis_y(stylis_y(c,/(.+:)(flex-)?(.*)/,stylis_a+"box-pack:$3"+e+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+stylis_a+c+c;case 4095:case 3583:case 4068:case 2532:return stylis_y(c,/(.+)-inline(.+)/,stylis_a+"$1$2")+c;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(A(c)-1-n>6)switch(z(c,n+1)){case 109:if(z(c,n+4)!==45)break;case 102:return stylis_y(c,/(.+:)(.+)-([^]+)/,"$1"+stylis_a+"$2-$3"+"$1"+stylis_r+(z(c,n+3)==108?"$3":"$2-$3"))+c;case 115:return~j(c,"stretch")?ue(stylis_y(c,"stretch","fill-available"),n)+c:c}break;case 4949:if(z(c,n+1)!==115)break;case 6444:switch(z(c,A(c)-3-(~j(c,"!important")&&10))){case 107:return stylis_y(c,":",":"+stylis_a)+c;case 101:return stylis_y(c,/(.+:)([^;!]+)(;|!.+)?/,"$1"+stylis_a+(z(c,14)===45?"inline-":"")+"box$3"+"$1"+stylis_a+"$2$3"+"$1"+e+"$2box$3")+c}break;case 5936:switch(z(c,n+11)){case 114:return stylis_a+c+e+stylis_y(c,/[svh]\w+-[tblr]{2}/,"tb")+c;case 108:return stylis_a+c+e+stylis_y(c,/[svh]\w+-[tblr]{2}/,"tb-rl")+c;case 45:return stylis_a+c+e+stylis_y(c,/[svh]\w+-[tblr]{2}/,"lr")+c}return stylis_a+c+e+c+c}return c}function ie(e,r){var a="";var c=M(e);for(var n=0;n<c;n++)a+=r(e[n],n,e,r)||"";return a}function fe(e,r,a,s){switch(e.type){case stylis_i:case t:return e.return=e.return||e.value;case stylis_c:return"";case stylis_n:e.value=e.props.join(",")}return A(a=ie(e.children,s))?e.return=e.value+"{"+a+"}":""}function oe(e){var r=M(e);return function(a,c,n,t){var s="";for(var u=0;u<r;u++)s+=e[u](a,c,n,t)||"";return s}}function le(e){return function(r){if(!r.root)if(r=r.return)e(r)}}function ve(c,s,u,i){if(!c.return)switch(c.type){case t:c.return=ue(c.value,c.length);break;case stylis_p:return ie([I(stylis_y(c.value,"@","@"+stylis_a),c,"")],i);case stylis_n:if(c.length)return S(c.props,(function(n){switch(stylis_x(n,/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":return ie([I(stylis_y(n,/:(read-\w+)/,":"+stylis_r+"$1"),c,"")],i);case"::placeholder":return ie([I(stylis_y(n,/:(plac\w+)/,":"+stylis_a+"input-$1"),c,""),I(stylis_y(n,/:(plac\w+)/,":"+stylis_r+"$1"),c,""),I(stylis_y(n,/:(plac\w+)/,e+"input-$1"),c,"")],i)}return""}))}}function he(e){switch(e.type){case stylis_n:e.props=e.props.map((function(r){return S(W(r),(function(r,a,c){switch(z(r,0)){case 12:return C(r,1,A(r));case 0:case 40:case 43:case 62:case 126:return r;case 58:if(c[++a]==="global")c[a]="",c[++a]="\f"+C(c[a],a=1,-1);case 32:return a===1?"":r;default:switch(a){case 0:e=r;return M(c)>1?"":r;case a=M(c)-1:case 2:return a===2?r+e+e:r+e;default:return r}}}))}))}}
//# sourceMappingURL=stylis.mjs.map

// CONCATENATED MODULE: ./node_modules/@emotion/weak-memoize/dist/weak-memoize.browser.esm.js
var weakMemoize = function weakMemoize(func) {
  // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps
  var cache = new WeakMap();
  return function (arg) {
    if (cache.has(arg)) {
      // $FlowFixMe
      return cache.get(arg);
    }

    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};

/* harmony default export */ var weak_memoize_browser_esm = (weakMemoize);
// CONCATENATED MODULE: ./node_modules/@emotion/memoize/dist/emotion-memoize.browser.esm.js
function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

/* harmony default export */ var emotion_memoize_browser_esm = (memoize);
// CONCATENATED MODULE: ./node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js





var last = function last(arr) {
  return arr.length ? arr[arr.length - 1] : null;
};

var emotion_cache_browser_esm_toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;

  do {
    switch (R(character)) {
      case 0:
        // &\f
        if (character === 38 && N() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }

        parsed[index] += re(E - 1);
        break;

      case 2:
        parsed[index] += V(character);
        break;

      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = N() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += d(character);
    }
  } while (character = L());

  return parsed;
};

var emotion_cache_browser_esm_getRules = function getRules(value, points) {
  return U(emotion_cache_browser_esm_toRules(T(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


var fixedElements = /* #__PURE__ */new WeakMap();

var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent || // .length indicates if this rule contains pseudo or not
  !element.length) {
    return;
  }

  var value = element.value,
      parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;

  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case


  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */
  && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


  if (isImplicitRule) {
    return;
  }

  fixedElements.set(element, true);
  var points = [];
  var rules = emotion_cache_browser_esm_getRules(value, points);
  var parentRules = parent.props;

  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};

var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;

    if ( // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};

var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';

var isIgnoringComment = function isIgnoringComment(element) {
  return !!element && element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
};

var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
  return function (element, index, children) {
    if (element.type !== 'rule') return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);

    if (unsafePseudoClasses && cache.compat !== true) {
      var prevElement = index > 0 ? children[index - 1] : null;

      if (prevElement && isIgnoringComment(last(prevElement.children))) {
        return;
      }

      unsafePseudoClasses.forEach(function (unsafePseudoClass) {
        console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
      });
    }
  };
};

var isImportRule = function isImportRule(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};

var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }

  return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user


var nullifyElement = function nullifyElement(element) {
  element.type = '';
  element.value = '';
  element["return"] = '';
  element.children = '';
  element.props = '';
};

var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }

  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};

var defaultStylisPlugins = [ve];

var emotion_cache_browser_esm_createCache = function createCache(options) {
  var key = options.key;

  if (false) {}

  if (key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');

      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }

      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }

  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

  if (false) {}

  var inserted = {}; // $FlowFixMe

  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }

      nodesToHydrate.push(node);
    });
  }

  var _insert;

  var omnipresentPlugins = [compat, removeLabel];

  if (false) {}

  {
    var currentSheet;
    var finalizingPlugins = [fe,  false ? undefined : le(function (rule) {
      currentSheet.insert(rule);
    })];
    var serializer = oe(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

    var stylis = function stylis(styles) {
      return ie(ae(styles), serializer);
    };

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;

      if (false) {}

      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key: key,
    sheet: new StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

/* harmony default export */ var emotion_cache_browser_esm = (emotion_cache_browser_esm_createCache);
// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var hoist_non_react_statics_cjs = __webpack_require__(10);
var hoist_non_react_statics_cjs_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics_cjs);

// CONCATENATED MODULE: ./node_modules/@emotion/react/isolated-hoist-non-react-statics-do-not-use-this-in-your-code/dist/emotion-react-isolated-hoist-non-react-statics-do-not-use-this-in-your-code.browser.esm.js
 // this file isolates this package that is not tree-shakeable
// and if this module doesn't actually contain any logic of its own
// then Rollup just use 'hoist-non-react-statics' directly in other chunks

var emotion_react_isolated_hoist_non_react_statics_do_not_use_this_in_your_code_browser_esm_hoistNonReactStatics = function hoistNonReactStatics(targetComponent, sourceComponent) {
  return hoist_non_react_statics_cjs_default()(targetComponent, sourceComponent);
};

/* harmony default export */ var emotion_react_isolated_hoist_non_react_statics_do_not_use_this_in_your_code_browser_esm = (emotion_react_isolated_hoist_non_react_statics_do_not_use_this_in_your_code_browser_esm_hoistNonReactStatics);
// CONCATENATED MODULE: ./node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = "object" !== 'undefined';

function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}

var insertStyles = function insertStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === false) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }

  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;

    do {
      var maybeStyles = cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);
      current = current.next;
    } while (current !== undefined);
  }
};


// CONCATENATED MODULE: ./node_modules/@emotion/hash/dist/hash.browser.esm.js
/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

/* harmony default export */ var hash_browser_esm = (murmur2);
// CONCATENATED MODULE: ./node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
/* harmony default export */ var unitless_browser_esm = (unitlessKeys);
// CONCATENATED MODULE: ./node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js
function emotion_serialize_browser_esm_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { emotion_serialize_browser_esm_typeof = function _typeof(obj) { return typeof obj; }; } else { emotion_serialize_browser_esm_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return emotion_serialize_browser_esm_typeof(obj); }




var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};

var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};

var processStyleName = /* #__PURE__ */emotion_memoize_browser_esm(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});

var emotion_serialize_browser_esm_processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }

  if (unitless_browser_esm[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }

  return value;
};

if (false) { var hyphenatedCache, hyphenPattern, msPattern, oldProcessStyleValue, contentValues, contentValuePattern; }

function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return '';
  }

  if (interpolation.__emotion_styles !== undefined) {
    if (false) {}

    return interpolation;
  }

  switch (emotion_serialize_browser_esm_typeof(interpolation)) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }

        if (interpolation.styles !== undefined) {
          var next = interpolation.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }

          var styles = interpolation.styles + ";";

          if (false) {}

          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        } else if (false) {}

        break;
      }

    case 'string':
      if (false) { var replaced, matched; }

      break;
  } // finalize string values (regular strings and functions interpolated into css calls)


  if (registered == null) {
    return interpolation;
  }

  var cached = registered[interpolation];
  return cached !== undefined ? cached : interpolation;
}

function createStringFromObject(mergedProps, registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];

      if (emotion_serialize_browser_esm_typeof(value) !== 'object') {
        if (registered != null && registered[value] !== undefined) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + emotion_serialize_browser_esm_processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {
          throw new Error('Component selectors can only be used in conjunction with @emotion/babel-plugin.');
        }

        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + emotion_serialize_browser_esm_processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);

          switch (_key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }

            default:
              {
                if (false) {}

                string += _key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }

  return string;
}

var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;

if (false) {} // this is the cursor for keyframes
// keyframes are stored on the SerializedStyles object as a linked list


var cursor;

var emotion_serialize_browser_esm_serializeStyles = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && emotion_serialize_browser_esm_typeof(args[0]) === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];

  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (false) {}

    styles += strings[0];
  } // we start at 1 since we've already handled the first arg


  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);

    if (stringMode) {
      if (false) {}

      styles += strings[i];
    }
  }

  var sourceMap;

  if (false) {} // using a global regex with .exec is stateful so lastIndex has to be reset each time


  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' + // $FlowFixMe we know it's not null
    match[1];
  }

  var name = hash_browser_esm(styles) + identifierName;

  if (false) {}

  return {
    name: name,
    styles: styles,
    next: cursor
  };
};


// CONCATENATED MODULE: ./node_modules/@emotion/react/dist/emotion-element-a8309070.browser.esm.js
function emotion_element_a8309070_browser_esm_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { emotion_element_a8309070_browser_esm_typeof = function _typeof(obj) { return typeof obj; }; } else { emotion_element_a8309070_browser_esm_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return emotion_element_a8309070_browser_esm_typeof(obj); }








var emotion_element_a8309070_browser_esm_hasOwnProperty = Object.prototype.hasOwnProperty;
var EmotionCacheContext = /* #__PURE__ */Object(compat_module["createContext"])( // we're doing this to avoid preconstruct's dead code elimination in this one case
// because this module is primarily intended for the browser and node
// but it's also required in react native and similar environments sometimes
// and we could have a special build just for that
// but this is much easier and the native packages
// might use a different theme context in the future anyway
typeof HTMLElement !== 'undefined' ? /* #__PURE__ */emotion_cache_browser_esm({
  key: 'css'
}) : null);
var CacheProvider = EmotionCacheContext.Provider;

var emotion_element_a8309070_browser_esm_withEmotionCache = function withEmotionCache(func) {
  // $FlowFixMe
  return /*#__PURE__*/Object(compat_module["forwardRef"])(function (props, ref) {
    // the cache will never be null in the browser
    var cache = Object(compat_module["useContext"])(EmotionCacheContext);
    return func(props, cache, ref);
  });
};

var ThemeContext = /* #__PURE__ */Object(compat_module["createContext"])({});

var emotion_element_a8309070_browser_esm_useTheme = function useTheme() {
  return Object(compat_module["useContext"])(ThemeContext);
};

var emotion_element_a8309070_browser_esm_getTheme = function getTheme(outerTheme, theme) {
  if (typeof theme === 'function') {
    var mergedTheme = theme(outerTheme);

    if (false) {}

    return mergedTheme;
  }

  if (false) {}

  return _extends({}, outerTheme, theme);
};

var createCacheWithTheme = /* #__PURE__ */weak_memoize_browser_esm(function (outerTheme) {
  return weak_memoize_browser_esm(function (theme) {
    return emotion_element_a8309070_browser_esm_getTheme(outerTheme, theme);
  });
});

var emotion_element_a8309070_browser_esm_ThemeProvider = function ThemeProvider(props) {
  var theme = Object(compat_module["useContext"])(ThemeContext);

  if (props.theme !== theme) {
    theme = createCacheWithTheme(theme)(props.theme);
  }

  return /*#__PURE__*/Object(compat_module["createElement"])(ThemeContext.Provider, {
    value: theme
  }, props.children);
};

function withTheme(Component) {
  var componentName = Component.displayName || Component.name || 'Component';

  var render = function render(props, ref) {
    var theme = Object(compat_module["useContext"])(ThemeContext);
    return /*#__PURE__*/Object(compat_module["createElement"])(Component, _extends({
      theme: theme,
      ref: ref
    }, props));
  }; // $FlowFixMe


  var WithTheme = /*#__PURE__*/Object(compat_module["forwardRef"])(render);
  WithTheme.displayName = "WithTheme(" + componentName + ")";
  return emotion_react_isolated_hoist_non_react_statics_do_not_use_this_in_your_code_browser_esm(WithTheme, Component);
} // thus we only need to replace what is a valid character for JS, but not for CSS


var sanitizeIdentifier = function sanitizeIdentifier(identifier) {
  return identifier.replace(/\$/g, '-');
};

var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';

var createEmotionProps = function createEmotionProps(type, props) {
  if (false) {}

  var newProps = {};

  for (var key in props) {
    if (emotion_element_a8309070_browser_esm_hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }

  newProps[typePropName] = type;

  if (false) { var match, error; }

  return newProps;
};

var Emotion = /* #__PURE__ */emotion_element_a8309070_browser_esm_withEmotionCache(function (props, cache, ref) {
  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }

  var type = props[typePropName];
  var registeredStyles = [cssProp];
  var className = '';

  if (typeof props.className === 'string') {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }

  var serialized = emotion_serialize_browser_esm_serializeStyles(registeredStyles, undefined, typeof cssProp === 'function' || Array.isArray(cssProp) ? Object(compat_module["useContext"])(ThemeContext) : undefined);

  if (false) { var labelFromStack; }

  var rules = insertStyles(cache, serialized, typeof type === 'string');
  className += cache.key + "-" + serialized.name;
  var newProps = {};

  for (var key in props) {
    if (emotion_element_a8309070_browser_esm_hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && ( true || false)) {
      newProps[key] = props[key];
    }
  }

  newProps.ref = ref;
  newProps.className = className;
  var ele = /*#__PURE__*/Object(compat_module["createElement"])(type, newProps);
  return ele;
});

if (false) {}


// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/extends.js
var helpers_extends = __webpack_require__(21);

// CONCATENATED MODULE: ./node_modules/@emotion/react/dist/emotion-react.browser.esm.js
function emotion_react_browser_esm_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { emotion_react_browser_esm_typeof = function _typeof(obj) { return typeof obj; }; } else { emotion_react_browser_esm_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return emotion_react_browser_esm_typeof(obj); }












var pkg = {
  name: "@emotion/react",
  version: "11.4.0",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.cjs.js": "./dist/emotion-react.browser.cjs.js",
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  types: "types/index.d.ts",
  files: ["src", "dist", "jsx-runtime", "jsx-dev-runtime", "isolated-hoist-non-react-statics-do-not-use-this-in-your-code", "types/*.d.ts", "macro.js", "macro.d.ts", "macro.js.flow"],
  sideEffects: false,
  author: "mitchellhamilton <mitchell@mitchellhamilton.me>",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.13.10",
    "@emotion/cache": "^11.4.0",
    "@emotion/serialize": "^1.0.2",
    "@emotion/sheet": "^1.0.1",
    "@emotion/utils": "^1.0.0",
    "@emotion/weak-memoize": "^0.2.5",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    "@babel/core": "^7.0.0",
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@babel/core": {
      optional: true
    },
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@babel/core": "^7.13.10",
    "@emotion/css": "11.1.3",
    "@emotion/css-prettifier": "1.0.0",
    "@emotion/server": "11.4.0",
    "@emotion/styled": "11.3.0",
    "@types/react": "^16.9.11",
    dtslint: "^0.3.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: ["./index.js", "./jsx-runtime.js", "./jsx-dev-runtime.js", "./isolated-hoist-non-react-statics-do-not-use-this-in-your-code.js"],
    umdName: "emotionReact"
  }
};

var emotion_react_browser_esm_jsx = function jsx(type, props) {
  var args = arguments;

  if (props == null || !emotion_element_a8309070_browser_esm_hasOwnProperty.call(props, 'css')) {
    // $FlowFixMe
    return compat_module["createElement"].apply(undefined, args);
  }

  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion;
  createElementArgArray[1] = createEmotionProps(type, props);

  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  } // $FlowFixMe


  return compat_module["createElement"].apply(null, createElementArgArray);
};

var warnedAboutCssPropForGlobal = false; // maintain place over rerenders.
// initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
// initial client-side render from SSR, use place of hydrating tag

var Global = /* #__PURE__ */emotion_element_a8309070_browser_esm_withEmotionCache(function (props, cache) {
  if (false) {}

  var styles = props.styles;
  var serialized = emotion_serialize_browser_esm_serializeStyles([styles], undefined, typeof styles === 'function' || Array.isArray(styles) ? Object(compat_module["useContext"])(ThemeContext) : undefined); // but it is based on a constant that will never change at runtime
  // it's effectively like having two implementations and switching them out
  // so it's not actually breaking anything

  var sheetRef = Object(compat_module["useRef"])();
  Object(compat_module["useLayoutEffect"])(function () {
    var key = cache.key + "-global";
    var sheet = new StyleSheet({
      key: key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false; // $FlowFixMe

    var node = document.querySelector("style[data-emotion=\"" + key + " " + serialized.name + "\"]");

    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }

    if (node !== null) {
      rehydrating = true; // clear the hash so this node won't be recognizable as rehydratable by other <Global/>s

      node.setAttribute('data-emotion', key);
      sheet.hydrate([node]);
    }

    sheetRef.current = [sheet, rehydrating];
    return function () {
      sheet.flush();
    };
  }, [cache]);
  Object(compat_module["useLayoutEffect"])(function () {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0],
        rehydrating = sheetRefCurrent[1];

    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }

    if (serialized.next !== undefined) {
      // insert keyframes
      insertStyles(cache, serialized.next, true);
    }

    if (sheet.tags.length) {
      // if this doesn't exist then it will be null so the style element will be appended
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }

    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});

if (false) {}

function emotion_react_browser_esm_css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return emotion_serialize_browser_esm_serializeStyles(args);
}

var keyframes = function keyframes() {
  var insertable = emotion_react_browser_esm_css.apply(void 0, arguments);
  var name = "animation-" + insertable.name; // $FlowFixMe

  return {
    name: name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};

var classnames = function classnames(args) {
  var len = args.length;
  var i = 0;
  var cls = '';

  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;

    switch (emotion_react_browser_esm_typeof(arg)) {
      case 'boolean':
        break;

      case 'object':
        {
          if (Array.isArray(arg)) {
            toAdd = classnames(arg);
          } else {
            if (false) {}

            toAdd = '';

            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += ' ');
                toAdd += k;
              }
            }
          }

          break;
        }

      default:
        {
          toAdd = arg;
        }
    }

    if (toAdd) {
      cls && (cls += ' ');
      cls += toAdd;
    }
  }

  return cls;
};

function merge(registered, css, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);

  if (registeredStyles.length < 2) {
    return className;
  }

  return rawClassName + css(registeredStyles);
}

var ClassNames = /* #__PURE__ */emotion_element_a8309070_browser_esm_withEmotionCache(function (props, cache) {
  var hasRendered = false;

  var css = function css() {
    if (hasRendered && "production" !== 'production') {
      throw new Error('css can only be used during render');
    }

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var serialized = emotion_serialize_browser_esm_serializeStyles(args, cache.registered);
    {
      insertStyles(cache, serialized, false);
    }
    return cache.key + "-" + serialized.name;
  };

  var cx = function cx() {
    if (hasRendered && "production" !== 'production') {
      throw new Error('cx can only be used during render');
    }

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return merge(cache.registered, css, classnames(args));
  };

  var content = {
    css: css,
    cx: cx,
    theme: Object(compat_module["useContext"])(ThemeContext)
  };
  var ele = props.children(content);
  hasRendered = true;
  return ele;
});

if (false) {}

if (false) { var globalKey, globalContext, isJest, emotion_react_browser_esm_isBrowser; }


// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function typeof_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    typeof_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    typeof_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return typeof_typeof(obj);
}
// EXTERNAL MODULE: ./node_modules/react-input-autosize/lib/AutosizeInput.js
var AutosizeInput = __webpack_require__(9);
var AutosizeInput_default = /*#__PURE__*/__webpack_require__.n(AutosizeInput);

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function classCallCheck_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function createClass_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function createClass_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) createClass_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) createClass_defineProperties(Constructor, staticProps);
  return Constructor;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function setPrototypeOf_setPrototypeOf(o, p) {
  setPrototypeOf_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return setPrototypeOf_setPrototypeOf(o, p);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js

function inherits_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf_setPrototypeOf(subClass, superClass);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function defineProperty_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// CONCATENATED MODULE: ./node_modules/react-select/dist/index-4bd03571.esm.js
function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }














function index_4bd03571_esm_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        index_4bd03571_esm_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function index_4bd03571_esm_getPrototypeOf(o) {
  index_4bd03571_esm_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return index_4bd03571_esm_getPrototypeOf(o);
}

function index_4bd03571_esm_isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function index_4bd03571_esm_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function index_4bd03571_esm_possibleConstructorReturn(self, call) {
  if (call && (_typeof2(call) === "object" || typeof call === "function")) {
    return call;
  }

  return index_4bd03571_esm_assertThisInitialized(self);
}

function index_4bd03571_esm_createSuper(Derived) {
  var hasNativeReflectConstruct = index_4bd03571_esm_isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = index_4bd03571_esm_getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = index_4bd03571_esm_getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return index_4bd03571_esm_possibleConstructorReturn(this, result);
  };
} // ==============================
// NO OP
// ==============================


var noop = function noop() {}; // Class Name Prefixer
// ==============================

/**
 String representation of component state for styling with class names.

 Expects an array of strings OR a string/object pair:
 - className(['comp', 'comp-arg', 'comp-arg-2'])
   @returns 'react-select__comp react-select__comp-arg react-select__comp-arg-2'
 - className('comp', { some: true, state: false })
   @returns 'react-select__comp react-select__comp--some'
*/


function applyPrefixToName(prefix, name) {
  if (!name) {
    return prefix;
  } else if (name[0] === '-') {
    return prefix + name;
  } else {
    return prefix + '__' + name;
  }
}

function classNames(prefix, state, className) {
  var arr = [className];

  if (state && prefix) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("".concat(applyPrefixToName(prefix, key)));
      }
    }
  }

  return arr.filter(function (i) {
    return i;
  }).map(function (i) {
    return String(i).trim();
  }).join(' ');
} // ==============================
// Clean Value
// ==============================


var index_4bd03571_esm_cleanValue = function cleanValue(value) {
  if (Array.isArray(value)) return value.filter(Boolean);
  if (typeof_typeof(value) === 'object' && value !== null) return [value];
  return [];
}; // ==============================
// Clean Common Props
// ==============================


var index_4bd03571_esm_cleanCommonProps = function cleanCommonProps(props) {
  //className
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;

  var innerProps = _objectWithoutProperties(props, ["className", "clearValue", "cx", "getStyles", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"]);

  return _objectSpread2({}, innerProps);
}; // ==============================
// Handle Input Change
// ==============================


function handleInputChange(inputValue, actionMeta, onInputChange) {
  if (onInputChange) {
    var newValue = onInputChange(inputValue, actionMeta);
    if (typeof newValue === 'string') return newValue;
  }

  return inputValue;
} // ==============================
// Scroll Helpers
// ==============================


function isDocumentElement(el) {
  return [document.documentElement, document.body, window].indexOf(el) > -1;
} // Normalized Scroll Top
// ------------------------------


function getScrollTop(el) {
  if (isDocumentElement(el)) {
    return window.pageYOffset;
  }

  return el.scrollTop;
}

function scrollTo(el, top) {
  // with a scroll distance, we perform scroll on the element
  if (isDocumentElement(el)) {
    window.scrollTo(0, top);
    return;
  }

  el.scrollTop = top;
} // Get Scroll Parent
// ------------------------------


function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === 'absolute';
  var overflowRx = /(auto|scroll)/;
  var docEl = document.documentElement; // suck it, flow...

  if (style.position === 'fixed') return docEl;

  for (var parent = element; parent = parent.parentElement;) {
    style = getComputedStyle(parent);

    if (excludeStaticParent && style.position === 'static') {
      continue;
    }

    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }

  return docEl;
} // Animated Scroll To
// ------------------------------

/**
  @param t: time (elapsed)
  @param b: initial value
  @param c: amount of change
  @param d: duration
*/


function easeOutCubic(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
}

function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;
  var start = getScrollTop(element);
  var change = to - start;
  var increment = 10;
  var currentTime = 0;

  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);

    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }

  animateScroll();
} // Scroll Into View
// ------------------------------


function index_4bd03571_esm_scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;

  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
} // ==============================
// Get bounding client object
// ==============================
// cannot get keys using array notation with DOMRect


function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
} // Touch Capability Detector
// ==============================


function isTouchCapable() {
  try {
    document.createEvent('TouchEvent');
    return true;
  } catch (e) {
    return false;
  }
} // ==============================
// Mobile Device Detector
// ==============================


function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e) {
    return false;
  }
} // ==============================
// Passive Event Detector
// ==============================
// https://github.com/rafgraph/detect-it/blob/main/src/index.ts#L19-L36


var passiveOptionAccessed = false;
var index_4bd03571_esm_options = {
  get passive() {
    return passiveOptionAccessed = true;
  }

}; // check for SSR

var index_4bd03571_esm_w = typeof window !== 'undefined' ? window : {};

if (index_4bd03571_esm_w.addEventListener && index_4bd03571_esm_w.removeEventListener) {
  index_4bd03571_esm_w.addEventListener('p', noop, index_4bd03571_esm_options);
  index_4bd03571_esm_w.removeEventListener('p', noop, false);
}

var supportsPassiveEvents = passiveOptionAccessed;

function getMenuPlacement(_ref) {
  var maxHeight = _ref.maxHeight,
      menuEl = _ref.menuEl,
      minHeight = _ref.minHeight,
      placement = _ref.placement,
      shouldScroll = _ref.shouldScroll,
      isFixedPosition = _ref.isFixedPosition,
      theme = _ref.theme;
  var spacing = theme.spacing;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: 'bottom',
    maxHeight: maxHeight
  }; // something went wrong, return default state

  if (!menuEl || !menuEl.offsetParent) return defaultState; // we can't trust `scrollParent.scrollHeight` --> it may increase when
  // the menu is rendered

  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(),
      scrollHeight = _scrollParent$getBoun.height;

  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(),
      menuBottom = _menuEl$getBoundingCl.bottom,
      menuHeight = _menuEl$getBoundingCl.height,
      menuTop = _menuEl$getBoundingCl.top;

  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(),
      containerTop = _menuEl$offsetParent$.top;

  var viewHeight = window.innerHeight;
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;

  switch (placement) {
    case 'auto':
    case 'bottom':
      // 1: the menu will fit, do nothing
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: 'bottom',
          maxHeight: maxHeight
        };
      } // 2: the menu will fit, if scrolled


      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }

        return {
          placement: 'bottom',
          maxHeight: maxHeight
        };
      } // 3: the menu will fit, if constrained


      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        } // we want to provide as much of the menu as possible to the user,
        // so give them whatever is available below rather than the minHeight.


        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: 'bottom',
          maxHeight: constrainedHeight
        };
      } // 4. Forked beviour when there isn't enough space below
      // AUTO: flip the menu, render above


      if (placement === 'auto' || isFixedPosition) {
        // may need to be constrained after flipping
        var _constrainedHeight = maxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;

        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - spacing.controlHeight, maxHeight);
        }

        return {
          placement: 'top',
          maxHeight: _constrainedHeight
        };
      } // BOTTOM: allow browser to increase scrollable area and immediately set scroll


      if (placement === 'bottom') {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }

        return {
          placement: 'bottom',
          maxHeight: maxHeight
        };
      }

      break;

    case 'top':
      // 1: the menu will fit, do nothing
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: 'top',
          maxHeight: maxHeight
        };
      } // 2: the menu will fit, if scrolled


      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }

        return {
          placement: 'top',
          maxHeight: maxHeight
        };
      } // 3: the menu will fit, if constrained


      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = maxHeight; // we want to provide as much of the menu as possible to the user,
        // so give them whatever is available below rather than the minHeight.

        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }

        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }

        return {
          placement: 'top',
          maxHeight: _constrainedHeight2
        };
      } // 4. not enough space, the browser WILL NOT increase scrollable area when
      // absolutely positioned element rendered above the viewport (only below).
      // Flip the menu, render below


      return {
        placement: 'bottom',
        maxHeight: maxHeight
      };

    default:
      throw new Error("Invalid placement provided \"".concat(placement, "\"."));
  } // fulfil contract with flow: implicit return value of undefined


  return defaultState;
} // Menu Component
// ------------------------------


function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: 'top',
    top: 'bottom'
  };
  return placement ? placementToCSSProp[placement] : 'bottom';
}

var coercePlacement = function coercePlacement(p) {
  return p === 'auto' ? 'bottom' : p;
};

var index_4bd03571_esm_menuCSS = function menuCSS(_ref2) {
  var _ref3;

  var placement = _ref2.placement,
      _ref2$theme = _ref2.theme,
      borderRadius = _ref2$theme.borderRadius,
      spacing = _ref2$theme.spacing,
      colors = _ref2$theme.colors;
  return _ref3 = {
    label: 'menu'
  }, defineProperty_defineProperty(_ref3, alignToControl(placement), '100%'), defineProperty_defineProperty(_ref3, "backgroundColor", colors.neutral0), defineProperty_defineProperty(_ref3, "borderRadius", borderRadius), defineProperty_defineProperty(_ref3, "boxShadow", '0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)'), defineProperty_defineProperty(_ref3, "marginBottom", spacing.menuGutter), defineProperty_defineProperty(_ref3, "marginTop", spacing.menuGutter), defineProperty_defineProperty(_ref3, "position", 'absolute'), defineProperty_defineProperty(_ref3, "width", '100%'), defineProperty_defineProperty(_ref3, "zIndex", 1), _ref3;
};

var PortalPlacementContext = /*#__PURE__*/Object(compat_module["createContext"])({
  getPortalPlacement: null
}); // NOTE: internal only

var index_4bd03571_esm_MenuPlacer = /*#__PURE__*/function (_Component) {
  inherits_inherits(MenuPlacer, _Component);

  var _super = index_4bd03571_esm_createSuper(MenuPlacer);

  function MenuPlacer() {
    var _this;

    classCallCheck_classCallCheck(this, MenuPlacer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      maxHeight: _this.props.maxMenuHeight,
      placement: null
    };

    _this.getPlacement = function (ref) {
      var _this$props = _this.props,
          minMenuHeight = _this$props.minMenuHeight,
          maxMenuHeight = _this$props.maxMenuHeight,
          menuPlacement = _this$props.menuPlacement,
          menuPosition = _this$props.menuPosition,
          menuShouldScrollIntoView = _this$props.menuShouldScrollIntoView,
          theme = _this$props.theme;
      if (!ref) return; // DO NOT scroll if position is fixed

      var isFixedPosition = menuPosition === 'fixed';
      var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
      var state = getMenuPlacement({
        maxHeight: maxMenuHeight,
        menuEl: ref,
        minHeight: minMenuHeight,
        placement: menuPlacement,
        shouldScroll: shouldScroll,
        isFixedPosition: isFixedPosition,
        theme: theme
      });
      var getPortalPlacement = _this.context.getPortalPlacement;
      if (getPortalPlacement) getPortalPlacement(state);

      _this.setState(state);
    };

    _this.getUpdatedProps = function () {
      var menuPlacement = _this.props.menuPlacement;
      var placement = _this.state.placement || coercePlacement(menuPlacement);
      return _objectSpread2(_objectSpread2({}, _this.props), {}, {
        placement: placement,
        maxHeight: _this.state.maxHeight
      });
    };

    return _this;
  }

  createClass_createClass(MenuPlacer, [{
    key: "render",
    value: function render() {
      var children = this.props.children;
      return children({
        ref: this.getPlacement,
        placerProps: this.getUpdatedProps()
      });
    }
  }]);

  return MenuPlacer;
}(compat_module["Component"]);

index_4bd03571_esm_MenuPlacer.contextType = PortalPlacementContext;

var index_4bd03571_esm_Menu = function Menu(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerRef = props.innerRef,
      innerProps = props.innerProps;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('menu', props),
    className: cx({
      menu: true
    }, className),
    ref: innerRef
  }, innerProps), children);
}; // Menu List
// ==============================


var menuListCSS = function menuListCSS(_ref4) {
  var maxHeight = _ref4.maxHeight,
      baseUnit = _ref4.theme.spacing.baseUnit;
  return {
    maxHeight: maxHeight,
    overflowY: 'auto',
    paddingBottom: baseUnit,
    paddingTop: baseUnit,
    position: 'relative',
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: 'touch'
  };
};

var index_4bd03571_esm_MenuList = function MenuList(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps,
      innerRef = props.innerRef,
      isMulti = props.isMulti;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('menuList', props),
    className: cx({
      'menu-list': true,
      'menu-list--is-multi': isMulti
    }, className),
    ref: innerRef
  }, innerProps), children);
}; // ==============================
// Menu Notices
// ==============================


var noticeCSS = function noticeCSS(_ref5) {
  var _ref5$theme = _ref5.theme,
      baseUnit = _ref5$theme.spacing.baseUnit,
      colors = _ref5$theme.colors;
  return {
    color: colors.neutral40,
    padding: "".concat(baseUnit * 2, "px ").concat(baseUnit * 3, "px"),
    textAlign: 'center'
  };
};

var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;

var index_4bd03571_esm_NoOptionsMessage = function NoOptionsMessage(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('noOptionsMessage', props),
    className: cx({
      'menu-notice': true,
      'menu-notice--no-options': true
    }, className)
  }, innerProps), children);
};

index_4bd03571_esm_NoOptionsMessage.defaultProps = {
  children: 'No options'
};

var index_4bd03571_esm_LoadingMessage = function LoadingMessage(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('loadingMessage', props),
    className: cx({
      'menu-notice': true,
      'menu-notice--loading': true
    }, className)
  }, innerProps), children);
};

index_4bd03571_esm_LoadingMessage.defaultProps = {
  children: 'Loading...'
}; // ==============================
// Menu Portal
// ==============================

var menuPortalCSS = function menuPortalCSS(_ref6) {
  var rect = _ref6.rect,
      offset = _ref6.offset,
      position = _ref6.position;
  return {
    left: rect.left,
    position: position,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
};

var index_4bd03571_esm_MenuPortal = /*#__PURE__*/function (_Component2) {
  inherits_inherits(MenuPortal, _Component2);

  var _super2 = index_4bd03571_esm_createSuper(MenuPortal);

  function MenuPortal() {
    var _this2;

    classCallCheck_classCallCheck(this, MenuPortal);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _this2.state = {
      placement: null
    };

    _this2.getPortalPlacement = function (_ref7) {
      var placement = _ref7.placement;
      var initialPlacement = coercePlacement(_this2.props.menuPlacement); // avoid re-renders if the placement has not changed

      if (placement !== initialPlacement) {
        _this2.setState({
          placement: placement
        });
      }
    };

    return _this2;
  }

  createClass_createClass(MenuPortal, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          appendTo = _this$props2.appendTo,
          children = _this$props2.children,
          className = _this$props2.className,
          controlElement = _this$props2.controlElement,
          cx = _this$props2.cx,
          innerProps = _this$props2.innerProps,
          menuPlacement = _this$props2.menuPlacement,
          position = _this$props2.menuPosition,
          getStyles = _this$props2.getStyles;
      var isFixed = position === 'fixed'; // bail early if required elements aren't present

      if (!appendTo && !isFixed || !controlElement) {
        return null;
      }

      var placement = this.state.placement || coercePlacement(menuPlacement);
      var rect = getBoundingClientObj(controlElement);
      var scrollDistance = isFixed ? 0 : window.pageYOffset;
      var offset = rect[placement] + scrollDistance;
      var state = {
        offset: offset,
        position: position,
        rect: rect
      }; // same wrapper element whether fixed or portalled

      var menuWrapper = emotion_react_browser_esm_jsx("div", _extends({
        css: getStyles('menuPortal', state),
        className: cx({
          'menu-portal': true
        }, className)
      }, innerProps), children);
      return emotion_react_browser_esm_jsx(PortalPlacementContext.Provider, {
        value: {
          getPortalPlacement: this.getPortalPlacement
        }
      }, appendTo ? /*#__PURE__*/Object(compat_module["createPortal"])(menuWrapper, appendTo) : menuWrapper);
    }
  }]);

  return MenuPortal;
}(compat_module["Component"]);

var containerCSS = function containerCSS(_ref) {
  var isDisabled = _ref.isDisabled,
      isRtl = _ref.isRtl;
  return {
    label: 'container',
    direction: isRtl ? 'rtl' : null,
    pointerEvents: isDisabled ? 'none' : null,
    // cancel mouse events when disabled
    position: 'relative'
  };
};

var index_4bd03571_esm_SelectContainer = function SelectContainer(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps,
      isDisabled = props.isDisabled,
      isRtl = props.isRtl;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('container', props),
    className: cx({
      '--is-disabled': isDisabled,
      '--is-rtl': isRtl
    }, className)
  }, innerProps), children);
}; // ==============================
// Value Container
// ==============================


var valueContainerCSS = function valueContainerCSS(_ref2) {
  var spacing = _ref2.theme.spacing;
  return {
    alignItems: 'center',
    display: 'flex',
    flex: 1,
    flexWrap: 'wrap',
    padding: "".concat(spacing.baseUnit / 2, "px ").concat(spacing.baseUnit * 2, "px"),
    WebkitOverflowScrolling: 'touch',
    position: 'relative',
    overflow: 'hidden'
  };
};

var index_4bd03571_esm_ValueContainer = function ValueContainer(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      innerProps = props.innerProps,
      isMulti = props.isMulti,
      getStyles = props.getStyles,
      hasValue = props.hasValue;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('valueContainer', props),
    className: cx({
      'value-container': true,
      'value-container--is-multi': isMulti,
      'value-container--has-value': hasValue
    }, className)
  }, innerProps), children);
}; // ==============================
// Indicator Container
// ==============================


var indicatorsContainerCSS = function indicatorsContainerCSS() {
  return {
    alignItems: 'center',
    alignSelf: 'stretch',
    display: 'flex',
    flexShrink: 0
  };
};

var index_4bd03571_esm_IndicatorsContainer = function IndicatorsContainer(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      innerProps = props.innerProps,
      getStyles = props.getStyles;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('indicatorsContainer', props),
    className: cx({
      indicators: true
    }, className)
  }, innerProps), children);
};

var _templateObject;

function _EMOTION_STRINGIFIED_CSS_ERROR__() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}

var index_4bd03571_esm_ref2 =  true ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : undefined; // ==============================
// Dropdown & Clear Icons
// ==============================


var index_4bd03571_esm_Svg = function Svg(_ref) {
  var size = _ref.size,
      props = _objectWithoutProperties(_ref, ["size"]);

  return emotion_react_browser_esm_jsx("svg", _extends({
    height: size,
    width: size,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: index_4bd03571_esm_ref2
  }, props));
};

var index_4bd03571_esm_CrossIcon = function CrossIcon(props) {
  return emotion_react_browser_esm_jsx(index_4bd03571_esm_Svg, _extends({
    size: 20
  }, props), emotion_react_browser_esm_jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};

var index_4bd03571_esm_DownChevron = function DownChevron(props) {
  return emotion_react_browser_esm_jsx(index_4bd03571_esm_Svg, _extends({
    size: 20
  }, props), emotion_react_browser_esm_jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}; // ==============================
// Dropdown & Clear Buttons
// ==============================


var baseCSS = function baseCSS(_ref3) {
  var isFocused = _ref3.isFocused,
      _ref3$theme = _ref3.theme,
      baseUnit = _ref3$theme.spacing.baseUnit,
      colors = _ref3$theme.colors;
  return {
    label: 'indicatorContainer',
    color: isFocused ? colors.neutral60 : colors.neutral20,
    display: 'flex',
    padding: baseUnit * 2,
    transition: 'color 150ms',
    ':hover': {
      color: isFocused ? colors.neutral80 : colors.neutral40
    }
  };
};

var dropdownIndicatorCSS = baseCSS;

var index_4bd03571_esm_DropdownIndicator = function DropdownIndicator(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('dropdownIndicator', props),
    className: cx({
      indicator: true,
      'dropdown-indicator': true
    }, className)
  }, innerProps), children || emotion_react_browser_esm_jsx(index_4bd03571_esm_DownChevron, null));
};

var clearIndicatorCSS = baseCSS;

var index_4bd03571_esm_ClearIndicator = function ClearIndicator(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('clearIndicator', props),
    className: cx({
      indicator: true,
      'clear-indicator': true
    }, className)
  }, innerProps), children || emotion_react_browser_esm_jsx(index_4bd03571_esm_CrossIcon, null));
}; // ==============================
// Separator
// ==============================


var indicatorSeparatorCSS = function indicatorSeparatorCSS(_ref4) {
  var isDisabled = _ref4.isDisabled,
      _ref4$theme = _ref4.theme,
      baseUnit = _ref4$theme.spacing.baseUnit,
      colors = _ref4$theme.colors;
  return {
    label: 'indicatorSeparator',
    alignSelf: 'stretch',
    backgroundColor: isDisabled ? colors.neutral10 : colors.neutral20,
    marginBottom: baseUnit * 2,
    marginTop: baseUnit * 2,
    width: 1
  };
};

var index_4bd03571_esm_IndicatorSeparator = function IndicatorSeparator(props) {
  var className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return emotion_react_browser_esm_jsx("span", _extends({}, innerProps, {
    css: getStyles('indicatorSeparator', props),
    className: cx({
      'indicator-separator': true
    }, className)
  }));
}; // ==============================
// Loading
// ==============================


var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));

var loadingIndicatorCSS = function loadingIndicatorCSS(_ref5) {
  var isFocused = _ref5.isFocused,
      size = _ref5.size,
      _ref5$theme = _ref5.theme,
      colors = _ref5$theme.colors,
      baseUnit = _ref5$theme.spacing.baseUnit;
  return {
    label: 'loadingIndicator',
    color: isFocused ? colors.neutral60 : colors.neutral20,
    display: 'flex',
    padding: baseUnit * 2,
    transition: 'color 150ms',
    alignSelf: 'center',
    fontSize: size,
    lineHeight: 1,
    marginRight: size,
    textAlign: 'center',
    verticalAlign: 'middle'
  };
};

var index_4bd03571_esm_LoadingDot = function LoadingDot(_ref6) {
  var delay = _ref6.delay,
      offset = _ref6.offset;
  return emotion_react_browser_esm_jsx("span", {
    css: /*#__PURE__*/emotion_react_browser_esm_css({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay, "ms infinite;"),
      backgroundColor: 'currentColor',
      borderRadius: '1em',
      display: 'inline-block',
      marginLeft: offset ? '1em' : null,
      height: '1em',
      verticalAlign: 'top',
      width: '1em'
    },  true ? "" : undefined,  true ? "" : undefined)
  });
};

var index_4bd03571_esm_LoadingIndicator = function LoadingIndicator(props) {
  var className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps,
      isRtl = props.isRtl;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('loadingIndicator', props),
    className: cx({
      indicator: true,
      'loading-indicator': true
    }, className)
  }, innerProps), emotion_react_browser_esm_jsx(index_4bd03571_esm_LoadingDot, {
    delay: 0,
    offset: isRtl
  }), emotion_react_browser_esm_jsx(index_4bd03571_esm_LoadingDot, {
    delay: 160,
    offset: true
  }), emotion_react_browser_esm_jsx(index_4bd03571_esm_LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};

index_4bd03571_esm_LoadingIndicator.defaultProps = {
  size: 4
};

var index_4bd03571_esm_css = function css(_ref) {
  var isDisabled = _ref.isDisabled,
      isFocused = _ref.isFocused,
      _ref$theme = _ref.theme,
      colors = _ref$theme.colors,
      borderRadius = _ref$theme.borderRadius,
      spacing = _ref$theme.spacing;
  return {
    label: 'control',
    alignItems: 'center',
    backgroundColor: isDisabled ? colors.neutral5 : colors.neutral0,
    borderColor: isDisabled ? colors.neutral10 : isFocused ? colors.primary : colors.neutral20,
    borderRadius: borderRadius,
    borderStyle: 'solid',
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors.primary) : null,
    cursor: 'default',
    display: 'flex',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    minHeight: spacing.controlHeight,
    outline: '0 !important',
    position: 'relative',
    transition: 'all 100ms',
    '&:hover': {
      borderColor: isFocused ? colors.primary : colors.neutral30
    }
  };
};

var index_4bd03571_esm_Control = function Control(props) {
  var children = props.children,
      cx = props.cx,
      getStyles = props.getStyles,
      className = props.className,
      isDisabled = props.isDisabled,
      isFocused = props.isFocused,
      innerRef = props.innerRef,
      innerProps = props.innerProps,
      menuIsOpen = props.menuIsOpen;
  return emotion_react_browser_esm_jsx("div", _extends({
    ref: innerRef,
    css: getStyles('control', props),
    className: cx({
      control: true,
      'control--is-disabled': isDisabled,
      'control--is-focused': isFocused,
      'control--menu-is-open': menuIsOpen
    }, className)
  }, innerProps), children);
};

var groupCSS = function groupCSS(_ref) {
  var spacing = _ref.theme.spacing;
  return {
    paddingBottom: spacing.baseUnit * 2,
    paddingTop: spacing.baseUnit * 2
  };
};

var index_4bd03571_esm_Group = function Group(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      Heading = props.Heading,
      headingProps = props.headingProps,
      innerProps = props.innerProps,
      label = props.label,
      theme = props.theme,
      selectProps = props.selectProps;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('group', props),
    className: cx({
      group: true
    }, className)
  }, innerProps), emotion_react_browser_esm_jsx(Heading, _extends({}, headingProps, {
    selectProps: selectProps,
    theme: theme,
    getStyles: getStyles,
    cx: cx
  }), label), emotion_react_browser_esm_jsx("div", null, children));
};

var groupHeadingCSS = function groupHeadingCSS(_ref2) {
  var spacing = _ref2.theme.spacing;
  return {
    label: 'group',
    color: '#999',
    cursor: 'default',
    display: 'block',
    fontSize: '75%',
    fontWeight: '500',
    marginBottom: '0.25em',
    paddingLeft: spacing.baseUnit * 3,
    paddingRight: spacing.baseUnit * 3,
    textTransform: 'uppercase'
  };
};

var index_4bd03571_esm_GroupHeading = function GroupHeading(props) {
  var getStyles = props.getStyles,
      cx = props.cx,
      className = props.className;

  var _cleanCommonProps = index_4bd03571_esm_cleanCommonProps(props);

  _cleanCommonProps.data;

  var innerProps = _objectWithoutProperties(_cleanCommonProps, ["data"]);

  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('groupHeading', props),
    className: cx({
      'group-heading': true
    }, className)
  }, innerProps));
};

var inputCSS = function inputCSS(_ref) {
  var isDisabled = _ref.isDisabled,
      _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
  return {
    margin: spacing.baseUnit / 2,
    paddingBottom: spacing.baseUnit / 2,
    paddingTop: spacing.baseUnit / 2,
    visibility: isDisabled ? 'hidden' : 'visible',
    color: colors.neutral80
  };
};

var inputStyle = function inputStyle(isHidden) {
  return {
    label: 'input',
    background: 0,
    border: 0,
    fontSize: 'inherit',
    opacity: isHidden ? 0 : 1,
    outline: 0,
    padding: 0,
    color: 'inherit'
  };
};

var index_4bd03571_esm_Input = function Input(props) {
  var className = props.className,
      cx = props.cx,
      getStyles = props.getStyles;

  var _cleanCommonProps = index_4bd03571_esm_cleanCommonProps(props),
      innerRef = _cleanCommonProps.innerRef,
      isDisabled = _cleanCommonProps.isDisabled,
      isHidden = _cleanCommonProps.isHidden,
      innerProps = _objectWithoutProperties(_cleanCommonProps, ["innerRef", "isDisabled", "isHidden"]);

  return emotion_react_browser_esm_jsx("div", {
    css: getStyles('input', props)
  }, emotion_react_browser_esm_jsx(AutosizeInput_default.a, _extends({
    className: cx({
      input: true
    }, className),
    inputRef: innerRef,
    inputStyle: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
};

var multiValueCSS = function multiValueCSS(_ref) {
  var _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      borderRadius = _ref$theme.borderRadius,
      colors = _ref$theme.colors;
  return {
    label: 'multiValue',
    backgroundColor: colors.neutral10,
    borderRadius: borderRadius / 2,
    display: 'flex',
    margin: spacing.baseUnit / 2,
    minWidth: 0 // resolves flex/text-overflow bug

  };
};

var multiValueLabelCSS = function multiValueLabelCSS(_ref2) {
  var _ref2$theme = _ref2.theme,
      borderRadius = _ref2$theme.borderRadius,
      colors = _ref2$theme.colors,
      cropWithEllipsis = _ref2.cropWithEllipsis;
  return {
    borderRadius: borderRadius / 2,
    color: colors.neutral80,
    fontSize: '85%',
    overflow: 'hidden',
    padding: 3,
    paddingLeft: 6,
    textOverflow: cropWithEllipsis ? 'ellipsis' : null,
    whiteSpace: 'nowrap'
  };
};

var multiValueRemoveCSS = function multiValueRemoveCSS(_ref3) {
  var _ref3$theme = _ref3.theme,
      spacing = _ref3$theme.spacing,
      borderRadius = _ref3$theme.borderRadius,
      colors = _ref3$theme.colors,
      isFocused = _ref3.isFocused;
  return {
    alignItems: 'center',
    borderRadius: borderRadius / 2,
    backgroundColor: isFocused && colors.dangerLight,
    display: 'flex',
    paddingLeft: spacing.baseUnit,
    paddingRight: spacing.baseUnit,
    ':hover': {
      backgroundColor: colors.dangerLight,
      color: colors.danger
    }
  };
};

var index_4bd03571_esm_MultiValueGeneric = function MultiValueGeneric(_ref4) {
  var children = _ref4.children,
      innerProps = _ref4.innerProps;
  return emotion_react_browser_esm_jsx("div", innerProps, children);
};

var index_4bd03571_esm_MultiValueContainer = index_4bd03571_esm_MultiValueGeneric;
var index_4bd03571_esm_MultiValueLabel = index_4bd03571_esm_MultiValueGeneric;

function index_4bd03571_esm_MultiValueRemove(_ref5) {
  var children = _ref5.children,
      innerProps = _ref5.innerProps;
  return emotion_react_browser_esm_jsx("div", innerProps, children || emotion_react_browser_esm_jsx(index_4bd03571_esm_CrossIcon, {
    size: 14
  }));
}

var index_4bd03571_esm_MultiValue = function MultiValue(props) {
  var children = props.children,
      className = props.className,
      components = props.components,
      cx = props.cx,
      data = props.data,
      getStyles = props.getStyles,
      innerProps = props.innerProps,
      isDisabled = props.isDisabled,
      removeProps = props.removeProps,
      selectProps = props.selectProps;
  var Container = components.Container,
      Label = components.Label,
      Remove = components.Remove;
  return emotion_react_browser_esm_jsx(ClassNames, null, function (_ref6) {
    var css = _ref6.css,
        emotionCx = _ref6.cx;
    return emotion_react_browser_esm_jsx(Container, {
      data: data,
      innerProps: _objectSpread2({
        className: emotionCx(css(getStyles('multiValue', props)), cx({
          'multi-value': true,
          'multi-value--is-disabled': isDisabled
        }, className))
      }, innerProps),
      selectProps: selectProps
    }, emotion_react_browser_esm_jsx(Label, {
      data: data,
      innerProps: {
        className: emotionCx(css(getStyles('multiValueLabel', props)), cx({
          'multi-value__label': true
        }, className))
      },
      selectProps: selectProps
    }, children), emotion_react_browser_esm_jsx(Remove, {
      data: data,
      innerProps: _objectSpread2({
        className: emotionCx(css(getStyles('multiValueRemove', props)), cx({
          'multi-value__remove': true
        }, className))
      }, removeProps),
      selectProps: selectProps
    }));
  });
};

index_4bd03571_esm_MultiValue.defaultProps = {
  cropWithEllipsis: true
};

var optionCSS = function optionCSS(_ref) {
  var isDisabled = _ref.isDisabled,
      isFocused = _ref.isFocused,
      isSelected = _ref.isSelected,
      _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
  return {
    label: 'option',
    backgroundColor: isSelected ? colors.primary : isFocused ? colors.primary25 : 'transparent',
    color: isDisabled ? colors.neutral20 : isSelected ? colors.neutral0 : 'inherit',
    cursor: 'default',
    display: 'block',
    fontSize: 'inherit',
    padding: "".concat(spacing.baseUnit * 2, "px ").concat(spacing.baseUnit * 3, "px"),
    width: '100%',
    userSelect: 'none',
    WebkitTapHighlightColor: 'rgba(0, 0, 0, 0)',
    // provide some affordance on touch devices
    ':active': {
      backgroundColor: !isDisabled && (isSelected ? colors.primary : colors.primary50)
    }
  };
};

var index_4bd03571_esm_Option = function Option(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      isDisabled = props.isDisabled,
      isFocused = props.isFocused,
      isSelected = props.isSelected,
      innerRef = props.innerRef,
      innerProps = props.innerProps;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('option', props),
    className: cx({
      option: true,
      'option--is-disabled': isDisabled,
      'option--is-focused': isFocused,
      'option--is-selected': isSelected
    }, className),
    ref: innerRef
  }, innerProps), children);
};

var placeholderCSS = function placeholderCSS(_ref) {
  var _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
  return {
    label: 'placeholder',
    color: colors.neutral50,
    marginLeft: spacing.baseUnit / 2,
    marginRight: spacing.baseUnit / 2,
    position: 'absolute',
    top: '50%',
    transform: 'translateY(-50%)'
  };
};

var index_4bd03571_esm_Placeholder = function Placeholder(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('placeholder', props),
    className: cx({
      placeholder: true
    }, className)
  }, innerProps), children);
};

var css$1 = function css(_ref) {
  var isDisabled = _ref.isDisabled,
      _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
  return {
    label: 'singleValue',
    color: isDisabled ? colors.neutral40 : colors.neutral80,
    marginLeft: spacing.baseUnit / 2,
    marginRight: spacing.baseUnit / 2,
    maxWidth: "calc(100% - ".concat(spacing.baseUnit * 2, "px)"),
    overflow: 'hidden',
    position: 'absolute',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    top: '50%',
    transform: 'translateY(-50%)'
  };
};

var index_4bd03571_esm_SingleValue = function SingleValue(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      isDisabled = props.isDisabled,
      innerProps = props.innerProps;
  return emotion_react_browser_esm_jsx("div", _extends({
    css: getStyles('singleValue', props),
    className: cx({
      'single-value': true,
      'single-value--is-disabled': isDisabled
    }, className)
  }, innerProps), children);
};

var index_4bd03571_esm_components = {
  ClearIndicator: index_4bd03571_esm_ClearIndicator,
  Control: index_4bd03571_esm_Control,
  DropdownIndicator: index_4bd03571_esm_DropdownIndicator,
  DownChevron: index_4bd03571_esm_DownChevron,
  CrossIcon: index_4bd03571_esm_CrossIcon,
  Group: index_4bd03571_esm_Group,
  GroupHeading: index_4bd03571_esm_GroupHeading,
  IndicatorsContainer: index_4bd03571_esm_IndicatorsContainer,
  IndicatorSeparator: index_4bd03571_esm_IndicatorSeparator,
  Input: index_4bd03571_esm_Input,
  LoadingIndicator: index_4bd03571_esm_LoadingIndicator,
  Menu: index_4bd03571_esm_Menu,
  MenuList: index_4bd03571_esm_MenuList,
  MenuPortal: index_4bd03571_esm_MenuPortal,
  LoadingMessage: index_4bd03571_esm_LoadingMessage,
  NoOptionsMessage: index_4bd03571_esm_NoOptionsMessage,
  MultiValue: index_4bd03571_esm_MultiValue,
  MultiValueContainer: index_4bd03571_esm_MultiValueContainer,
  MultiValueLabel: index_4bd03571_esm_MultiValueLabel,
  MultiValueRemove: index_4bd03571_esm_MultiValueRemove,
  Option: index_4bd03571_esm_Option,
  Placeholder: index_4bd03571_esm_Placeholder,
  SelectContainer: index_4bd03571_esm_SelectContainer,
  SingleValue: index_4bd03571_esm_SingleValue,
  ValueContainer: index_4bd03571_esm_ValueContainer
};

var defaultComponents = function defaultComponents(props) {
  return _objectSpread2(_objectSpread2({}, index_4bd03571_esm_components), props.components);
};


// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
// CONCATENATED MODULE: ./node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === 'number' && value !== value;
};

function memoize_one_esm_isEqual(first, second) {
  if (first === second) {
    return true;
  }

  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }

  return false;
}

function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }

  for (var i = 0; i < newInputs.length; i++) {
    if (!memoize_one_esm_isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }

  return true;
}

function memoizeOne(resultFn, isEqual) {
  if (isEqual === void 0) {
    isEqual = areInputsEqual;
  }

  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;

  function memoized() {
    var newArgs = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }

    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
      return lastResult;
    }

    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }

  return memoized;
}

/* harmony default export */ var memoize_one_esm = (memoizeOne);
// CONCATENATED MODULE: ./node_modules/react-select/dist/Select-dbb12e54.esm.js











function Select_dbb12e54_esm_EMOTION_STRINGIFIED_CSS_ERROR_() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}

var Select_dbb12e54_esm_ref =  true ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : undefined;

var Select_dbb12e54_esm_A11yText = function A11yText(props) {
  return emotion_react_browser_esm_jsx("span", _extends({
    css: Select_dbb12e54_esm_ref
  }, props));
};

var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable,
        isMulti = props.isMulti,
        isDisabled = props.isDisabled,
        tabSelectsValue = props.tabSelectsValue,
        context = props.context;

    switch (context) {
      case 'menu':
        return "Use Up and Down to choose options".concat(isDisabled ? '' : ', press Enter to select the currently focused option', ", press Escape to exit the menu").concat(tabSelectsValue ? ', press Tab to select the option and exit the menu' : '', ".");

      case 'input':
        return "".concat(props['aria-label'] || 'Select', " is focused ").concat(isSearchable ? ',type to refine list' : '', ", press Down to open the menu, ").concat(isMulti ? ' press left to focus selected values' : '');

      case 'value':
        return 'Use left and right to toggle between focused values, press Backspace to remove the currently focused value';

      default:
        return '';
    }
  },
  onChange: function onChange(props) {
    var action = props.action,
        _props$label = props.label,
        label = _props$label === void 0 ? '' : _props$label,
        isDisabled = props.isDisabled;

    switch (action) {
      case 'deselect-option':
      case 'pop-value':
      case 'remove-value':
        return "option ".concat(label, ", deselected.");

      case 'select-option':
        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");

      default:
        return '';
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context,
        _props$focused = props.focused,
        focused = _props$focused === void 0 ? {} : _props$focused,
        options = props.options,
        _props$label2 = props.label,
        label = _props$label2 === void 0 ? '' : _props$label2,
        selectValue = props.selectValue,
        isDisabled = props.isDisabled,
        isSelected = props.isSelected;

    var getArrayIndex = function getArrayIndex(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : '';
    };

    if (context === 'value' && selectValue) {
      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }

    if (context === 'menu') {
      var disabled = isDisabled ? ' disabled' : '';
      var status = "".concat(isSelected ? 'selected' : 'focused').concat(disabled);
      return "option ".concat(label, " ").concat(status, ", ").concat(getArrayIndex(options, focused), ".");
    }

    return '';
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue,
        resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? ' for search term ' + inputValue : '', ".");
  }
};

var Select_dbb12e54_esm_LiveRegion = function LiveRegion(props) {
  var ariaSelection = props.ariaSelection,
      focusedOption = props.focusedOption,
      focusedValue = props.focusedValue,
      focusableOptions = props.focusableOptions,
      isFocused = props.isFocused,
      selectValue = props.selectValue,
      selectProps = props.selectProps;
  var ariaLiveMessages = selectProps.ariaLiveMessages,
      getOptionLabel = selectProps.getOptionLabel,
      inputValue = selectProps.inputValue,
      isMulti = selectProps.isMulti,
      isOptionDisabled = selectProps.isOptionDisabled,
      isSearchable = selectProps.isSearchable,
      menuIsOpen = selectProps.menuIsOpen,
      options = selectProps.options,
      screenReaderStatus = selectProps.screenReaderStatus,
      tabSelectsValue = selectProps.tabSelectsValue;
  var ariaLabel = selectProps['aria-label'];
  var ariaLive = selectProps['aria-live']; // Update aria live message configuration when prop changes

  var messages = Object(compat_module["useMemo"])(function () {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]); // Update aria live selected option when prop changes

  var ariaSelected = Object(compat_module["useMemo"])(function () {
    var message = '';

    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option,
          removedValue = ariaSelection.removedValue,
          value = ariaSelection.value; // select-option when !isMulti does not return option so we assume selected option is value

      var asOption = function asOption(val) {
        return !Array.isArray(val) ? val : null;
      };

      var selected = removedValue || option || asOption(value);

      var onChangeProps = _objectSpread2({
        isDisabled: selected && isOptionDisabled(selected),
        label: selected ? getOptionLabel(selected) : ''
      }, ariaSelection);

      message = messages.onChange(onChangeProps);
    }

    return message;
  }, [ariaSelection, isOptionDisabled, getOptionLabel, messages]);
  var ariaFocused = Object(compat_module["useMemo"])(function () {
    var focusMsg = '';
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));

    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused: focused,
        label: getOptionLabel(focused),
        isDisabled: isOptionDisabled(focused),
        isSelected: isSelected,
        options: options,
        context: focused === focusedOption ? 'menu' : 'value',
        selectValue: selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }

    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel, isOptionDisabled, messages, options, selectValue]);
  var ariaResults = Object(compat_module["useMemo"])(function () {
    var resultsMsg = '';

    if (menuIsOpen && options.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue: inputValue,
        resultsMessage: resultsMessage
      });
    }

    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options, screenReaderStatus]);
  var ariaGuidance = Object(compat_module["useMemo"])(function () {
    var guidanceMsg = '';

    if (messages.guidance) {
      var context = focusedValue ? 'value' : menuIsOpen ? 'menu' : 'input';
      guidanceMsg = messages.guidance({
        'aria-label': ariaLabel,
        context: context,
        isDisabled: focusedOption && isOptionDisabled(focusedOption),
        isMulti: isMulti,
        isSearchable: isSearchable,
        tabSelectsValue: tabSelectsValue
      });
    }

    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled, isSearchable, menuIsOpen, messages, tabSelectsValue]);
  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
  return emotion_react_browser_esm_jsx(Select_dbb12e54_esm_A11yText, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && emotion_react_browser_esm_jsx(compat_module["default"].Fragment, null, emotion_react_browser_esm_jsx("span", {
    id: "aria-selection"
  }, ariaSelected), emotion_react_browser_esm_jsx("span", {
    id: "aria-context"
  }, ariaContext)));
};

var diacritics = [{
  base: 'A',
  letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
}, {
  base: 'AA',
  letters: "\uA732"
}, {
  base: 'AE',
  letters: "\xC6\u01FC\u01E2"
}, {
  base: 'AO',
  letters: "\uA734"
}, {
  base: 'AU',
  letters: "\uA736"
}, {
  base: 'AV',
  letters: "\uA738\uA73A"
}, {
  base: 'AY',
  letters: "\uA73C"
}, {
  base: 'B',
  letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
}, {
  base: 'C',
  letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
}, {
  base: 'D',
  letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
}, {
  base: 'DZ',
  letters: "\u01F1\u01C4"
}, {
  base: 'Dz',
  letters: "\u01F2\u01C5"
}, {
  base: 'E',
  letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
}, {
  base: 'F',
  letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
}, {
  base: 'G',
  letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
}, {
  base: 'H',
  letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
}, {
  base: 'I',
  letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
}, {
  base: 'J',
  letters: "J\u24BF\uFF2A\u0134\u0248"
}, {
  base: 'K',
  letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
}, {
  base: 'L',
  letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
}, {
  base: 'LJ',
  letters: "\u01C7"
}, {
  base: 'Lj',
  letters: "\u01C8"
}, {
  base: 'M',
  letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
}, {
  base: 'N',
  letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
}, {
  base: 'NJ',
  letters: "\u01CA"
}, {
  base: 'Nj',
  letters: "\u01CB"
}, {
  base: 'O',
  letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
}, {
  base: 'OI',
  letters: "\u01A2"
}, {
  base: 'OO',
  letters: "\uA74E"
}, {
  base: 'OU',
  letters: "\u0222"
}, {
  base: 'P',
  letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
}, {
  base: 'Q',
  letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
}, {
  base: 'R',
  letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
}, {
  base: 'S',
  letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
}, {
  base: 'T',
  letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
}, {
  base: 'TZ',
  letters: "\uA728"
}, {
  base: 'U',
  letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
}, {
  base: 'V',
  letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
}, {
  base: 'VY',
  letters: "\uA760"
}, {
  base: 'W',
  letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
}, {
  base: 'X',
  letters: "X\u24CD\uFF38\u1E8A\u1E8C"
}, {
  base: 'Y',
  letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
}, {
  base: 'Z',
  letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
}, {
  base: 'a',
  letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
}, {
  base: 'aa',
  letters: "\uA733"
}, {
  base: 'ae',
  letters: "\xE6\u01FD\u01E3"
}, {
  base: 'ao',
  letters: "\uA735"
}, {
  base: 'au',
  letters: "\uA737"
}, {
  base: 'av',
  letters: "\uA739\uA73B"
}, {
  base: 'ay',
  letters: "\uA73D"
}, {
  base: 'b',
  letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
}, {
  base: 'c',
  letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
}, {
  base: 'd',
  letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
}, {
  base: 'dz',
  letters: "\u01F3\u01C6"
}, {
  base: 'e',
  letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
}, {
  base: 'f',
  letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
}, {
  base: 'g',
  letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
}, {
  base: 'h',
  letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
}, {
  base: 'hv',
  letters: "\u0195"
}, {
  base: 'i',
  letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
}, {
  base: 'j',
  letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
}, {
  base: 'k',
  letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
}, {
  base: 'l',
  letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
}, {
  base: 'lj',
  letters: "\u01C9"
}, {
  base: 'm',
  letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
}, {
  base: 'n',
  letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
}, {
  base: 'nj',
  letters: "\u01CC"
}, {
  base: 'o',
  letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
}, {
  base: 'oi',
  letters: "\u01A3"
}, {
  base: 'ou',
  letters: "\u0223"
}, {
  base: 'oo',
  letters: "\uA74F"
}, {
  base: 'p',
  letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
}, {
  base: 'q',
  letters: "q\u24E0\uFF51\u024B\uA757\uA759"
}, {
  base: 'r',
  letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
}, {
  base: 's',
  letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
}, {
  base: 't',
  letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
}, {
  base: 'tz',
  letters: "\uA729"
}, {
  base: 'u',
  letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
}, {
  base: 'v',
  letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
}, {
  base: 'vy',
  letters: "\uA761"
}, {
  base: 'w',
  letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
}, {
  base: 'x',
  letters: "x\u24E7\uFF58\u1E8B\u1E8D"
}, {
  base: 'y',
  letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
}, {
  base: 'z',
  letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
}];
var anyDiacritic = new RegExp('[' + diacritics.map(function (d) {
  return d.letters;
}).join('') + ']', 'g');
var diacriticToBase = {};

for (var Select_dbb12e54_esm_i = 0; Select_dbb12e54_esm_i < diacritics.length; Select_dbb12e54_esm_i++) {
  var diacritic = diacritics[Select_dbb12e54_esm_i];

  for (var Select_dbb12e54_esm_j = 0; Select_dbb12e54_esm_j < diacritic.letters.length; Select_dbb12e54_esm_j++) {
    diacriticToBase[diacritic.letters[Select_dbb12e54_esm_j]] = diacritic.base;
  }
}

var stripDiacritics = function stripDiacritics(str) {
  return str.replace(anyDiacritic, function (match) {
    return diacriticToBase[match];
  });
};

var memoizedStripDiacriticsForInput = memoize_one_esm(stripDiacritics);

var trimString = function trimString(str) {
  return str.replace(/^\s+|\s+$/g, '');
};

var defaultStringify = function defaultStringify(option) {
  return "".concat(option.label, " ").concat(option.value);
};

var Select_dbb12e54_esm_createFilter = function createFilter(config) {
  return function (option, rawInput) {
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: 'any'
    }, config),
        ignoreCase = _ignoreCase$ignoreAcc.ignoreCase,
        ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents,
        stringify = _ignoreCase$ignoreAcc.stringify,
        trim = _ignoreCase$ignoreAcc.trim,
        matchFrom = _ignoreCase$ignoreAcc.matchFrom;

    var input = trim ? trimString(rawInput) : rawInput;
    var candidate = trim ? trimString(stringify(option)) : stringify(option);

    if (ignoreCase) {
      input = input.toLowerCase();
      candidate = candidate.toLowerCase();
    }

    if (ignoreAccents) {
      input = memoizedStripDiacriticsForInput(input);
      candidate = stripDiacritics(candidate);
    }

    return matchFrom === 'start' ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
  };
};

function DummyInput(_ref) {
  _ref["in"];
  _ref.out;
  _ref.onExited;
  _ref.appear;
  _ref.enter;
  _ref.exit;
  var innerRef = _ref.innerRef;
  _ref.emotion;

  var props = _objectWithoutProperties(_ref, ["in", "out", "onExited", "appear", "enter", "exit", "innerRef", "emotion"]);

  return emotion_react_browser_esm_jsx("input", _extends({
    ref: innerRef
  }, props, {
    css: /*#__PURE__*/emotion_react_browser_esm_css({
      label: 'dummyInput',
      // get rid of any default styles
      background: 0,
      border: 0,
      fontSize: 'inherit',
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: 'transparent',
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: 'relative',
      transform: 'scale(0)'
    },  true ? "" : undefined,  true ? "" : undefined)
  }));
}

var cancelScroll = function cancelScroll(event) {
  event.preventDefault();
  event.stopPropagation();
};

function useScrollCapture(_ref) {
  var isEnabled = _ref.isEnabled,
      onBottomArrive = _ref.onBottomArrive,
      onBottomLeave = _ref.onBottomLeave,
      onTopArrive = _ref.onTopArrive,
      onTopLeave = _ref.onTopLeave;
  var isBottom = Object(compat_module["useRef"])(false);
  var isTop = Object(compat_module["useRef"])(false);
  var touchStart = Object(compat_module["useRef"])(0);
  var scrollTarget = Object(compat_module["useRef"])(null);
  var handleEventDelta = Object(compat_module["useCallback"])(function (event, delta) {
    // Reference should never be `null` at this point, but flow complains otherwise
    if (scrollTarget.current === null) return;
    var _scrollTarget$current = scrollTarget.current,
        scrollTop = _scrollTarget$current.scrollTop,
        scrollHeight = _scrollTarget$current.scrollHeight,
        clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false; // reset bottom/top flags

    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave) onBottomLeave(event);
      isBottom.current = false;
    }

    if (isDeltaPositive && isTop.current) {
      if (onTopLeave) onTopLeave(event);
      isTop.current = false;
    } // bottom limit


    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }

      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true; // top limit
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }

      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    } // cancel scroll


    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, []);
  var onWheel = Object(compat_module["useCallback"])(function (event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = Object(compat_module["useCallback"])(function (event) {
    // set touch start so we can calculate touchmove delta
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = Object(compat_module["useCallback"])(function (event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = Object(compat_module["useCallback"])(function (el) {
    // bail early if no element is available to attach to
    if (!el) return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false; // all the if statements are to appease Flow 

    if (typeof el.addEventListener === 'function') {
      el.addEventListener('wheel', onWheel, notPassive);
    }

    if (typeof el.addEventListener === 'function') {
      el.addEventListener('touchstart', onTouchStart, notPassive);
    }

    if (typeof el.addEventListener === 'function') {
      el.addEventListener('touchmove', onTouchMove, notPassive);
    }
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = Object(compat_module["useCallback"])(function (el) {
    // bail early if no element is available to detach from
    if (!el) return; // all the if statements are to appease Flow 

    if (typeof el.removeEventListener === 'function') {
      el.removeEventListener('wheel', onWheel, false);
    }

    if (typeof el.removeEventListener === 'function') {
      el.removeEventListener('touchstart', onTouchStart, false);
    }

    if (typeof el.removeEventListener === 'function') {
      el.removeEventListener('touchmove', onTouchMove, false);
    }
  }, [onTouchMove, onTouchStart, onWheel]);
  Object(compat_module["useEffect"])(function () {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    startListening(element);
    return function () {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function (element) {
    scrollTarget.current = element;
  };
}

var STYLE_KEYS = ['boxSizing', 'height', 'overflow', 'paddingRight', 'position'];
var LOCK_STYLES = {
  boxSizing: 'border-box',
  // account for possible declaration `width: 100%;` on body
  overflow: 'hidden',
  position: 'relative',
  height: '100%'
};

function preventTouchMove(e) {
  e.preventDefault();
}

function allowTouchMove(e) {
  e.stopPropagation();
}

function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;

  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
} // `ontouchstart` check works on most browsers
// `maxTouchPoints` works on IE10/11 and Surface


function isTouchDevice() {
  return 'ontouchstart' in window || navigator.maxTouchPoints;
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};

function useScrollLock(_ref) {
  var isEnabled = _ref.isEnabled,
      _ref$accountForScroll = _ref.accountForScrollbars,
      accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = Object(compat_module["useRef"])({});
  var scrollTarget = Object(compat_module["useRef"])(null);
  var addScrollLock = Object(compat_module["useCallback"])(function (touchScrollTarget) {
    if (!canUseDOM) return;
    var target = document.body;
    var targetStyle = target && target.style;

    if (accountForScrollbars) {
      // store any styles already applied to the body
      STYLE_KEYS.forEach(function (key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    } // apply the lock styles and padding if this is the first scroll lock


    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function (key) {
        var val = LOCK_STYLES[key];

        if (targetStyle) {
          targetStyle[key] = val;
        }
      });

      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    } // account for touch devices


    if (target && isTouchDevice()) {
      // Mobile Safari ignores { overflow: hidden } declaration on the body.
      target.addEventListener('touchmove', preventTouchMove, listenerOptions); // Allow scroll on provided target

      if (touchScrollTarget) {
        touchScrollTarget.addEventListener('touchstart', preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener('touchmove', allowTouchMove, listenerOptions);
      }
    } // increment active scroll locks


    activeScrollLocks += 1;
  }, []);
  var removeScrollLock = Object(compat_module["useCallback"])(function (touchScrollTarget) {
    if (!canUseDOM) return;
    var target = document.body;
    var targetStyle = target && target.style; // safely decrement active scroll locks

    activeScrollLocks = Math.max(activeScrollLocks - 1, 0); // reapply original body styles, if any

    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function (key) {
        var val = originalStyles.current[key];

        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    } // remove touch listeners


    if (target && isTouchDevice()) {
      target.removeEventListener('touchmove', preventTouchMove, listenerOptions);

      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener('touchstart', preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener('touchmove', allowTouchMove, listenerOptions);
      }
    }
  }, []);
  Object(compat_module["useEffect"])(function () {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function () {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function (element) {
    scrollTarget.current = element;
  };
}

function _EMOTION_STRINGIFIED_CSS_ERROR__$1() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}

var blurSelectInput = function blurSelectInput() {
  return document.activeElement && document.activeElement.blur();
};

var Select_dbb12e54_esm_ref2 =  true ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : undefined;

function ScrollManager(_ref) {
  var children = _ref.children,
      lockEnabled = _ref.lockEnabled,
      _ref$captureEnabled = _ref.captureEnabled,
      captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled,
      onBottomArrive = _ref.onBottomArrive,
      onBottomLeave = _ref.onBottomLeave,
      onTopArrive = _ref.onTopArrive,
      onTopLeave = _ref.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive: onBottomArrive,
    onBottomLeave: onBottomLeave,
    onTopArrive: onTopArrive,
    onTopLeave: onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });

  var targetRef = function targetRef(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };

  return emotion_react_browser_esm_jsx(compat_module["default"].Fragment, null, lockEnabled && emotion_react_browser_esm_jsx("div", {
    onClick: blurSelectInput,
    css: Select_dbb12e54_esm_ref2
  }), children(targetRef));
}

var formatGroupLabel = function formatGroupLabel(group) {
  return group.label;
};

var Select_dbb12e54_esm_getOptionLabel = function getOptionLabel(option) {
  return option.label;
};

var getOptionValue = function getOptionValue(option) {
  return option.value;
};

var Select_dbb12e54_esm_isOptionDisabled = function isOptionDisabled(option) {
  return !!option.isDisabled;
};

var defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: index_4bd03571_esm_css,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: index_4bd03571_esm_menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css$1,
  valueContainer: valueContainerCSS
}; // Merge Utility
// Allows consumers to extend a base Select with additional styles

function mergeStyles(source) {
  var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // initialize with source styles

  var styles = _objectSpread2({}, source); // massage in target styles


  Object.keys(target).forEach(function (key) {
    if (source[key]) {
      styles[key] = function (rsCss, props) {
        return target[key](source[key](rsCss, props), props);
      };
    } else {
      styles[key] = target[key];
    }
  });
  return styles;
}

var Select_dbb12e54_esm_colors = {
  primary: '#2684FF',
  primary75: '#4C9AFF',
  primary50: '#B2D4FF',
  primary25: '#DEEBFF',
  danger: '#DE350B',
  dangerLight: '#FFBDAD',
  neutral0: 'hsl(0, 0%, 100%)',
  neutral5: 'hsl(0, 0%, 95%)',
  neutral10: 'hsl(0, 0%, 90%)',
  neutral20: 'hsl(0, 0%, 80%)',
  neutral30: 'hsl(0, 0%, 70%)',
  neutral40: 'hsl(0, 0%, 60%)',
  neutral50: 'hsl(0, 0%, 50%)',
  neutral60: 'hsl(0, 0%, 40%)',
  neutral70: 'hsl(0, 0%, 30%)',
  neutral80: 'hsl(0, 0%, 20%)',
  neutral90: 'hsl(0, 0%, 10%)'
};
var Select_dbb12e54_esm_borderRadius = 4; // Used to calculate consistent margin/padding on elements

var baseUnit = 4; // The minimum height of the control

var controlHeight = 38; // The amount of space between the control and menu */

var menuGutter = baseUnit * 2;
var Select_dbb12e54_esm_spacing = {
  baseUnit: baseUnit,
  controlHeight: controlHeight,
  menuGutter: menuGutter
};
var defaultTheme = {
  borderRadius: Select_dbb12e54_esm_borderRadius,
  colors: Select_dbb12e54_esm_colors,
  spacing: Select_dbb12e54_esm_spacing
};
var defaultProps = {
  'aria-live': 'polite',
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: Select_dbb12e54_esm_createFilter(),
  formatGroupLabel: formatGroupLabel,
  getOptionLabel: Select_dbb12e54_esm_getOptionLabel,
  getOptionValue: getOptionValue,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled: Select_dbb12e54_esm_isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return 'Loading...';
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: 'bottom',
  menuPosition: 'absolute',
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return 'No options';
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: 'Select...',
  screenReaderStatus: function screenReaderStatus(_ref) {
    var count = _ref.count;
    return "".concat(count, " result").concat(count !== 1 ? 's' : '', " available");
  },
  styles: {},
  tabIndex: '0',
  tabSelectsValue: true
};

function toCategorizedOption(props, option, selectValue, index) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);

  var isSelected = _isOptionSelected(props, option, selectValue);

  var label = getOptionLabel$1(props, option);
  var value = getOptionValue$1(props, option);
  return {
    type: 'option',
    data: option,
    isDisabled: isDisabled,
    isSelected: isSelected,
    label: label,
    value: value,
    index: index
  };
}

function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function (groupOrOption, groupOrOptionIndex) {
    if (groupOrOption.options) {
      var categorizedOptions = groupOrOption.options.map(function (option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function (categorizedOption) {
        return isFocusable(props, categorizedOption);
      });
      return categorizedOptions.length > 0 ? {
        type: 'group',
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : undefined;
    }

    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : undefined;
  }) // Flow limitation (see https://github.com/facebook/flow/issues/1414)
  .filter(function (categorizedOption) {
    return !!categorizedOption;
  });
}

function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function (optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === 'group') {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function (option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }

    return optionsAccumulator;
  }, []);
}

function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}

function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue,
      inputValue = _props$inputValue === void 0 ? '' : _props$inputValue;
  var data = categorizedOption.data,
      isSelected = categorizedOption.isSelected,
      label = categorizedOption.label,
      value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label: label,
    value: value,
    data: data
  }, inputValue);
}

function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue,
      lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);

  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);

    if (nextFocusedIndex > -1) {
      // the focused value is still in the selectValue, return it
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      // the focusedValue is not present in the next selectValue array by
      // reference, so return the new value at the same index
      return nextSelectValue[lastFocusedIndex];
    }
  }

  return null;
}

function getNextFocusedOption(state, options) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options[0];
}

var getOptionLabel$1 = function getOptionLabel(props, data) {
  return props.getOptionLabel(data);
};

var getOptionValue$1 = function getOptionValue(props, data) {
  return props.getOptionValue(data);
};

function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === 'function' ? props.isOptionDisabled(option, selectValue) : false;
}

function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1) return true;

  if (typeof props.isOptionSelected === 'function') {
    return props.isOptionSelected(option, selectValue);
  }

  var candidate = getOptionValue$1(props, option);
  return selectValue.some(function (i) {
    return getOptionValue$1(props, i) === candidate;
  });
}

function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}

var shouldHideSelectedOptions = function shouldHideSelectedOptions(props) {
  var hideSelectedOptions = props.hideSelectedOptions,
      isMulti = props.isMulti;
  if (hideSelectedOptions === undefined) return isMulti;
  return hideSelectedOptions;
};

var instanceId = 1;

var Select_dbb12e54_esm_Select = /*#__PURE__*/function (_Component) {
  inherits_inherits(Select, _Component);

  var _super = index_4bd03571_esm_createSuper(Select); // Misc. Instance Properties
  // ------------------------------
  // TODO
  // Refs
  // ------------------------------
  // Lifecycle
  // ------------------------------


  function Select(_props) {
    var _this;

    classCallCheck_classCallCheck(this, Select);

    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      inputIsHiddenAfterUpdate: undefined,
      prevProps: undefined
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.instancePrefix = '';
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;

    _this.getControlRef = function (ref) {
      _this.controlRef = ref;
    };

    _this.focusedOptionRef = null;

    _this.getFocusedOptionRef = function (ref) {
      _this.focusedOptionRef = ref;
    };

    _this.menuListRef = null;

    _this.getMenuListRef = function (ref) {
      _this.menuListRef = ref;
    };

    _this.inputRef = null;

    _this.getInputRef = function (ref) {
      _this.inputRef = ref;
    };

    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;

    _this.onChange = function (newValue, actionMeta) {
      var _this$props = _this.props,
          onChange = _this$props.onChange,
          name = _this$props.name;
      actionMeta.name = name;

      _this.ariaOnChange(newValue, actionMeta);

      onChange(newValue, actionMeta);
    };

    _this.setValue = function (newValue) {
      var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'set-value';
      var option = arguments.length > 2 ? arguments[2] : undefined;
      var _this$props2 = _this.props,
          closeMenuOnSelect = _this$props2.closeMenuOnSelect,
          isMulti = _this$props2.isMulti;

      _this.onInputChange('', {
        action: 'set-value'
      });

      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });

        _this.onMenuClose();
      } // when the select value should change, we should reset focusedValue


      _this.setState({
        clearFocusValueOnUpdate: true
      });

      _this.onChange(newValue, {
        action: action,
        option: option
      });
    };

    _this.selectOption = function (newValue) {
      var _this$props3 = _this.props,
          blurInputOnSelect = _this$props3.blurInputOnSelect,
          isMulti = _this$props3.isMulti,
          name = _this$props3.name;
      var selectValue = _this.state.selectValue;

      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);

      var isDisabled = _this.isOptionDisabled(newValue, selectValue);

      if (deselected) {
        var candidate = _this.getOptionValue(newValue);

        _this.setValue(selectValue.filter(function (i) {
          return _this.getOptionValue(i) !== candidate;
        }), 'deselect-option', newValue);
      } else if (!isDisabled) {
        // Select option if option is not disabled
        if (isMulti) {
          _this.setValue([].concat(_toConsumableArray(selectValue), [newValue]), 'select-option', newValue);
        } else {
          _this.setValue(newValue, 'select-option');
        }
      } else {
        _this.ariaOnChange(newValue, {
          action: 'select-option',
          name: name
        });

        return;
      }

      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };

    _this.removeValue = function (removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;

      var candidate = _this.getOptionValue(removedValue);

      var newValueArray = selectValue.filter(function (i) {
        return _this.getOptionValue(i) !== candidate;
      });
      var newValue = isMulti ? newValueArray : newValueArray[0] || null;

      _this.onChange(newValue, {
        action: 'remove-value',
        removedValue: removedValue
      });

      _this.focusInput();
    };

    _this.clearValue = function () {
      var selectValue = _this.state.selectValue;

      _this.onChange(_this.props.isMulti ? [] : null, {
        action: 'clear',
        removedValues: selectValue
      });
    };

    _this.popValue = function () {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = isMulti ? newValueArray : newValueArray[0] || null;

      _this.onChange(newValue, {
        action: 'pop-value',
        removedValue: lastSelectedValue
      });
    };

    _this.getValue = function () {
      return _this.state.selectValue;
    };

    _this.cx = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };

    _this.getOptionLabel = function (data) {
      return getOptionLabel$1(_this.props, data);
    };

    _this.getOptionValue = function (data) {
      return getOptionValue$1(_this.props, data);
    };

    _this.getStyles = function (key, props) {
      var base = defaultStyles[key](props);
      base.boxSizing = 'border-box';
      var custom = _this.props.styles[key];
      return custom ? custom(base, props) : base;
    };

    _this.getElementId = function (element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    };

    _this.getComponents = function () {
      return defaultComponents(_this.props);
    };

    _this.buildCategorizedOptions = function () {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };

    _this.getCategorizedOptions = function () {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };

    _this.buildFocusableOptions = function () {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };

    _this.getFocusableOptions = function () {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };

    _this.ariaOnChange = function (value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value: value
        }, actionMeta)
      });
    };

    _this.onMenuMouseDown = function (event) {
      if (event.button !== 0) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();

      _this.focusInput();
    };

    _this.onMenuMouseMove = function (event) {
      _this.blockOptionHover = false;
    };

    _this.onControlMouseDown = function (event) {
      var openMenuOnClick = _this.props.openMenuOnClick;

      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }

        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu('first');
        }
      } else {
        if ( // $FlowFixMe
        event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
          _this.onMenuClose();
        }
      }

      if ( // $FlowFixMe
      event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
        event.preventDefault();
      }
    };

    _this.onDropdownIndicatorMouseDown = function (event) {
      // ignore mouse events that weren't triggered by the primary button
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }

      if (_this.props.isDisabled) return;
      var _this$props4 = _this.props,
          isMulti = _this$props4.isMulti,
          menuIsOpen = _this$props4.menuIsOpen;

      _this.focusInput();

      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });

        _this.onMenuClose();
      } else {
        _this.openMenu('first');
      }

      event.preventDefault();
      event.stopPropagation();
    };

    _this.onClearIndicatorMouseDown = function (event) {
      // ignore mouse events that weren't triggered by the primary button
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }

      _this.clearValue();

      event.stopPropagation();
      _this.openAfterFocus = false;

      if (event.type === 'touchend') {
        _this.focusInput();
      } else {
        setTimeout(function () {
          return _this.focusInput();
        });
      }
    };

    _this.onScroll = function (event) {
      if (typeof _this.props.closeMenuOnScroll === 'boolean') {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === 'function') {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };

    _this.onCompositionStart = function () {
      _this.isComposing = true;
    };

    _this.onCompositionEnd = function () {
      _this.isComposing = false;
    };

    _this.onTouchStart = function (_ref2) {
      var touches = _ref2.touches;
      var touch = touches && touches.item(0);

      if (!touch) {
        return;
      }

      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };

    _this.onTouchMove = function (_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);

      if (!touch) {
        return;
      }

      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };

    _this.onTouchEnd = function (event) {
      if (_this.userIsDragging) return; // close the menu if the user taps outside
      // we're checking on event.target here instead of event.currentTarget, because we want to assert information
      // on events on child elements, not the document (which we've attached this handler to).

      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      } // reset move vars


      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };

    _this.onControlTouchEnd = function (event) {
      if (_this.userIsDragging) return;

      _this.onControlMouseDown(event);
    };

    _this.onClearIndicatorTouchEnd = function (event) {
      if (_this.userIsDragging) return;

      _this.onClearIndicatorMouseDown(event);
    };

    _this.onDropdownIndicatorTouchEnd = function (event) {
      if (_this.userIsDragging) return;

      _this.onDropdownIndicatorMouseDown(event);
    };

    _this.handleInputChange = function (event) {
      var inputValue = event.currentTarget.value;

      _this.setState({
        inputIsHiddenAfterUpdate: false
      });

      _this.onInputChange(inputValue, {
        action: 'input-change'
      });

      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };

    _this.onInputFocus = function (event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }

      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });

      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu('first');
      }

      _this.openAfterFocus = false;
    };

    _this.onInputBlur = function (event) {
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();

        return;
      }

      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }

      _this.onInputChange('', {
        action: 'input-blur'
      });

      _this.onMenuClose();

      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };

    _this.onOptionHover = function (focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }

      _this.setState({
        focusedOption: focusedOption
      });
    };

    _this.shouldHideSelectedOptions = function () {
      return shouldHideSelectedOptions(_this.props);
    };

    _this.onKeyDown = function (event) {
      var _this$props5 = _this.props,
          isMulti = _this$props5.isMulti,
          backspaceRemovesValue = _this$props5.backspaceRemovesValue,
          escapeClearsValue = _this$props5.escapeClearsValue,
          inputValue = _this$props5.inputValue,
          isClearable = _this$props5.isClearable,
          isDisabled = _this$props5.isDisabled,
          menuIsOpen = _this$props5.menuIsOpen,
          onKeyDown = _this$props5.onKeyDown,
          tabSelectsValue = _this$props5.tabSelectsValue,
          openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state,
          focusedOption = _this$state.focusedOption,
          focusedValue = _this$state.focusedValue,
          selectValue = _this$state.selectValue;
      if (isDisabled) return;

      if (typeof onKeyDown === 'function') {
        onKeyDown(event);

        if (event.defaultPrevented) {
          return;
        }
      } // Block option hover events when the user has just pressed a key


      _this.blockOptionHover = true;

      switch (event.key) {
        case 'ArrowLeft':
          if (!isMulti || inputValue) return;

          _this.focusValue('previous');

          break;

        case 'ArrowRight':
          if (!isMulti || inputValue) return;

          _this.focusValue('next');

          break;

        case 'Delete':
        case 'Backspace':
          if (inputValue) return;

          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue) return;

            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }

          break;

        case 'Tab':
          if (_this.isComposing) return;

          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }

          _this.selectOption(focusedOption);

          break;

        case 'Enter':
          if (event.keyCode === 229) {
            // ignore the keydown event from an Input Method Editor(IME)
            // ref. https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode
            break;
          }

          if (menuIsOpen) {
            if (!focusedOption) return;
            if (_this.isComposing) return;

            _this.selectOption(focusedOption);

            break;
          }

          return;

        case 'Escape':
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });

            _this.onInputChange('', {
              action: 'menu-close'
            });

            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }

          break;

        case ' ':
          // space
          if (inputValue) {
            return;
          }

          if (!menuIsOpen) {
            _this.openMenu('first');

            break;
          }

          if (!focusedOption) return;

          _this.selectOption(focusedOption);

          break;

        case 'ArrowUp':
          if (menuIsOpen) {
            _this.focusOption('up');
          } else {
            _this.openMenu('last');
          }

          break;

        case 'ArrowDown':
          if (menuIsOpen) {
            _this.focusOption('down');
          } else {
            _this.openMenu('first');
          }

          break;

        case 'PageUp':
          if (!menuIsOpen) return;

          _this.focusOption('pageup');

          break;

        case 'PageDown':
          if (!menuIsOpen) return;

          _this.focusOption('pagedown');

          break;

        case 'Home':
          if (!menuIsOpen) return;

          _this.focusOption('first');

          break;

        case 'End':
          if (!menuIsOpen) return;

          _this.focusOption('last');

          break;

        default:
          return;
      }

      event.preventDefault();
    };

    _this.instancePrefix = 'react-select-' + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = index_4bd03571_esm_cleanValue(_props.value);
    return _this;
  }

  createClass_createClass(Select, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();

      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        // Listen to all scroll events, and filter them out inside of 'onScroll'
        document.addEventListener('scroll', this.onScroll, true);
      }

      if (this.props.autoFocus) {
        this.focusInput();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props,
          isDisabled = _this$props6.isDisabled,
          menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;

      if ( // ensure focus is restored correctly when the control becomes enabled
      isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
      isFocused && menuIsOpen && !prevProps.menuIsOpen) {
        this.focusInput();
      }

      if (isFocused && isDisabled && !prevProps.isDisabled) {
        // ensure select state gets blurred in case Select is programatically disabled while focused
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } // scroll the focused option into view if necessary


      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        index_4bd03571_esm_scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener('scroll', this.onScroll, true);
    } // ==============================
    // Consumer Handlers
    // ==============================

  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange('', {
        action: 'menu-close'
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    } // ==============================
    // Methods
    // ==============================

  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef) return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef) return;
      this.inputRef.blur();
    } // aliased for consumers

  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;

      var _this$state2 = this.state,
          selectValue = _this$state2.selectValue,
          isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === 'first' ? 0 : focusableOptions.length - 1;

      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);

        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      } // only scroll if the menu isn't already open


      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function () {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state,
          selectValue = _this$state3.selectValue,
          focusedValue = _this$state3.focusedValue; // Only multiselects support value focusing

      if (!this.props.isMulti) return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);

      if (!focusedValue) {
        focusedIndex = -1;
      }

      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length) return;

      switch (direction) {
        case 'previous':
          if (focusedIndex === 0) {
            // don't cycle from the start to the end
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            // if nothing is focused, focus the last value first
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }

          break;

        case 'next':
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }

          break;
      }

      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'first';
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options = this.getFocusableOptions();
      if (!options.length) return;
      var nextFocus = 0; // handles 'first'

      var focusedIndex = options.indexOf(focusedOption);

      if (!focusedOption) {
        focusedIndex = -1;
      }

      if (direction === 'up') {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options.length - 1;
      } else if (direction === 'down') {
        nextFocus = (focusedIndex + 1) % options.length;
      } else if (direction === 'pageup') {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0) nextFocus = 0;
      } else if (direction === 'pagedown') {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options.length - 1) nextFocus = options.length - 1;
      } else if (direction === 'last') {
        nextFocus = options.length - 1;
      }

      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options[nextFocus],
        focusedValue: null
      });
    }
  }, {
    key: "getTheme",
    value: // ==============================
    // Getters
    // ==============================
    function getTheme() {
      // Use the default theme if there are no customizations.
      if (!this.props.theme) {
        return defaultTheme;
      } // If the theme prop is a function, assume the function
      // knows how to merge the passed-in default theme with
      // its own modifications.


      if (typeof this.props.theme === 'function') {
        return this.props.theme(defaultTheme);
      } // Otherwise, if a plain theme object was passed in,
      // overlay it with the default theme.


      return _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme);
    }
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue,
          cx = this.cx,
          getStyles = this.getStyles,
          getValue = this.getValue,
          selectOption = this.selectOption,
          setValue = this.setValue,
          props = this.props;
      var isMulti = props.isMulti,
          isRtl = props.isRtl,
          options = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue: clearValue,
        cx: cx,
        getStyles: getStyles,
        getValue: getValue,
        hasValue: hasValue,
        isMulti: isMulti,
        isRtl: isRtl,
        options: options,
        selectOption: selectOption,
        selectProps: props,
        setValue: setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props,
          isClearable = _this$props7.isClearable,
          isMulti = _this$props7.isMulti; // single select, by default, IS NOT clearable
      // multi select, by default, IS clearable

      if (isClearable === undefined) return isMulti;
      return isClearable;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === 'function') {
        var inputValue = this.props.inputValue;
        var selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context: context,
          inputValue: inputValue,
          selectValue: selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel(data) {
      return this.props.formatGroupLabel(data);
    } // ==============================
    // Mouse Handlers
    // ==============================

  }, {
    key: "startListeningComposition",
    value: // ==============================
    // Composition Handlers
    // ==============================
    function startListeningComposition() {
      if (document && document.addEventListener) {
        document.addEventListener('compositionstart', this.onCompositionStart, false);
        document.addEventListener('compositionend', this.onCompositionEnd, false);
      }
    }
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener('compositionstart', this.onCompositionStart);
        document.removeEventListener('compositionend', this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: // ==============================
    // Touch Handlers
    // ==============================
    function startListeningToTouch() {
      if (document && document.addEventListener) {
        document.addEventListener('touchstart', this.onTouchStart, false);
        document.addEventListener('touchmove', this.onTouchMove, false);
        document.addEventListener('touchend', this.onTouchEnd, false);
      }
    }
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener('touchstart', this.onTouchStart);
        document.removeEventListener('touchmove', this.onTouchMove);
        document.removeEventListener('touchend', this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: // ==============================
    // Renderers
    // ==============================
    function renderInput() {
      var _this$props8 = this.props,
          isDisabled = _this$props8.isDisabled,
          isSearchable = _this$props8.isSearchable,
          inputId = _this$props8.inputId,
          inputValue = _this$props8.inputValue,
          tabIndex = _this$props8.tabIndex,
          form = _this$props8.form;

      var _this$getComponents = this.getComponents(),
          Input = _this$getComponents.Input;

      var inputIsHidden = this.state.inputIsHidden;
      var commonProps = this.commonProps;
      var id = inputId || this.getElementId('input'); // aria attributes makes the JSX "noisy", separated for clarity

      var ariaAttributes = {
        'aria-autocomplete': 'list',
        'aria-label': this.props['aria-label'],
        'aria-labelledby': this.props['aria-labelledby']
      };

      if (!isSearchable) {
        // use a dummy input to maintain focus/blur functionality
        return /*#__PURE__*/compat_module["default"].createElement(DummyInput, _extends({
          id: id,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: noop,
          onFocus: this.onInputFocus,
          readOnly: true,
          disabled: isDisabled,
          tabIndex: tabIndex,
          form: form,
          value: ""
        }, ariaAttributes));
      }

      return /*#__PURE__*/compat_module["default"].createElement(Input, _extends({}, commonProps, {
        autoCapitalize: "none",
        autoComplete: "off",
        autoCorrect: "off",
        id: id,
        innerRef: this.getInputRef,
        isDisabled: isDisabled,
        isHidden: inputIsHidden,
        onBlur: this.onInputBlur,
        onChange: this.handleInputChange,
        onFocus: this.onInputFocus,
        spellCheck: "false",
        tabIndex: tabIndex,
        form: form,
        type: "text",
        value: inputValue
      }, ariaAttributes));
    }
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;

      var _this$getComponents2 = this.getComponents(),
          MultiValue = _this$getComponents2.MultiValue,
          MultiValueContainer = _this$getComponents2.MultiValueContainer,
          MultiValueLabel = _this$getComponents2.MultiValueLabel,
          MultiValueRemove = _this$getComponents2.MultiValueRemove,
          SingleValue = _this$getComponents2.SingleValue,
          Placeholder = _this$getComponents2.Placeholder;

      var commonProps = this.commonProps;
      var _this$props9 = this.props,
          controlShouldRenderValue = _this$props9.controlShouldRenderValue,
          isDisabled = _this$props9.isDisabled,
          isMulti = _this$props9.isMulti,
          inputValue = _this$props9.inputValue,
          placeholder = _this$props9.placeholder;
      var _this$state4 = this.state,
          selectValue = _this$state4.selectValue,
          focusedValue = _this$state4.focusedValue,
          isFocused = _this$state4.isFocused;

      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : /*#__PURE__*/compat_module["default"].createElement(Placeholder, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled: isDisabled,
          isFocused: isFocused
        }), placeholder);
      }

      if (isMulti) {
        var selectValues = selectValue.map(function (opt, index) {
          var isOptionFocused = opt === focusedValue;
          return /*#__PURE__*/compat_module["default"].createElement(MultiValue, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer,
              Label: MultiValueLabel,
              Remove: MultiValueRemove
            },
            isFocused: isOptionFocused,
            isDisabled: isDisabled,
            key: "".concat(_this3.getOptionValue(opt)).concat(index),
            index: index,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e) {
                e.preventDefault();
                e.stopPropagation();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, 'value'));
        });
        return selectValues;
      }

      if (inputValue) {
        return null;
      }

      var singleValue = selectValue[0];
      return /*#__PURE__*/compat_module["default"].createElement(SingleValue, _extends({}, commonProps, {
        data: singleValue,
        isDisabled: isDisabled
      }), this.formatOptionLabel(singleValue, 'value'));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(),
          ClearIndicator = _this$getComponents3.ClearIndicator;

      var commonProps = this.commonProps;
      var _this$props10 = this.props,
          isDisabled = _this$props10.isDisabled,
          isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;

      if (!this.isClearable() || !ClearIndicator || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }

      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        'aria-hidden': 'true'
      };
      return /*#__PURE__*/compat_module["default"].createElement(ClearIndicator, _extends({}, commonProps, {
        innerProps: innerProps,
        isFocused: isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(),
          LoadingIndicator = _this$getComponents4.LoadingIndicator;

      var commonProps = this.commonProps;
      var _this$props11 = this.props,
          isDisabled = _this$props11.isDisabled,
          isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator || !isLoading) return null;
      var innerProps = {
        'aria-hidden': 'true'
      };
      return /*#__PURE__*/compat_module["default"].createElement(LoadingIndicator, _extends({}, commonProps, {
        innerProps: innerProps,
        isDisabled: isDisabled,
        isFocused: isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(),
          DropdownIndicator = _this$getComponents5.DropdownIndicator,
          IndicatorSeparator = _this$getComponents5.IndicatorSeparator; // separator doesn't make sense without the dropdown indicator


      if (!DropdownIndicator || !IndicatorSeparator) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return /*#__PURE__*/compat_module["default"].createElement(IndicatorSeparator, _extends({}, commonProps, {
        isDisabled: isDisabled,
        isFocused: isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(),
          DropdownIndicator = _this$getComponents6.DropdownIndicator;

      if (!DropdownIndicator) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        'aria-hidden': 'true'
      };
      return /*#__PURE__*/compat_module["default"].createElement(DropdownIndicator, _extends({}, commonProps, {
        innerProps: innerProps,
        isDisabled: isDisabled,
        isFocused: isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;

      var _this$getComponents7 = this.getComponents(),
          Group = _this$getComponents7.Group,
          GroupHeading = _this$getComponents7.GroupHeading,
          Menu = _this$getComponents7.Menu,
          MenuList = _this$getComponents7.MenuList,
          MenuPortal = _this$getComponents7.MenuPortal,
          LoadingMessage = _this$getComponents7.LoadingMessage,
          NoOptionsMessage = _this$getComponents7.NoOptionsMessage,
          Option = _this$getComponents7.Option;

      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props,
          captureMenuScroll = _this$props12.captureMenuScroll,
          inputValue = _this$props12.inputValue,
          isLoading = _this$props12.isLoading,
          loadingMessage = _this$props12.loadingMessage,
          minMenuHeight = _this$props12.minMenuHeight,
          maxMenuHeight = _this$props12.maxMenuHeight,
          menuIsOpen = _this$props12.menuIsOpen,
          menuPlacement = _this$props12.menuPlacement,
          menuPosition = _this$props12.menuPosition,
          menuPortalTarget = _this$props12.menuPortalTarget,
          menuShouldBlockScroll = _this$props12.menuShouldBlockScroll,
          menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView,
          noOptionsMessage = _this$props12.noOptionsMessage,
          onMenuScrollToTop = _this$props12.onMenuScrollToTop,
          onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen) return null; // TODO: Internal Option Type here

      var render = function render(props, id) {
        var type = props.type,
            data = props.data,
            isDisabled = props.isDisabled,
            isSelected = props.isSelected,
            label = props.label,
            value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? undefined : function () {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled ? undefined : function () {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId('option'), "-").concat(id);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return /*#__PURE__*/compat_module["default"].createElement(Option, _extends({}, commonProps, {
          innerProps: innerProps,
          data: data,
          isDisabled: isDisabled,
          isSelected: isSelected,
          key: optionId,
          label: label,
          type: type,
          value: value,
          isFocused: isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : undefined
        }), _this4.formatOptionLabel(props.data, 'menu'));
      };

      var menuUI;

      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function (item) {
          if (item.type === 'group') {
            var data = item.data,
                options = item.options,
                groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId('group'), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return /*#__PURE__*/compat_module["default"].createElement(Group, _extends({}, commonProps, {
              key: groupId,
              data: data,
              options: options,
              Heading: GroupHeading,
              headingProps: {
                id: headingId,
                data: item.data
              },
              label: _this4.formatGroupLabel(item.data)
            }), item.options.map(function (option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item.type === 'option') {
            return render(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message = loadingMessage({
          inputValue: inputValue
        });
        if (message === null) return null;
        menuUI = /*#__PURE__*/compat_module["default"].createElement(LoadingMessage, commonProps, message);
      } else {
        var _message = noOptionsMessage({
          inputValue: inputValue
        });

        if (_message === null) return null;
        menuUI = /*#__PURE__*/compat_module["default"].createElement(NoOptionsMessage, commonProps, _message);
      }

      var menuPlacementProps = {
        minMenuHeight: minMenuHeight,
        maxMenuHeight: maxMenuHeight,
        menuPlacement: menuPlacement,
        menuPosition: menuPosition,
        menuShouldScrollIntoView: menuShouldScrollIntoView
      };
      var menuElement = /*#__PURE__*/compat_module["default"].createElement(index_4bd03571_esm_MenuPlacer, _extends({}, commonProps, menuPlacementProps), function (_ref4) {
        var ref = _ref4.ref,
            _ref4$placerProps = _ref4.placerProps,
            placement = _ref4$placerProps.placement,
            maxHeight = _ref4$placerProps.maxHeight;
        return /*#__PURE__*/compat_module["default"].createElement(Menu, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove
          },
          isLoading: isLoading,
          placement: placement
        }), /*#__PURE__*/compat_module["default"].createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function (scrollTargetRef) {
          return /*#__PURE__*/compat_module["default"].createElement(MenuList, _extends({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this4.getMenuListRef(instance);

              scrollTargetRef(instance);
            },
            isLoading: isLoading,
            maxHeight: maxHeight,
            focusedOption: focusedOption
          }), menuUI);
        }));
      }); // positioning behaviour is almost identical for portalled and fixed,
      // so we use the same component. the actual portalling logic is forked
      // within the component based on `menuPosition`

      return menuPortalTarget || menuPosition === 'fixed' ? /*#__PURE__*/compat_module["default"].createElement(MenuPortal, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement: menuPlacement,
        menuPosition: menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;

      var _this$props13 = this.props,
          delimiter = _this$props13.delimiter,
          isDisabled = _this$props13.isDisabled,
          isMulti = _this$props13.isMulti,
          name = _this$props13.name;
      var selectValue = this.state.selectValue;
      if (!name || isDisabled) return;

      if (isMulti) {
        if (delimiter) {
          var value = selectValue.map(function (opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter);
          return /*#__PURE__*/compat_module["default"].createElement("input", {
            name: name,
            type: "hidden",
            value: value
          });
        } else {
          var input = selectValue.length > 0 ? selectValue.map(function (opt, i) {
            return /*#__PURE__*/compat_module["default"].createElement("input", {
              key: "i-".concat(i),
              name: name,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : /*#__PURE__*/compat_module["default"].createElement("input", {
            name: name,
            type: "hidden"
          });
          return /*#__PURE__*/compat_module["default"].createElement("div", null, input);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : '';

        return /*#__PURE__*/compat_module["default"].createElement("input", {
          name: name,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state5 = this.state,
          ariaSelection = _this$state5.ariaSelection,
          focusedOption = _this$state5.focusedOption,
          focusedValue = _this$state5.focusedValue,
          isFocused = _this$state5.isFocused,
          selectValue = _this$state5.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return /*#__PURE__*/compat_module["default"].createElement(Select_dbb12e54_esm_LiveRegion, _extends({}, commonProps, {
        ariaSelection: ariaSelection,
        focusedOption: focusedOption,
        focusedValue: focusedValue,
        isFocused: isFocused,
        selectValue: selectValue,
        focusableOptions: focusableOptions
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$getComponents8 = this.getComponents(),
          Control = _this$getComponents8.Control,
          IndicatorsContainer = _this$getComponents8.IndicatorsContainer,
          SelectContainer = _this$getComponents8.SelectContainer,
          ValueContainer = _this$getComponents8.ValueContainer;

      var _this$props14 = this.props,
          className = _this$props14.className,
          id = _this$props14.id,
          isDisabled = _this$props14.isDisabled,
          menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return /*#__PURE__*/compat_module["default"].createElement(SelectContainer, _extends({}, commonProps, {
        className: className,
        innerProps: {
          id: id,
          onKeyDown: this.onKeyDown
        },
        isDisabled: isDisabled,
        isFocused: isFocused
      }), this.renderLiveRegion(), /*#__PURE__*/compat_module["default"].createElement(Control, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: isDisabled,
        isFocused: isFocused,
        menuIsOpen: menuIsOpen
      }), /*#__PURE__*/compat_module["default"].createElement(ValueContainer, _extends({}, commonProps, {
        isDisabled: isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), /*#__PURE__*/compat_module["default"].createElement(IndicatorsContainer, _extends({}, commonProps, {
        isDisabled: isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps,
          clearFocusValueOnUpdate = state.clearFocusValueOnUpdate,
          inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate;
      var options = props.options,
          value = props.value,
          menuIsOpen = props.menuIsOpen,
          inputValue = props.inputValue;
      var newMenuOptionsState = {};

      if (prevProps && (value !== prevProps.value || options !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var selectValue = index_4bd03571_esm_cleanValue(value);
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue: selectValue,
          focusedOption: focusedOption,
          focusedValue: focusedValue,
          clearFocusValueOnUpdate: false
        };
      } // some updates should toggle the state of the input visibility


      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: undefined
      } : {};
      return _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props
      });
    }
  }]);

  return Select;
}(compat_module["Component"]);

Select_dbb12e54_esm_Select.defaultProps = defaultProps;

// CONCATENATED MODULE: ./node_modules/react-select/dist/stateManager-845a3300.esm.js







var stateManager_845a3300_esm_defaultProps = {
  defaultInputValue: '',
  defaultMenuIsOpen: false,
  defaultValue: null
};

var stateManager_845a3300_esm_manageState = function manageState(SelectComponent) {
  var _class, _temp;

  return _temp = _class = /*#__PURE__*/function (_Component) {
    inherits_inherits(StateManager, _Component);

    var _super = index_4bd03571_esm_createSuper(StateManager);

    function StateManager() {
      var _this;

      classCallCheck_classCallCheck(this, StateManager);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.select = void 0;
      _this.state = {
        inputValue: _this.props.inputValue !== undefined ? _this.props.inputValue : _this.props.defaultInputValue,
        menuIsOpen: _this.props.menuIsOpen !== undefined ? _this.props.menuIsOpen : _this.props.defaultMenuIsOpen,
        value: _this.props.value !== undefined ? _this.props.value : _this.props.defaultValue
      };

      _this.onChange = function (value, actionMeta) {
        _this.callProp('onChange', value, actionMeta);

        _this.setState({
          value: value
        });
      };

      _this.onInputChange = function (value, actionMeta) {
        // TODO: for backwards compatibility, we allow the prop to return a new
        // value, but now inputValue is a controllable prop we probably shouldn't
        var newValue = _this.callProp('onInputChange', value, actionMeta);

        _this.setState({
          inputValue: newValue !== undefined ? newValue : value
        });
      };

      _this.onMenuOpen = function () {
        _this.callProp('onMenuOpen');

        _this.setState({
          menuIsOpen: true
        });
      };

      _this.onMenuClose = function () {
        _this.callProp('onMenuClose');

        _this.setState({
          menuIsOpen: false
        });
      };

      return _this;
    }

    createClass_createClass(StateManager, [{
      key: "focus",
      value: function focus() {
        this.select.focus();
      }
    }, {
      key: "blur",
      value: function blur() {
        this.select.blur();
      } // FIXME: untyped flow code, return any

    }, {
      key: "getProp",
      value: function getProp(key) {
        return this.props[key] !== undefined ? this.props[key] : this.state[key];
      } // FIXME: untyped flow code, return any

    }, {
      key: "callProp",
      value: function callProp(name) {
        if (typeof this.props[name] === 'function') {
          var _this$props;

          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          return (_this$props = this.props)[name].apply(_this$props, args);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props2 = this.props;
        _this$props2.defaultInputValue;
        _this$props2.defaultMenuIsOpen;
        _this$props2.defaultValue;

        var props = _objectWithoutProperties(_this$props2, ["defaultInputValue", "defaultMenuIsOpen", "defaultValue"]);

        return /*#__PURE__*/compat_module["default"].createElement(SelectComponent, _extends({}, props, {
          ref: function ref(_ref) {
            _this2.select = _ref;
          },
          inputValue: this.getProp('inputValue'),
          menuIsOpen: this.getProp('menuIsOpen'),
          onChange: this.onChange,
          onInputChange: this.onInputChange,
          onMenuClose: this.onMenuClose,
          onMenuOpen: this.onMenuOpen,
          value: this.getProp('value')
        }));
      }
    }]);

    return StateManager;
  }(compat_module["Component"]), _class.defaultProps = stateManager_845a3300_esm_defaultProps, _temp;
};


// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(78);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var objectWithoutProperties = __webpack_require__(83);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js
var taggedTemplateLiteral = __webpack_require__(85);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(86);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(87);

// CONCATENATED MODULE: ./node_modules/react-select/dist/react-select.esm.js





















var react_select_esm_NonceProvider = /*#__PURE__*/function (_Component) {
  inherits_inherits(NonceProvider, _Component);

  var _super = index_4bd03571_esm_createSuper(NonceProvider);

  function NonceProvider(props) {
    var _this;

    classCallCheck_classCallCheck(this, NonceProvider);

    _this = _super.call(this, props);

    _this.createEmotionCache = function (nonce, key) {
      return emotion_cache_browser_esm({
        nonce: nonce,
        key: key
      });
    };

    _this.createEmotionCache = memoize_one_esm(_this.createEmotionCache);
    return _this;
  }

  createClass_createClass(NonceProvider, [{
    key: "render",
    value: function render() {
      var emotionCache = this.createEmotionCache(this.props.nonce, this.props.cacheKey);
      return /*#__PURE__*/compat_module["default"].createElement(CacheProvider, {
        value: emotionCache
      }, this.props.children);
    }
  }]);

  return NonceProvider;
}(compat_module["Component"]);

var react_select_esm_index = stateManager_845a3300_esm_manageState(Select_dbb12e54_esm_Select);
/* harmony default export */ var react_select_esm = (react_select_esm_index);

// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/editor/widgets/comment/PurposeSelect.jsx


var PURPOSES = [{
  'value': 'assessing',
  'label': 'Assessing'
}, {
  'value': 'bookmarking',
  'label': 'Bookmarking'
}, {
  'value': 'classifying',
  'label': 'Classifying'
}, {
  'value': 'commenting',
  'label': 'Commenting'
}, {
  'value': 'describing',
  'label': 'Describing'
}, {
  'value': 'editing',
  'label': 'Editing'
}, {
  'value': 'highlighting',
  'label': 'Highlighting'
}, {
  'value': 'identifying',
  'label': 'Identifying'
}, {
  'value': 'linking',
  'label': 'Linking'
}, {
  'value': 'moderating',
  'label': 'Moderating'
}, {
  'value': 'questioning',
  'label': 'Questioning'
}, {
  'value': 'replying',
  'label': 'Replying'
}];

var PurposeSelect_PurposeSelect = function PurposeSelect(props) {
  var selectedOption = props.content ? PURPOSES.find(function (p) {
    return p.value === props.content;
  }) : null;
  return /*#__PURE__*/compat_module["default"].createElement("div", {
    className: "r6o-purposedropdown"
  }, /*#__PURE__*/compat_module["default"].createElement(react_select_esm, {
    value: selectedOption,
    onChange: props.onChange,
    options: PURPOSES,
    isDisabled: !props.editable
  }));
};

/* harmony default export */ var comment_PurposeSelect = (PurposeSelect_PurposeSelect);
// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/Icons.jsx

/**
 * Icon from IcoFont https://icofont.com/, licensed under the CC BY 4.0 license.
 */

var Icons_ChevronDownIcon = function ChevronDownIcon(props) {
  return /*#__PURE__*/compat_module["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1000 940",
    width: props.width
  }, /*#__PURE__*/compat_module["default"].createElement("metadata", null, "IcoFont Icons"), /*#__PURE__*/compat_module["default"].createElement("title", null, "simple-down"), /*#__PURE__*/compat_module["default"].createElement("glyph", {
    glyphName: "simple-down",
    unicode: "\uEAB2",
    horizAdvX: "1000"
  }), /*#__PURE__*/compat_module["default"].createElement("path", {
    fill: "currentColor",
    d: "M200 392.6l300 300 300-300-85.10000000000002-85.10000000000002-214.89999999999998 214.79999999999995-214.89999999999998-214.89999999999998-85.10000000000002 85.20000000000005z"
  }));
};
/**
 * Icon from IcoFont https://icofont.com/, licensed under the CC BY 4.0 license.
 */

var Icons_CloseIcon = function CloseIcon(props) {
  return /*#__PURE__*/compat_module["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "180 150 700 800",
    width: props.width
  }, /*#__PURE__*/compat_module["default"].createElement("metadata", null, "IcoFont Icons"), /*#__PURE__*/compat_module["default"].createElement("title", null, "close"), /*#__PURE__*/compat_module["default"].createElement("glyph", {
    glyphName: "close",
    unicode: "\uEEE4",
    horizAdvX: "1000"
  }), /*#__PURE__*/compat_module["default"].createElement("path", {
    fill: "currentColor",
    d: "M709.8 206.6c-64.39999999999998 65.50000000000003-128.89999999999998 131.20000000000002-194.19999999999993 197.6-8.600000000000023 8.699999999999989-22.400000000000034 8.800000000000011-31 0-65-66-129.70000000000005-131.8-194.5-197.6-8.600000000000023-8.699999999999989-22.400000000000034-8.599999999999994-30.900000000000034 0.09999999999999432-15.699999999999989 16.200000000000017-31.099999999999994 32.30000000000001-47.099999999999994 48.80000000000001-8.5 8.800000000000011-8.299999999999983 23 0.20000000000001705 31.69999999999999 63.099999999999966 64.19999999999999 127.89999999999998 130.10000000000002 193.59999999999997 197 8.600000000000023 8.699999999999989 8.5 22.80000000000001 0 31.599999999999966-65.19999999999999 66.40000000000009-130.2 132.5-194.7 198.10000000000002-8.5 8.700000000000045-8.5 22.800000000000068 0.20000000000001705 31.399999999999977l47.79999999999998 47.90000000000009c8.600000000000023 8.599999999999909 22.600000000000023 8.599999999999909 31.100000000000023-0.10000000000002274l194.2-197.30000000000007c8.600000000000023-8.699999999999932 22.399999999999977-8.699999999999932 31 0 64.70000000000005 65.80000000000007 129.20000000000005 131.4000000000001 194.20000000000005 197.5 8.599999999999909 8.700000000000045 22.5 8.800000000000068 31 0.10000000000002274 16-16.199999999999932 31.699999999999932-32.19999999999993 47.59999999999991-48.299999999999955 8.600000000000023-8.700000000000045 8.600000000000023-22.899999999999977 0.10000000000002274-31.600000000000023-63.799999999999955-65-128.5-130.89999999999998-194.19999999999993-197.79999999999995-8.600000000000023-8.700000000000045-8.600000000000023-22.900000000000034 0-31.600000000000023 65.19999999999993-66.40000000000003 130.0999999999999-132.5 194.5-198.20000000000005 8.599999999999909-8.699999999999989 8.5-22.799999999999955-0.10000000000002274-31.49999999999997l-47.80000000000007-48.099999999999994c-8.5-8.5-22.399999999999977-8.400000000000006-31 0.29999999999998295z"
  }));
};
/**
 * Icon from IcoFont https://icofont.com/, licensed under the CC BY 4.0 license.
 */

var Icons_CheckIcon = function CheckIcon(props) {
  return /*#__PURE__*/compat_module["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 980 980",
    width: props.width
  }, /*#__PURE__*/compat_module["default"].createElement("metadata", null, "IcoFont Icons"), /*#__PURE__*/compat_module["default"].createElement("title", null, "verification-check"), /*#__PURE__*/compat_module["default"].createElement("glyph", {
    glyphName: "verification-check",
    unicode: "\uF021",
    horizAdvX: "1000"
  }), /*#__PURE__*/compat_module["default"].createElement("path", {
    fill: "currentColor",
    d: "M792.9 162.8c-133.19999999999993 126.69999999999999-264.9 251.89999999999998-397.29999999999995 377.8-8.800000000000011 8.299999999999955-22.600000000000023 8-31-0.8000000000000682l-139.50000000000003-146.89999999999998c-8.299999999999983-8.799999999999955-22.5-9.399999999999977-31.599999999999994-1.5-41.19999999999999 36-82 71.70000000000005-123.7 108.20000000000005-9.099999999999994 8-9.899999999999999 21.699999999999932-1.7999999999999972 30.600000000000023 92.9 102.19999999999993 185 203.5 277.7 305.4 8.100000000000023 8.899999999999977 21.900000000000034 9.5 30.80000000000001 1.2999999999999545 185.29999999999995-172.39999999999998 369.29999999999995-343.7 553.8-515.3 8.900000000000091-8.200000000000045 9.600000000000023-22.30000000000001 1.7000000000000455-31.5-36.700000000000045-42.400000000000034-72.70000000000005-84.00000000000003-108.89999999999998-125.80000000000001-7.899999999999977-9.100000000000023-21.399999999999977-9.800000000000011-30.200000000000045-1.5z"
  }));
};
/**
 * Icon from FontAwesome https://fontawesome.com/icons/trash-alt, 
 * licensed under the CC BY 4.0 license https://fontawesome.com/license
 */

var Icons_TrashIcon = function TrashIcon(props) {
  return /*#__PURE__*/compat_module["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 448 512",
    width: props.width
  }, /*#__PURE__*/compat_module["default"].createElement("path", {
    fill: "currentColor",
    d: "M268 416h24a12 12 0 0 0 12-12V188a12 12 0 0 0-12-12h-24a12 12 0 0 0-12 12v216a12 12 0 0 0 12 12zM432 80h-82.41l-34-56.7A48 48 0 0 0 274.41 0H173.59a48 48 0 0 0-41.16 23.3L98.41 80H16A16 16 0 0 0 0 96v16a16 16 0 0 0 16 16h16v336a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V128h16a16 16 0 0 0 16-16V96a16 16 0 0 0-16-16zM171.84 50.91A6 6 0 0 1 177 48h94a6 6 0 0 1 5.15 2.91L293.61 80H154.39zM368 464H80V128h288zm-212-48h24a12 12 0 0 0 12-12V188a12 12 0 0 0-12-12h-24a12 12 0 0 0-12 12v216a12 12 0 0 0 12 12z"
  }));
};
// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/editor/widgets/comment/Comment.jsx
function Comment_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Comment_ownKeys(Object(source), true).forEach(function (key) { Comment_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Comment_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Comment_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || Comment_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function Comment_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Comment_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Comment_arrayLikeToArray(o, minLen); }

function Comment_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }








/** A single comment inside the CommentWidget **/

var Comment_Comment = function Comment(props) {
  var _useState = Object(compat_module["useState"])(false),
      _useState2 = _slicedToArray(_useState, 2),
      isEditable = _useState2[0],
      setIsEditable = _useState2[1];

  var _useState3 = Object(compat_module["useState"])(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isMenuVisible = _useState4[0],
      setIsMenuVisible = _useState4[1];

  var onMakeEditable = function onMakeEditable(_) {
    setIsEditable(true);
    setIsMenuVisible(false);
  };

  var onDelete = function onDelete(_) {
    props.onDelete(props.body);
    setIsMenuVisible(false);
  };

  var onUpdateComment = function onUpdateComment(evt) {
    return props.onUpdate(props.body, _objectSpread(_objectSpread({}, props.body), {}, {
      value: evt.target.value
    }));
  };

  var onChangePurpose = function onChangePurpose(evt) {
    return props.onUpdate(props.body, _objectSpread(_objectSpread({}, props.body), {}, {
      purpose: evt.value
    }));
  };

  var timestamp = props.body.modified || props.body.created;
  var creatorInfo = props.body.creator && /*#__PURE__*/compat_module["default"].createElement("div", {
    className: "r6o-lastmodified"
  }, /*#__PURE__*/compat_module["default"].createElement("span", {
    className: "r6o-lastmodified-by"
  }, props.body.creator.name || props.body.creator.id), props.body.created && /*#__PURE__*/compat_module["default"].createElement("span", {
    className: "r6o-lastmodified-at"
  }, /*#__PURE__*/compat_module["default"].createElement(timeago_react, {
    datetime: props.env.toClientTime(timestamp),
    locale: src_i18n.locale()
  })));
  return props.readOnly ? /*#__PURE__*/compat_module["default"].createElement("div", {
    className: "r6o-widget comment"
  }, /*#__PURE__*/compat_module["default"].createElement("div", {
    className: "r6o-readonly-comment"
  }, props.body.value), creatorInfo) : /*#__PURE__*/compat_module["default"].createElement("div", {
    className: isEditable ? "r6o-widget comment editable" : "r6o-widget comment"
  }, /*#__PURE__*/compat_module["default"].createElement(TextEntryField_TextEntryField, {
    editable: isEditable,
    content: props.body.value,
    onChange: onUpdateComment,
    onSaveAndClose: props.onSaveAndClose
  }), !isEditable && creatorInfo, props.purposeSelector && /*#__PURE__*/compat_module["default"].createElement(comment_PurposeSelect, {
    editable: isEditable,
    content: props.body.purpose,
    onChange: onChangePurpose,
    onSaveAndClose: props.onSaveAndClose
  }), /*#__PURE__*/compat_module["default"].createElement("div", {
    className: isMenuVisible ? "r6o-icon r6o-arrow-down r6o-nodrag r6o-menu-open" : "r6o-icon r6o-arrow-down r6o-nodrag",
    onClick: function onClick() {
      return setIsMenuVisible(!isMenuVisible);
    }
  }, /*#__PURE__*/compat_module["default"].createElement(Icons_ChevronDownIcon, {
    width: 12
  })), isMenuVisible && /*#__PURE__*/compat_module["default"].createElement(comment_DropdownMenu, {
    onEdit: onMakeEditable,
    onDelete: onDelete,
    onClickOutside: function onClickOutside() {
      return setIsMenuVisible(false);
    }
  }));
};

/* harmony default export */ var comment_Comment = (Comment_Comment);
// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/editor/widgets/comment/CommentWidget.jsx
function CommentWidget_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function CommentWidget_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CommentWidget_ownKeys(Object(source), true).forEach(function (key) { CommentWidget_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CommentWidget_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function CommentWidget_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var validPurposes = PURPOSES.map(function (p) {
  return p.value;
});
/**
 * Comments are TextualBodies where the purpose field is either 
 * blank or 'commenting' or 'replying'
 */

var isComment = function isComment(body, matchAllPurposes) {
  var hasMatchingPurpose = matchAllPurposes ? validPurposes.indexOf(body.purpose) > -1 : body.purpose == 'commenting' || body.purpose == 'replying';
  return body.type === 'TextualBody' && (!body.hasOwnProperty('purpose') || hasMatchingPurpose);
};
/** 
/* A comment should be read-only if:
/* - the global read-only flag is set
/* - the current rule is 'MINE_ONLY' and the creator ID differs 
/* The 'editable' config flag overrides the global setting, if any
*/


var isReadOnlyComment = function isReadOnlyComment(body, props) {
  if (props.editable === true) return false;
  if (props.editable === false) return true;

  if (props.editable === 'MINE_ONLY') {
    var _body$creator, _props$env$user;

    // The original creator of the body
    var creator = (_body$creator = body.creator) === null || _body$creator === void 0 ? void 0 : _body$creator.id; // The current user

    var me = (_props$env$user = props.env.user) === null || _props$env$user === void 0 ? void 0 : _props$env$user.id;
    return me !== creator;
  } // Global setting as last possible option


  return props.readOnly;
};
/**
 * The draft reply is a comment body with a 'draft' flag
 */


var getDraftReply = function getDraftReply(existingDraft, isReply) {
  var purpose = isReply ? 'replying' : 'commenting';
  return existingDraft ? existingDraft : {
    type: 'TextualBody',
    value: '',
    purpose: purpose,
    draft: true
  };
};
/** 
 * Renders a list of comment bodies, followed by a 'reply' field.
 */


var CommentWidget_CommentWidget = function CommentWidget(props) {
  // All comments
  var all = props.annotation ? props.annotation.bodies.filter(function (body) {
    return isComment(body, props.purposeSelector);
  }) : []; // Add a draft reply if there isn't one already

  var draftReply = getDraftReply(all.find(function (b) {
    return b.draft == true;
  }), all.length > 1); // All except draft reply

  var comments = all.filter(function (b) {
    return b != draftReply;
  });

  var onEditReply = function onEditReply(evt) {
    var prev = draftReply.value;
    var updated = evt.target.value;

    if (prev.length === 0 && updated.length > 0) {
      props.onAppendBody(CommentWidget_objectSpread(CommentWidget_objectSpread({}, draftReply), {}, {
        value: updated
      }));
    } else if (prev.length > 0 && updated.length === 0) {
      props.onRemoveBody(draftReply);
    } else {
      props.onUpdateBody(draftReply, CommentWidget_objectSpread(CommentWidget_objectSpread({}, draftReply), {}, {
        value: updated
      }));
    }
  };

  var onChangeReplyPurpose = function onChangeReplyPurpose(purpose) {
    return props.onUpdateBody(draftReply, CommentWidget_objectSpread(CommentWidget_objectSpread({}, draftReply), {}, {
      purpose: purpose.value
    }));
  };

  return /*#__PURE__*/compat_module["default"].createElement(compat_module["default"].Fragment, null, comments.map(function (body, idx) {
    return /*#__PURE__*/compat_module["default"].createElement(comment_Comment, {
      key: idx,
      env: props.env,
      purposeSelector: props.purposeSelector,
      readOnly: isReadOnlyComment(body, props),
      body: body,
      onUpdate: props.onUpdateBody,
      onDelete: props.onRemoveBody,
      onSaveAndClose: props.onSaveAndClose
    });
  }), !props.readOnly && props.annotation && /*#__PURE__*/compat_module["default"].createElement("div", {
    className: "r6o-widget comment editable"
  }, /*#__PURE__*/compat_module["default"].createElement(TextEntryField_TextEntryField, {
    focus: props.focus,
    content: draftReply.value,
    editable: true,
    placeholder: comments.length > 0 ? src_i18n.t('Add a reply...') : src_i18n.t('Add a comment...'),
    onChange: onEditReply,
    onSaveAndClose: function onSaveAndClose() {
      return props.onSaveAndClose();
    }
  }), props.purposeSelector && draftReply.value.length > 0 && /*#__PURE__*/compat_module["default"].createElement(comment_PurposeSelect, {
    editable: true,
    content: draftReply.purpose,
    onChange: onChangeReplyPurpose,
    onSaveAndClose: function onSaveAndClose() {
      return props.onSaveAndClose();
    }
  })));
};

CommentWidget_CommentWidget.disableDelete = function (annotation, props) {
  var commentBodies = annotation.bodies.filter(function (body) {
    return isComment(body, props.purposeSelector);
  });
  return commentBodies.some(function (comment) {
    return isReadOnlyComment(comment, props);
  });
};

/* harmony default export */ var comment_CommentWidget = (CommentWidget_CommentWidget);
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  setPrototypeOf_setPrototypeOf(subClass, superClass);
}
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(1);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/hasClass.js
/**
 * Checks if a given element has a CSS class.
 * 
 * @param element the element
 * @param className the CSS class name
 */
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/addClass.js

/**
 * Adds a CSS class to a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */

function addClass_addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
}
// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/removeClass.js
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
/**
 * Removes a CSS class from a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */


function removeClass_removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === 'string') {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  }
}
// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/config.js
/* harmony default export */ var esm_config = ({
  disabled: false
});
// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/TransitionGroupContext.js

/* harmony default export */ var TransitionGroupContext = (/*#__PURE__*/compat_module["default"].createContext(null));
// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/Transition.js








var UNMOUNTED = 'unmounted';
var EXITED = 'exited';
var ENTERING = 'entering';
var ENTERED = 'entered';
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */

var Transition_Transition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props["in"]) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref["in"];

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  } // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }
  ;

  var _proto = Transition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props["in"]) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter; // TODO: remove fallback for next major

      appear = timeout.appear !== undefined ? timeout.appear : enter;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;

    var _ref2 = this.props.nodeRef ? [appearing] : [compat_module["default"].findDOMNode(this), appearing],
        maybeNode = _ref2[0],
        maybeAppearing = _ref2[1];

    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter || esm_config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }

    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(maybeNode, maybeAppearing);

      _this2.onTransitionEnd(enterTimeout, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };

  _proto.performExit = function performExit() {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? undefined : compat_module["default"].findDOMNode(this); // no exit animation skip right to EXITED

    if (!exit || esm_config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(maybeNode);
      });
      return;
    }

    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(maybeNode);

      _this3.onTransitionEnd(timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : compat_module["default"].findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }

    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
          maybeNode = _ref3[0],
          maybeNextCallback = _ref3[1];

      this.props.addEndListener(maybeNode, maybeNextCallback);
    }

    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children,
        _in = _this$props["in"],
        _mountOnEnter = _this$props.mountOnEnter,
        _unmountOnExit = _this$props.unmountOnExit,
        _appear = _this$props.appear,
        _enter = _this$props.enter,
        _exit = _this$props.exit,
        _timeout = _this$props.timeout,
        _addEndListener = _this$props.addEndListener,
        _onEnter = _this$props.onEnter,
        _onEntering = _this$props.onEntering,
        _onEntered = _this$props.onEntered,
        _onExit = _this$props.onExit,
        _onExiting = _this$props.onExiting,
        _onExited = _this$props.onExited,
        _nodeRef = _this$props.nodeRef,
        childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

    return (
      /*#__PURE__*/
      // allows for nested Transitions
      compat_module["default"].createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === 'function' ? children(status, childProps) : /*#__PURE__*/compat_module["default"].cloneElement(compat_module["default"].Children.only(children), childProps))
    );
  };

  return Transition;
}(compat_module["default"].Component);

Transition_Transition.contextType = TransitionGroupContext;
Transition_Transition.propTypes =  false ? undefined : {}; // Name the function so it is clearer in the documentation

function Transition_noop() {}

Transition_Transition.defaultProps = {
  "in": false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: Transition_noop,
  onEntering: Transition_noop,
  onEntered: Transition_noop,
  onExit: Transition_noop,
  onExiting: Transition_noop,
  onExited: Transition_noop
};
Transition_Transition.UNMOUNTED = UNMOUNTED;
Transition_Transition.EXITED = EXITED;
Transition_Transition.ENTERING = ENTERING;
Transition_Transition.ENTERED = ENTERED;
Transition_Transition.EXITING = EXITING;
/* harmony default export */ var esm_Transition = (Transition_Transition);
// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/CSSTransition.js










var _addClass = function addClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return addClass_addClass(node, c);
  });
};

var CSSTransition_removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return removeClass_removeClass(node, c);
  });
};
/**
 * A transition component inspired by the excellent
 * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
 * use it if you're using CSS transitions or animations. It's built upon the
 * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
 * component, so it inherits all of its props.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` states of the transition. The first class is applied and then a
 * second `*-active` class in order to activate the CSS transition. After the
 * transition, matching `*-done` class names are applied to persist the
 * transition state.
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
 *         <div>
 *           {"I'll receive my-node-* classes"}
 *         </div>
 *       </CSSTransition>
 *       <button type="button" onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the `in` prop is set to `true`, the child component will first receive
 * the class `example-enter`, then the `example-enter-active` will be added in
 * the next tick. `CSSTransition` [forces a
 * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * between before adding the `example-enter-active`. This is an important trick
 * because it allows us to transition between `example-enter` and
 * `example-enter-active` even though they were added immediately one after
 * another. Most notably, this is what makes it possible for us to animate
 * _appearance_.
 *
 * ```css
 * .my-node-enter {
 *   opacity: 0;
 * }
 * .my-node-enter-active {
 *   opacity: 1;
 *   transition: opacity 200ms;
 * }
 * .my-node-exit {
 *   opacity: 1;
 * }
 * .my-node-exit-active {
 *   opacity: 0;
 *   transition: opacity 200ms;
 * }
 * ```
 *
 * `*-active` classes represent which styles you want to animate **to**, so it's
 * important to add `transition` declaration only to them, otherwise transitions
 * might not behave as intended! This might not be obvious when the transitions
 * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
 * the example above (minus `transition`), but it becomes apparent in more
 * complex transitions.
 *
 * **Note**: If you're using the
 * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
 * prop, make sure to define styles for `.appear-*` classes as well.
 */


var CSSTransition_CSSTransition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };

    _this.onEnter = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument[0],
          appearing = _this$resolveArgument[1];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };

    _this.onEntering = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument2[0],
          appearing = _this$resolveArgument2[1];

      var type = appearing ? 'appear' : 'enter';

      _this.addClass(node, type, 'active');

      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };

    _this.onEntered = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument3[0],
          appearing = _this$resolveArgument3[1];

      var type = appearing ? 'appear' : 'enter';

      _this.removeClasses(node, type);

      _this.addClass(node, type, 'done');

      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };

    _this.onExit = function (maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument4[0];

      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      _this.addClass(node, 'exit', 'base');

      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };

    _this.onExiting = function (maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument5[0];

      _this.addClass(node, 'exit', 'active');

      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };

    _this.onExited = function (maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument6[0];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, 'exit', 'done');

      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };

    _this.resolveArguments = function (maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`
      : [maybeNode, maybeAppearing];
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === 'string';
      var prefix = isStringClassNames && classNames ? classNames + "-" : '';
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName: baseClassName,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.addClass = function addClass(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];

    var _this$getClassNames = this.getClassNames('enter'),
        doneClassName = _this$getClassNames.doneClassName;

    if (type === 'appear' && phase === 'done' && doneClassName) {
      className += " " + doneClassName;
    } // This is to force a repaint,
    // which is necessary in order to transition styles when adding a class name.


    if (phase === 'active') {
      /* eslint-disable no-unused-expressions */
      node && node.scrollTop;
    }

    if (className) {
      this.appliedClasses[type][phase] = className;

      _addClass(node, className);
    }
  };

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type],
        baseClassName = _this$appliedClasses$.base,
        activeClassName = _this$appliedClasses$.active,
        doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};

    if (baseClassName) {
      CSSTransition_removeClass(node, baseClassName);
    }

    if (activeClassName) {
      CSSTransition_removeClass(node, activeClassName);
    }

    if (doneClassName) {
      CSSTransition_removeClass(node, doneClassName);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        _ = _this$props.classNames,
        props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);

    return /*#__PURE__*/compat_module["default"].createElement(esm_Transition, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(compat_module["default"].Component);

CSSTransition_CSSTransition.defaultProps = {
  classNames: ''
};
CSSTransition_CSSTransition.propTypes =  false ? undefined : {};
/* harmony default export */ var esm_CSSTransition = (CSSTransition_CSSTransition);
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function assertThisInitialized_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
// EXTERNAL MODULE: ./node_modules/react-is/index.js
var react_is = __webpack_require__(11);

// CONCATENATED MODULE: ./node_modules/compute-scroll-into-view/dist/index.module.js
function index_module_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { index_module_typeof = function _typeof(obj) { return typeof obj; }; } else { index_module_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return index_module_typeof(obj); }

function index_module_t(t) {
  return "object" == index_module_typeof(t) && null != t && 1 === t.nodeType;
}

function index_module_e(t, e) {
  return (!e || "hidden" !== t) && "visible" !== t && "clip" !== t;
}

function index_module_n(t, n) {
  if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
    var r = getComputedStyle(t, null);
    return index_module_e(r.overflowY, n) || index_module_e(r.overflowX, n) || function (t) {
      var e = function (t) {
        if (!t.ownerDocument || !t.ownerDocument.defaultView) return null;

        try {
          return t.ownerDocument.defaultView.frameElement;
        } catch (t) {
          return null;
        }
      }(t);

      return !!e && (e.clientHeight < t.scrollHeight || e.clientWidth < t.scrollWidth);
    }(t);
  }

  return !1;
}

function index_module_r(t, e, n, r, i, o, l, d) {
  return o < t && l > e || o > t && l < e ? 0 : o <= t && d <= n || l >= e && d >= n ? o - t - r : l > e && d < n || o < t && d > n ? l - e + i : 0;
}

/* harmony default export */ var index_module = (function (e, i) {
  var o = window,
      l = i.scrollMode,
      d = i.block,
      u = i.inline,
      h = i.boundary,
      a = i.skipOverflowHiddenElements,
      c = "function" == typeof h ? h : function (t) {
    return t !== h;
  };
  if (!index_module_t(e)) throw new TypeError("Invalid target");

  for (var f = document.scrollingElement || document.documentElement, s = [], p = e; index_module_t(p) && c(p);) {
    if ((p = p.parentElement) === f) {
      s.push(p);
      break;
    }

    null != p && p === document.body && index_module_n(p) && !index_module_n(document.documentElement) || null != p && index_module_n(p, a) && s.push(p);
  }

  for (var m = o.visualViewport ? o.visualViewport.width : innerWidth, g = o.visualViewport ? o.visualViewport.height : innerHeight, w = window.scrollX || pageXOffset, v = window.scrollY || pageYOffset, W = e.getBoundingClientRect(), b = W.height, H = W.width, y = W.top, E = W.right, M = W.bottom, V = W.left, x = "start" === d || "nearest" === d ? y : "end" === d ? M : y + b / 2, I = "center" === u ? V + H / 2 : "end" === u ? E : V, C = [], T = 0; T < s.length; T++) {
    var k = s[T],
        B = k.getBoundingClientRect(),
        D = B.height,
        O = B.width,
        R = B.top,
        X = B.right,
        Y = B.bottom,
        L = B.left;
    if ("if-needed" === l && y >= 0 && V >= 0 && M <= g && E <= m && y >= R && M <= Y && V >= L && E <= X) return C;
    var S = getComputedStyle(k),
        j = parseInt(S.borderLeftWidth, 10),
        q = parseInt(S.borderTopWidth, 10),
        z = parseInt(S.borderRightWidth, 10),
        A = parseInt(S.borderBottomWidth, 10),
        F = 0,
        G = 0,
        J = "offsetWidth" in k ? k.offsetWidth - k.clientWidth - j - z : 0,
        K = "offsetHeight" in k ? k.offsetHeight - k.clientHeight - q - A : 0;
    if (f === k) F = "start" === d ? x : "end" === d ? x - g : "nearest" === d ? index_module_r(v, v + g, g, q, A, v + x, v + x + b, b) : x - g / 2, G = "start" === u ? I : "center" === u ? I - m / 2 : "end" === u ? I - m : index_module_r(w, w + m, m, j, z, w + I, w + I + H, H), F = Math.max(0, F + v), G = Math.max(0, G + w);else {
      F = "start" === d ? x - R - q : "end" === d ? x - Y + A + K : "nearest" === d ? index_module_r(R, Y, D, q, A + K, x, x + b, b) : x - (R + D / 2) + K / 2, G = "start" === u ? I - L - j : "center" === u ? I - (L + O / 2) + J / 2 : "end" === u ? I - X + z + J : index_module_r(L, X, O, j, z + J, I, I + H, H);
      var N = k.scrollLeft,
          P = k.scrollTop;
      x += P - (F = Math.max(0, Math.min(P + F, k.scrollHeight - D + K))), I += N - (G = Math.max(0, Math.min(N + G, k.scrollWidth - O + J)));
    }
    C.push({
      el: k,
      top: F,
      left: G
    });
  }

  return C;
});
// CONCATENATED MODULE: ./node_modules/downshift/dist/downshift.esm.js








var idCounter = 0;
/**
 * Accepts a parameter and returns it if it's a function
 * or a noop function if it's not. This allows us to
 * accept a callback, but not worry about it if it's not
 * passed.
 * @param {Function} cb the callback
 * @return {Function} a function
 */

function cbToCb(cb) {
  return typeof cb === 'function' ? cb : downshift_esm_noop;
}

function downshift_esm_noop() {}
/**
 * Scroll node into view if necessary
 * @param {HTMLElement} node the element that should scroll into view
 * @param {HTMLElement} menuNode the menu element of the component
 */


function downshift_esm_scrollIntoView(node, menuNode) {
  if (!node) {
    return;
  }

  var actions = index_module(node, {
    boundary: menuNode,
    block: 'nearest',
    scrollMode: 'if-needed'
  });
  actions.forEach(function (_ref) {
    var el = _ref.el,
        top = _ref.top,
        left = _ref.left;
    el.scrollTop = top;
    el.scrollLeft = left;
  });
}
/**
 * @param {HTMLElement} parent the parent node
 * @param {HTMLElement} child the child node
 * @param {Window} environment The window context where downshift renders.
 * @return {Boolean} whether the parent is the child or the child is in the parent
 */


function isOrContainsNode(parent, child, environment) {
  var result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);
  return result;
}
/**
 * Simple debounce implementation. Will call the given
 * function once after the time given has passed since
 * it was last called.
 * @param {Function} fn the function to call after the time
 * @param {Number} time the time to wait
 * @return {Function} the debounced function
 */


function debounce(fn, time) {
  var timeoutId;

  function cancel() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  }

  function wrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    cancel();
    timeoutId = setTimeout(function () {
      timeoutId = null;
      fn.apply(void 0, args);
    }, time);
  }

  wrapper.cancel = cancel;
  return wrapper;
}
/**
 * This is intended to be used to compose event handlers.
 * They are executed in order until one of them sets
 * `event.preventDownshiftDefault = true`.
 * @param {...Function} fns the event handler functions
 * @return {Function} the event handler to add to an element
 */


function callAllEventHandlers() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }

  return function (event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }

    return fns.some(function (fn) {
      if (fn) {
        fn.apply(void 0, [event].concat(args));
      }

      return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;
    });
  };
}

function handleRefs() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }

  return function (node) {
    refs.forEach(function (ref) {
      if (typeof ref === 'function') {
        ref(node);
      } else if (ref) {
        ref.current = node;
      }
    });
  };
}
/**
 * This generates a unique ID for an instance of Downshift
 * @return {String} the unique ID
 */


function generateId() {
  return String(idCounter++);
}
/**
 * Resets idCounter to 0. Used for SSR.
 */


function resetIdCounter() {
  idCounter = 0;
}
/**
 * Default implementation for status message. Only added when menu is open.
 * Will specift if there are results in the list, and if so, how many,
 * and what keys are relevant.
 *
 * @param {Object} param the downshift state and other relevant properties
 * @return {String} the a11y status message
 */


function getA11yStatusMessage$1(_ref2) {
  var isOpen = _ref2.isOpen,
      resultCount = _ref2.resultCount,
      previousResultCount = _ref2.previousResultCount;

  if (!isOpen) {
    return '';
  }

  if (!resultCount) {
    return 'No results are available.';
  }

  if (resultCount !== previousResultCount) {
    return resultCount + " result" + (resultCount === 1 ? ' is' : 's are') + " available, use up and down arrow keys to navigate. Press Enter key to select.";
  }

  return '';
}
/**
 * Takes an argument and if it's an array, returns the first item in the array
 * otherwise returns the argument
 * @param {*} arg the maybe-array
 * @param {*} defaultValue the value if arg is falsey not defined
 * @return {*} the arg or it's first item
 */


function unwrapArray(arg, defaultValue) {
  arg = Array.isArray(arg) ?
  /* istanbul ignore next (preact) */
  arg[0] : arg;

  if (!arg && defaultValue) {
    return defaultValue;
  } else {
    return arg;
  }
}
/**
 * @param {Object} element (P)react element
 * @return {Boolean} whether it's a DOM element
 */


function isDOMElement(element) {
  return typeof element.type === 'string';
}
/**
 * @param {Object} element (P)react element
 * @return {Object} the props
 */


function getElementProps(element) {
  return element.props;
}
/**
 * Throws a helpful error message for required properties. Useful
 * to be used as a default in destructuring or object params.
 * @param {String} fnName the function name
 * @param {String} propName the prop name
 */


function requiredProp(fnName, propName) {
  // eslint-disable-next-line no-console
  console.error("The property \"" + propName + "\" is required in \"" + fnName + "\"");
}

var stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];
/**
 * @param {Object} state the state object
 * @return {Object} state that is relevant to downshift
 */

function pickState(state) {
  if (state === void 0) {
    state = {};
  }

  var result = {};
  stateKeys.forEach(function (k) {
    if (state.hasOwnProperty(k)) {
      result[k] = state[k];
    }
  });
  return result;
}
/**
 * This will perform a shallow merge of the given state object
 * with the state coming from props
 * (for the controlled component scenario)
 * This is used in state updater functions so they're referencing
 * the right state regardless of where it comes from.
 *
 * @param {Object} state The state of the component/hook.
 * @param {Object} props The props that may contain controlled values.
 * @returns {Object} The merged controlled state.
 */


function getState(state, props) {
  return Object.keys(state).reduce(function (prevState, key) {
    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
    return prevState;
  }, {});
}
/**
 * This determines whether a prop is a "controlled prop" meaning it is
 * state which is controlled by the outside of this component rather
 * than within this component.
 *
 * @param {Object} props The props that may contain controlled values.
 * @param {String} key the key to check
 * @return {Boolean} whether it is a controlled controlled prop
 */


function isControlledProp(props, key) {
  return props[key] !== undefined;
}
/**
 * Normalizes the 'key' property of a KeyboardEvent in IE/Edge
 * @param {Object} event a keyboardEvent object
 * @return {String} keyboard key
 */


function normalizeArrowKey(event) {
  var key = event.key,
      keyCode = event.keyCode;
  /* istanbul ignore next (ie) */

  if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {
    return "Arrow" + key;
  }

  return key;
}
/**
 * Simple check if the value passed is object literal
 * @param {*} obj any things
 * @return {Boolean} whether it's object literal
 */


function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}
/**
 * Returns the new index in the list, in a circular way. If next value is out of bonds from the total,
 * it will wrap to either 0 or itemCount - 1.
 *
 * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.
 * @param {number} baseIndex The initial position to move from.
 * @param {number} itemCount The total number of items.
 * @param {Function} getItemNodeFromIndex Used to check if item is disabled.
 * @param {boolean} circular Specify if navigation is circular. Default is true.
 * @returns {number} The new index after the move.
 */


function getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
  if (circular === void 0) {
    circular = true;
  }

  if (itemCount === 0) {
    return -1;
  }

  var itemsLastIndex = itemCount - 1;

  if (typeof baseIndex !== 'number' || baseIndex < 0 || baseIndex >= itemCount) {
    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
  }

  var newIndex = baseIndex + moveAmount;

  if (newIndex < 0) {
    newIndex = circular ? itemsLastIndex : 0;
  } else if (newIndex > itemsLastIndex) {
    newIndex = circular ? 0 : itemsLastIndex;
  }

  var nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);

  if (nonDisabledNewIndex === -1) {
    return baseIndex >= itemCount ? -1 : baseIndex;
  }

  return nonDisabledNewIndex;
}
/**
 * Returns the next index in the list of an item that is not disabled.
 *
 * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.
 * @param {number} baseIndex The initial position to move from.
 * @param {number} itemCount The total number of items.
 * @param {Function} getItemNodeFromIndex Used to check if item is disabled.
 * @param {boolean} circular Specify if navigation is circular. Default is true.
 * @returns {number} The new index. Returns baseIndex if item is not disabled. Returns next non-disabled item otherwise. If no non-disabled found it will return -1.
 */


function getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
  var currentElementNode = getItemNodeFromIndex(baseIndex);

  if (!currentElementNode || !currentElementNode.hasAttribute('disabled')) {
    return baseIndex;
  }

  if (moveAmount > 0) {
    for (var index = baseIndex + 1; index < itemCount; index++) {
      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {
        return index;
      }
    }
  } else {
    for (var _index = baseIndex - 1; _index >= 0; _index--) {
      if (!getItemNodeFromIndex(_index).hasAttribute('disabled')) {
        return _index;
      }
    }
  }

  if (circular) {
    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);
  }

  return -1;
}
/**
 * Checks if event target is within the downshift elements.
 *
 * @param {EventTarget} target Target to check.
 * @param {HTMLElement[]} downshiftElements The elements that form downshift (list, toggle button etc).
 * @param {Window} environment The window context where downshift renders.
 * @param {boolean} checkActiveElement Whether to also check activeElement.
 *
 * @returns {boolean} Whether or not the target is within downshift elements.
 */


function targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {
  if (checkActiveElement === void 0) {
    checkActiveElement = true;
  }

  return downshiftElements.some(function (contextNode) {
    return contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment));
  });
} // eslint-disable-next-line import/no-mutable-exports


var validateControlledUnchanged = downshift_esm_noop;
/* istanbul ignore next */

if (false) {}

var cleanupStatus = debounce(function (documentProp) {
  getStatusDiv(documentProp).textContent = '';
}, 500);
/**
 * @param {String} status the status message
 * @param {Object} documentProp document passed by the user.
 */

function setStatus(status, documentProp) {
  var div = getStatusDiv(documentProp);

  if (!status) {
    return;
  }

  div.textContent = status;
  cleanupStatus(documentProp);
}
/**
 * Get the status node or create it if it does not already exist.
 * @param {Object} documentProp document passed by the user.
 * @return {HTMLElement} the status node.
 */


function getStatusDiv(documentProp) {
  if (documentProp === void 0) {
    documentProp = document;
  }

  var statusDiv = documentProp.getElementById('a11y-status-message');

  if (statusDiv) {
    return statusDiv;
  }

  statusDiv = documentProp.createElement('div');
  statusDiv.setAttribute('id', 'a11y-status-message');
  statusDiv.setAttribute('role', 'status');
  statusDiv.setAttribute('aria-live', 'polite');
  statusDiv.setAttribute('aria-relevant', 'additions text');
  Object.assign(statusDiv.style, {
    border: '0',
    clip: 'rect(0 0 0 0)',
    height: '1px',
    margin: '-1px',
    overflow: 'hidden',
    padding: '0',
    position: 'absolute',
    width: '1px'
  });
  documentProp.body.appendChild(statusDiv);
  return statusDiv;
}

var unknown =  false ? undefined : 0;
var mouseUp =  false ? undefined : 1;
var itemMouseEnter =  false ? undefined : 2;
var keyDownArrowUp =  false ? undefined : 3;
var keyDownArrowDown =  false ? undefined : 4;
var keyDownEscape =  false ? undefined : 5;
var keyDownEnter =  false ? undefined : 6;
var keyDownHome =  false ? undefined : 7;
var keyDownEnd =  false ? undefined : 8;
var clickItem =  false ? undefined : 9;
var blurInput =  false ? undefined : 10;
var changeInput =  false ? undefined : 11;
var keyDownSpaceButton =  false ? undefined : 12;
var clickButton =  false ? undefined : 13;
var blurButton =  false ? undefined : 14;
var controlledPropUpdatedSelectedItem =  false ? undefined : 15;
var touchEnd =  false ? undefined : 16;
var stateChangeTypes$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unknown: unknown,
  mouseUp: mouseUp,
  itemMouseEnter: itemMouseEnter,
  keyDownArrowUp: keyDownArrowUp,
  keyDownArrowDown: keyDownArrowDown,
  keyDownEscape: keyDownEscape,
  keyDownEnter: keyDownEnter,
  keyDownHome: keyDownHome,
  keyDownEnd: keyDownEnd,
  clickItem: clickItem,
  blurInput: blurInput,
  changeInput: changeInput,
  keyDownSpaceButton: keyDownSpaceButton,
  clickButton: clickButton,
  blurButton: blurButton,
  controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,
  touchEnd: touchEnd
});

var downshift_esm_Downshift = /*#__PURE__*/function () {
  var Downshift = /*#__PURE__*/function (_Component) {
    _inheritsLoose(Downshift, _Component);

    function Downshift(_props) {
      var _this;

      _this = _Component.call(this, _props) || this; // fancy destructuring + defaults + aliases
      // this basically says each value of state should either be set to
      // the initial value or the default value if the initial value is not provided

      _this.id = _this.props.id || "downshift-" + generateId();
      _this.menuId = _this.props.menuId || _this.id + "-menu";
      _this.labelId = _this.props.labelId || _this.id + "-label";
      _this.inputId = _this.props.inputId || _this.id + "-input";

      _this.getItemId = _this.props.getItemId || function (index) {
        return _this.id + "-item-" + index;
      };

      _this.input = null;
      _this.items = [];
      _this.itemCount = null;
      _this.previousResultCount = 0;
      _this.timeoutIds = [];

      _this.internalSetTimeout = function (fn, time) {
        var id = setTimeout(function () {
          _this.timeoutIds = _this.timeoutIds.filter(function (i) {
            return i !== id;
          });
          fn();
        }, time);

        _this.timeoutIds.push(id);
      };

      _this.setItemCount = function (count) {
        _this.itemCount = count;
      };

      _this.unsetItemCount = function () {
        _this.itemCount = null;
      };

      _this.setHighlightedIndex = function (highlightedIndex, otherStateToSet) {
        if (highlightedIndex === void 0) {
          highlightedIndex = _this.props.defaultHighlightedIndex;
        }

        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }

        otherStateToSet = pickState(otherStateToSet);

        _this.internalSetState(_extends({
          highlightedIndex: highlightedIndex
        }, otherStateToSet));
      };

      _this.clearSelection = function (cb) {
        _this.internalSetState({
          selectedItem: null,
          inputValue: '',
          highlightedIndex: _this.props.defaultHighlightedIndex,
          isOpen: _this.props.defaultIsOpen
        }, cb);
      };

      _this.selectItem = function (item, otherStateToSet, cb) {
        otherStateToSet = pickState(otherStateToSet);

        _this.internalSetState(_extends({
          isOpen: _this.props.defaultIsOpen,
          highlightedIndex: _this.props.defaultHighlightedIndex,
          selectedItem: item,
          inputValue: _this.props.itemToString(item)
        }, otherStateToSet), cb);
      };

      _this.selectItemAtIndex = function (itemIndex, otherStateToSet, cb) {
        var item = _this.items[itemIndex];

        if (item == null) {
          return;
        }

        _this.selectItem(item, otherStateToSet, cb);
      };

      _this.selectHighlightedItem = function (otherStateToSet, cb) {
        return _this.selectItemAtIndex(_this.getState().highlightedIndex, otherStateToSet, cb);
      };

      _this.internalSetState = function (stateToSet, cb) {
        var isItemSelected, onChangeArg;
        var onStateChangeArg = {};
        var isStateToSetFunction = typeof stateToSet === 'function'; // we want to call `onInputValueChange` before the `setState` call
        // so someone controlling the `inputValue` state gets notified of
        // the input change as soon as possible. This avoids issues with
        // preserving the cursor position.
        // See https://github.com/downshift-js/downshift/issues/217 for more info.

        if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {
          _this.props.onInputValueChange(stateToSet.inputValue, _extends({}, _this.getStateAndHelpers(), stateToSet));
        }

        return _this.setState(function (state) {
          state = _this.getState(state);
          var newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet; // Your own function that could modify the state that will be set.

          newStateToSet = _this.props.stateReducer(state, newStateToSet); // checks if an item is selected, regardless of if it's different from
          // what was selected before
          // used to determine if onSelect and onChange callbacks should be called

          isItemSelected = newStateToSet.hasOwnProperty('selectedItem'); // this keeps track of the object we want to call with setState

          var nextState = {}; // this is just used to tell whether the state changed
          // and we're trying to update that state. OR if the selection has changed and we're
          // trying to update the selection

          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {
            onChangeArg = newStateToSet.selectedItem;
          }

          newStateToSet.type = newStateToSet.type || unknown;
          Object.keys(newStateToSet).forEach(function (key) {
            // onStateChangeArg should only have the state that is
            // actually changing
            if (state[key] !== newStateToSet[key]) {
              onStateChangeArg[key] = newStateToSet[key];
            } // the type is useful for the onStateChangeArg
            // but we don't actually want to set it in internal state.
            // this is an undocumented feature for now... Not all internalSetState
            // calls support it and I'm not certain we want them to yet.
            // But it enables users controlling the isOpen state to know when
            // the isOpen state changes due to mouseup events which is quite handy.


            if (key === 'type') {
              return;
            }

            newStateToSet[key]; // if it's coming from props, then we don't care to set it internally

            if (!isControlledProp(_this.props, key)) {
              nextState[key] = newStateToSet[key];
            }
          }); // if stateToSet is a function, then we weren't able to call onInputValueChange
          // earlier, so we'll call it now that we know what the inputValue state will be.

          if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {
            _this.props.onInputValueChange(newStateToSet.inputValue, _extends({}, _this.getStateAndHelpers(), newStateToSet));
          }

          return nextState;
        }, function () {
          // call the provided callback if it's a function
          cbToCb(cb)(); // only call the onStateChange and onChange callbacks if
          // we have relevant information to pass them.

          var hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;

          if (hasMoreStateThanType) {
            _this.props.onStateChange(onStateChangeArg, _this.getStateAndHelpers());
          }

          if (isItemSelected) {
            _this.props.onSelect(stateToSet.selectedItem, _this.getStateAndHelpers());
          }

          if (onChangeArg !== undefined) {
            _this.props.onChange(onChangeArg, _this.getStateAndHelpers());
          } // this is currently undocumented and therefore subject to change
          // We'll try to not break it, but just be warned.


          _this.props.onUserAction(onStateChangeArg, _this.getStateAndHelpers());
        });
      };

      _this.rootRef = function (node) {
        return _this._rootNode = node;
      };

      _this.getRootProps = function (_temp, _temp2) {
        var _extends2;

        var _ref = _temp === void 0 ? {} : _temp,
            _ref$refKey = _ref.refKey,
            refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,
            ref = _ref.ref,
            rest = _objectWithoutPropertiesLoose(_ref, ["refKey", "ref"]);

        var _ref2 = _temp2 === void 0 ? {} : _temp2,
            _ref2$suppressRefErro = _ref2.suppressRefError,
            suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro; // this is used in the render to know whether the user has called getRootProps.
        // It uses that to know whether to apply the props automatically


        _this.getRootProps.called = true;
        _this.getRootProps.refKey = refKey;
        _this.getRootProps.suppressRefError = suppressRefError;

        var _this$getState = _this.getState(),
            isOpen = _this$getState.isOpen;

        return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref, _this.rootRef), _extends2.role = 'combobox', _extends2['aria-expanded'] = isOpen, _extends2['aria-haspopup'] = 'listbox', _extends2['aria-owns'] = isOpen ? _this.menuId : null, _extends2['aria-labelledby'] = _this.labelId, _extends2), rest);
      };

      _this.keyDownHandlers = {
        ArrowDown: function ArrowDown(event) {
          var _this2 = this;

          event.preventDefault();

          if (this.getState().isOpen) {
            var amount = event.shiftKey ? 5 : 1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowDown
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowDown
            }, function () {
              var itemCount = _this2.getItemCount();

              if (itemCount > 0) {
                var _this2$getState = _this2.getState(),
                    highlightedIndex = _this2$getState.highlightedIndex;

                var nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, function (index) {
                  return _this2.getItemNodeFromIndex(index);
                });

                _this2.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowDown
                });
              }
            });
          }
        },
        ArrowUp: function ArrowUp(event) {
          var _this3 = this;

          event.preventDefault();

          if (this.getState().isOpen) {
            var amount = event.shiftKey ? -5 : -1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowUp
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowUp
            }, function () {
              var itemCount = _this3.getItemCount();

              if (itemCount > 0) {
                var _this3$getState = _this3.getState(),
                    highlightedIndex = _this3$getState.highlightedIndex;

                var nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, function (index) {
                  return _this3.getItemNodeFromIndex(index);
                });

                _this3.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowUp
                });
              }
            });
          }
        },
        Enter: function Enter(event) {
          if (event.which === 229) {
            return;
          }

          var _this$getState2 = this.getState(),
              isOpen = _this$getState2.isOpen,
              highlightedIndex = _this$getState2.highlightedIndex;

          if (isOpen && highlightedIndex != null) {
            event.preventDefault();
            var item = this.items[highlightedIndex];
            var itemNode = this.getItemNodeFromIndex(highlightedIndex);

            if (item == null || itemNode && itemNode.hasAttribute('disabled')) {
              return;
            }

            this.selectHighlightedItem({
              type: keyDownEnter
            });
          }
        },
        Escape: function Escape(event) {
          event.preventDefault();
          this.reset(_extends({
            type: keyDownEscape
          }, !this.state.isOpen && {
            selectedItem: null,
            inputValue: ''
          }));
        }
      };
      _this.buttonKeyDownHandlers = _extends({}, _this.keyDownHandlers, {
        ' ': function _(event) {
          event.preventDefault();
          this.toggleMenu({
            type: keyDownSpaceButton
          });
        }
      });
      _this.inputKeyDownHandlers = _extends({}, _this.keyDownHandlers, {
        Home: function Home(event) {
          var _this4 = this;

          var _this$getState3 = this.getState(),
              isOpen = _this$getState3.isOpen;

          if (!isOpen) {
            return;
          }

          event.preventDefault();
          var itemCount = this.getItemCount();

          if (itemCount <= 0 || !isOpen) {
            return;
          } // get next non-disabled starting downwards from 0 if that's disabled.


          var newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, function (index) {
            return _this4.getItemNodeFromIndex(index);
          }, false);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownHome
          });
        },
        End: function End(event) {
          var _this5 = this;

          var _this$getState4 = this.getState(),
              isOpen = _this$getState4.isOpen;

          if (!isOpen) {
            return;
          }

          event.preventDefault();
          var itemCount = this.getItemCount();

          if (itemCount <= 0 || !isOpen) {
            return;
          } // get next non-disabled starting upwards from last index if that's disabled.


          var newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, function (index) {
            return _this5.getItemNodeFromIndex(index);
          }, false);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownEnd
          });
        }
      });

      _this.getToggleButtonProps = function (_temp3) {
        var _ref3 = _temp3 === void 0 ? {} : _temp3,
            onClick = _ref3.onClick;

        _ref3.onPress;

        var onKeyDown = _ref3.onKeyDown,
            onKeyUp = _ref3.onKeyUp,
            onBlur = _ref3.onBlur,
            rest = _objectWithoutPropertiesLoose(_ref3, ["onClick", "onPress", "onKeyDown", "onKeyUp", "onBlur"]);

        var _this$getState5 = _this.getState(),
            isOpen = _this$getState5.isOpen;

        var enabledEventHandlers = {
          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),
          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),
          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),
          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)
        };
        var eventHandlers = rest.disabled ? {} : enabledEventHandlers;
        return _extends({
          type: 'button',
          role: 'button',
          'aria-label': isOpen ? 'close menu' : 'open menu',
          'aria-haspopup': true,
          'data-toggle': true
        }, eventHandlers, rest);
      };

      _this.buttonHandleKeyUp = function (event) {
        // Prevent click event from emitting in Firefox
        event.preventDefault();
      };

      _this.buttonHandleKeyDown = function (event) {
        var key = normalizeArrowKey(event);

        if (_this.buttonKeyDownHandlers[key]) {
          _this.buttonKeyDownHandlers[key].call(assertThisInitialized_assertThisInitialized(_this), event);
        }
      };

      _this.buttonHandleClick = function (event) {
        event.preventDefault(); // handle odd case for Safari and Firefox which
        // don't give the button the focus properly.

        /* istanbul ignore if (can't reasonably test this) */

        if (_this.props.environment.document.activeElement === _this.props.environment.document.body) {
          event.target.focus();
        } // to simplify testing components that use downshift, we'll not wrap this in a setTimeout
        // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated
        // when building for production and should therefore have no impact on production code.


        if (false) {} else {
          // Ensure that toggle of menu occurs after the potential blur event in iOS
          _this.internalSetTimeout(function () {
            return _this.toggleMenu({
              type: clickButton
            });
          });
        }
      };

      _this.buttonHandleBlur = function (event) {
        var blurTarget = event.target; // Save blur target for comparison with activeElement later
        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element

        _this.internalSetTimeout(function () {
          if (!_this.isMouseDown && (_this.props.environment.document.activeElement == null || _this.props.environment.document.activeElement.id !== _this.inputId) && _this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)
          ) {
              _this.reset({
                type: blurButton
              });
            }
        });
      };

      _this.getLabelProps = function (props) {
        return _extends({
          htmlFor: _this.inputId,
          id: _this.labelId
        }, props);
      };

      _this.getInputProps = function (_temp4) {
        var _ref4 = _temp4 === void 0 ? {} : _temp4,
            onKeyDown = _ref4.onKeyDown,
            onBlur = _ref4.onBlur,
            onChange = _ref4.onChange,
            onInput = _ref4.onInput;

        _ref4.onChangeText;

        var rest = _objectWithoutPropertiesLoose(_ref4, ["onKeyDown", "onBlur", "onChange", "onInput", "onChangeText"]);

        var onChangeKey;
        var eventHandlers = {};
        /* istanbul ignore next (preact) */

        {
          onChangeKey = 'onChange';
        }

        var _this$getState6 = _this.getState(),
            inputValue = _this$getState6.inputValue,
            isOpen = _this$getState6.isOpen,
            highlightedIndex = _this$getState6.highlightedIndex;

        if (!rest.disabled) {
          var _eventHandlers;

          eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, _this.inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, _this.inputHandleBlur), _eventHandlers);
        }

        return _extends({
          'aria-autocomplete': 'list',
          'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,
          'aria-controls': isOpen ? _this.menuId : null,
          'aria-labelledby': _this.labelId,
          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
          // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
          autoComplete: 'off',
          value: inputValue,
          id: _this.inputId
        }, eventHandlers, rest);
      };

      _this.inputHandleKeyDown = function (event) {
        var key = normalizeArrowKey(event);

        if (key && _this.inputKeyDownHandlers[key]) {
          _this.inputKeyDownHandlers[key].call(assertThisInitialized_assertThisInitialized(_this), event);
        }
      };

      _this.inputHandleChange = function (event) {
        _this.internalSetState({
          type: changeInput,
          isOpen: true,
          inputValue: event.target.value,
          highlightedIndex: _this.props.defaultHighlightedIndex
        });
      };

      _this.inputHandleBlur = function () {
        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element
        _this.internalSetTimeout(function () {
          var downshiftButtonIsActive = _this.props.environment.document && !!_this.props.environment.document.activeElement && !!_this.props.environment.document.activeElement.dataset && _this.props.environment.document.activeElement.dataset.toggle && _this._rootNode && _this._rootNode.contains(_this.props.environment.document.activeElement);

          if (!_this.isMouseDown && !downshiftButtonIsActive) {
            _this.reset({
              type: blurInput
            });
          }
        });
      };

      _this.menuRef = function (node) {
        _this._menuNode = node;
      };

      _this.getMenuProps = function (_temp5, _temp6) {
        var _extends3;

        var _ref5 = _temp5 === void 0 ? {} : _temp5,
            _ref5$refKey = _ref5.refKey,
            refKey = _ref5$refKey === void 0 ? 'ref' : _ref5$refKey,
            ref = _ref5.ref,
            props = _objectWithoutPropertiesLoose(_ref5, ["refKey", "ref"]);

        var _ref6 = _temp6 === void 0 ? {} : _temp6,
            _ref6$suppressRefErro = _ref6.suppressRefError,
            suppressRefError = _ref6$suppressRefErro === void 0 ? false : _ref6$suppressRefErro;

        _this.getMenuProps.called = true;
        _this.getMenuProps.refKey = refKey;
        _this.getMenuProps.suppressRefError = suppressRefError;
        return _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref, _this.menuRef), _extends3.role = 'listbox', _extends3['aria-labelledby'] = props && props['aria-label'] ? null : _this.labelId, _extends3.id = _this.menuId, _extends3), props);
      };

      _this.getItemProps = function (_temp7) {
        var _enabledEventHandlers;

        var _ref7 = _temp7 === void 0 ? {} : _temp7,
            onMouseMove = _ref7.onMouseMove,
            onMouseDown = _ref7.onMouseDown,
            onClick = _ref7.onClick;

        _ref7.onPress;

        var index = _ref7.index,
            _ref7$item = _ref7.item,
            item = _ref7$item === void 0 ?  true ?
        /* istanbul ignore next */
        undefined : undefined : _ref7$item,
            rest = _objectWithoutPropertiesLoose(_ref7, ["onMouseMove", "onMouseDown", "onClick", "onPress", "index", "item"]);

        if (index === undefined) {
          _this.items.push(item);

          index = _this.items.indexOf(item);
        } else {
          _this.items[index] = item;
        }

        var onSelectKey = 'onClick';
        var customClickHandler = onClick;
        var enabledEventHandlers = (_enabledEventHandlers = {
          // onMouseMove is used over onMouseEnter here. onMouseMove
          // is only triggered on actual mouse movement while onMouseEnter
          // can fire on DOM changes, interrupting keyboard navigation
          onMouseMove: callAllEventHandlers(onMouseMove, function () {
            if (index === _this.getState().highlightedIndex) {
              return;
            }

            _this.setHighlightedIndex(index, {
              type: itemMouseEnter
            }); // We never want to manually scroll when changing state based
            // on `onMouseMove` because we will be moving the element out
            // from under the user which is currently scrolling/moving the
            // cursor


            _this.avoidScrolling = true;

            _this.internalSetTimeout(function () {
              return _this.avoidScrolling = false;
            }, 250);
          }),
          onMouseDown: callAllEventHandlers(onMouseDown, function (event) {
            // This prevents the activeElement from being changed
            // to the item so it can remain with the current activeElement
            // which is a more common use case.
            event.preventDefault();
          })
        }, _enabledEventHandlers[onSelectKey] = callAllEventHandlers(customClickHandler, function () {
          _this.selectItemAtIndex(index, {
            type: clickItem
          });
        }), _enabledEventHandlers); // Passing down the onMouseDown handler to prevent redirect
        // of the activeElement if clicking on disabled items

        var eventHandlers = rest.disabled ? {
          onMouseDown: enabledEventHandlers.onMouseDown
        } : enabledEventHandlers;
        return _extends({
          id: _this.getItemId(index),
          role: 'option',
          'aria-selected': _this.getState().highlightedIndex === index
        }, eventHandlers, rest);
      };

      _this.clearItems = function () {
        _this.items = [];
      };

      _this.reset = function (otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }

        otherStateToSet = pickState(otherStateToSet);

        _this.internalSetState(function (_ref8) {
          var selectedItem = _ref8.selectedItem;
          return _extends({
            isOpen: _this.props.defaultIsOpen,
            highlightedIndex: _this.props.defaultHighlightedIndex,
            inputValue: _this.props.itemToString(selectedItem)
          }, otherStateToSet);
        }, cb);
      };

      _this.toggleMenu = function (otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }

        otherStateToSet = pickState(otherStateToSet);

        _this.internalSetState(function (_ref9) {
          var isOpen = _ref9.isOpen;
          return _extends({
            isOpen: !isOpen
          }, isOpen && {
            highlightedIndex: _this.props.defaultHighlightedIndex
          }, otherStateToSet);
        }, function () {
          var _this$getState7 = _this.getState(),
              isOpen = _this$getState7.isOpen,
              highlightedIndex = _this$getState7.highlightedIndex;

          if (isOpen) {
            if (_this.getItemCount() > 0 && typeof highlightedIndex === 'number') {
              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);
            }
          }

          cbToCb(cb)();
        });
      };

      _this.openMenu = function (cb) {
        _this.internalSetState({
          isOpen: true
        }, cb);
      };

      _this.closeMenu = function (cb) {
        _this.internalSetState({
          isOpen: false
        }, cb);
      };

      _this.updateStatus = debounce(function () {
        var state = _this.getState();

        var item = _this.items[state.highlightedIndex];

        var resultCount = _this.getItemCount();

        var status = _this.props.getA11yStatusMessage(_extends({
          itemToString: _this.props.itemToString,
          previousResultCount: _this.previousResultCount,
          resultCount: resultCount,
          highlightedItem: item
        }, state));

        _this.previousResultCount = resultCount;
        setStatus(status, _this.props.environment.document);
      }, 200);

      var _this$props = _this.props,
          defaultHighlightedIndex = _this$props.defaultHighlightedIndex,
          _this$props$initialHi = _this$props.initialHighlightedIndex,
          _highlightedIndex = _this$props$initialHi === void 0 ? defaultHighlightedIndex : _this$props$initialHi,
          defaultIsOpen = _this$props.defaultIsOpen,
          _this$props$initialIs = _this$props.initialIsOpen,
          _isOpen = _this$props$initialIs === void 0 ? defaultIsOpen : _this$props$initialIs,
          _this$props$initialIn = _this$props.initialInputValue,
          _inputValue = _this$props$initialIn === void 0 ? '' : _this$props$initialIn,
          _this$props$initialSe = _this$props.initialSelectedItem,
          _selectedItem = _this$props$initialSe === void 0 ? null : _this$props$initialSe;

      var _state = _this.getState({
        highlightedIndex: _highlightedIndex,
        isOpen: _isOpen,
        inputValue: _inputValue,
        selectedItem: _selectedItem
      });

      if (_state.selectedItem != null && _this.props.initialInputValue === undefined) {
        _state.inputValue = _this.props.itemToString(_state.selectedItem);
      }

      _this.state = _state;
      return _this;
    }

    var _proto = Downshift.prototype;
    /**
     * Clear all running timeouts
     */

    _proto.internalClearTimeouts = function internalClearTimeouts() {
      this.timeoutIds.forEach(function (id) {
        clearTimeout(id);
      });
      this.timeoutIds = [];
    }
    /**
     * Gets the state based on internal state or props
     * If a state value is passed via props, then that
     * is the value given, otherwise it's retrieved from
     * stateToMerge
     *
     * @param {Object} stateToMerge defaults to this.state
     * @return {Object} the state
     */
    ;

    _proto.getState = function getState$1(stateToMerge) {
      if (stateToMerge === void 0) {
        stateToMerge = this.state;
      }

      return getState(stateToMerge, this.props);
    };

    _proto.getItemCount = function getItemCount() {
      // things read better this way. They're in priority order:
      // 1. `this.itemCount`
      // 2. `this.props.itemCount`
      // 3. `this.items.length`
      var itemCount = this.items.length;

      if (this.itemCount != null) {
        itemCount = this.itemCount;
      } else if (this.props.itemCount !== undefined) {
        itemCount = this.props.itemCount;
      }

      return itemCount;
    };

    _proto.getItemNodeFromIndex = function getItemNodeFromIndex(index) {
      return this.props.environment.document.getElementById(this.getItemId(index));
    };

    _proto.scrollHighlightedItemIntoView = function scrollHighlightedItemIntoView() {
      /* istanbul ignore else (react-native) */
      {
        var node = this.getItemNodeFromIndex(this.getState().highlightedIndex);
        this.props.scrollIntoView(node, this._menuNode);
      }
    };

    _proto.moveHighlightedIndex = function moveHighlightedIndex(amount, otherStateToSet) {
      var _this6 = this;

      var itemCount = this.getItemCount();

      var _this$getState8 = this.getState(),
          highlightedIndex = _this$getState8.highlightedIndex;

      if (itemCount > 0) {
        var nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, function (index) {
          return _this6.getItemNodeFromIndex(index);
        });
        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);
      }
    };

    _proto.getStateAndHelpers = function getStateAndHelpers() {
      var _this$getState9 = this.getState(),
          highlightedIndex = _this$getState9.highlightedIndex,
          inputValue = _this$getState9.inputValue,
          selectedItem = _this$getState9.selectedItem,
          isOpen = _this$getState9.isOpen;

      var itemToString = this.props.itemToString;
      var id = this.id;
      var getRootProps = this.getRootProps,
          getToggleButtonProps = this.getToggleButtonProps,
          getLabelProps = this.getLabelProps,
          getMenuProps = this.getMenuProps,
          getInputProps = this.getInputProps,
          getItemProps = this.getItemProps,
          openMenu = this.openMenu,
          closeMenu = this.closeMenu,
          toggleMenu = this.toggleMenu,
          selectItem = this.selectItem,
          selectItemAtIndex = this.selectItemAtIndex,
          selectHighlightedItem = this.selectHighlightedItem,
          setHighlightedIndex = this.setHighlightedIndex,
          clearSelection = this.clearSelection,
          clearItems = this.clearItems,
          reset = this.reset,
          setItemCount = this.setItemCount,
          unsetItemCount = this.unsetItemCount,
          setState = this.internalSetState;
      return {
        // prop getters
        getRootProps: getRootProps,
        getToggleButtonProps: getToggleButtonProps,
        getLabelProps: getLabelProps,
        getMenuProps: getMenuProps,
        getInputProps: getInputProps,
        getItemProps: getItemProps,
        // actions
        reset: reset,
        openMenu: openMenu,
        closeMenu: closeMenu,
        toggleMenu: toggleMenu,
        selectItem: selectItem,
        selectItemAtIndex: selectItemAtIndex,
        selectHighlightedItem: selectHighlightedItem,
        setHighlightedIndex: setHighlightedIndex,
        clearSelection: clearSelection,
        clearItems: clearItems,
        setItemCount: setItemCount,
        unsetItemCount: unsetItemCount,
        setState: setState,
        // props
        itemToString: itemToString,
        // derived
        id: id,
        // state
        highlightedIndex: highlightedIndex,
        inputValue: inputValue,
        isOpen: isOpen,
        selectedItem: selectedItem
      };
    } //////////////////////////// ROOT
    ;

    _proto.componentDidMount = function componentDidMount() {
      var _this7 = this;
      /* istanbul ignore if (react-native) */


      if (false) {}
      /* istanbul ignore if (react-native) */


      {
        // this.isMouseDown helps us track whether the mouse is currently held down.
        // This is useful when the user clicks on an item in the list, but holds the mouse
        // down long enough for the list to disappear (because the blur event fires on the input)
        // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should
        // trigger hiding the menu.
        var onMouseDown = function onMouseDown() {
          _this7.isMouseDown = true;
        };

        var onMouseUp = function onMouseUp(event) {
          _this7.isMouseDown = false; // if the target element or the activeElement is within a downshift node
          // then we don't want to reset downshift

          var contextWithinDownshift = targetWithinDownshift(event.target, [_this7._rootNode, _this7._menuNode], _this7.props.environment);

          if (!contextWithinDownshift && _this7.getState().isOpen) {
            _this7.reset({
              type: mouseUp
            }, function () {
              return _this7.props.onOuterClick(_this7.getStateAndHelpers());
            });
          }
        }; // Touching an element in iOS gives focus and hover states, but touching out of
        // the element will remove hover, and persist the focus state, resulting in the
        // blur event not being triggered.
        // this.isTouchMove helps us track whether the user is tapping or swiping on a touch screen.
        // If the user taps outside of Downshift, the component should be reset,
        // but not if the user is swiping


        var onTouchStart = function onTouchStart() {
          _this7.isTouchMove = false;
        };

        var onTouchMove = function onTouchMove() {
          _this7.isTouchMove = true;
        };

        var onTouchEnd = function onTouchEnd(event) {
          var contextWithinDownshift = targetWithinDownshift(event.target, [_this7._rootNode, _this7._menuNode], _this7.props.environment, false);

          if (!_this7.isTouchMove && !contextWithinDownshift && _this7.getState().isOpen) {
            _this7.reset({
              type: touchEnd
            }, function () {
              return _this7.props.onOuterClick(_this7.getStateAndHelpers());
            });
          }
        };

        var environment = this.props.environment;
        environment.addEventListener('mousedown', onMouseDown);
        environment.addEventListener('mouseup', onMouseUp);
        environment.addEventListener('touchstart', onTouchStart);
        environment.addEventListener('touchmove', onTouchMove);
        environment.addEventListener('touchend', onTouchEnd);

        this.cleanup = function () {
          _this7.internalClearTimeouts();

          _this7.updateStatus.cancel();

          environment.removeEventListener('mousedown', onMouseDown);
          environment.removeEventListener('mouseup', onMouseUp);
          environment.removeEventListener('touchstart', onTouchStart);
          environment.removeEventListener('touchmove', onTouchMove);
          environment.removeEventListener('touchend', onTouchEnd);
        };
      }
    };

    _proto.shouldScroll = function shouldScroll(prevState, prevProps) {
      var _ref10 = this.props.highlightedIndex === undefined ? this.getState() : this.props,
          currentHighlightedIndex = _ref10.highlightedIndex;

      var _ref11 = prevProps.highlightedIndex === undefined ? prevState : prevProps,
          prevHighlightedIndex = _ref11.highlightedIndex;

      var scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;
      var scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;
      return scrollWhenOpen || scrollWhenNavigating;
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      if (false) {}

      if (isControlledProp(this.props, 'selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {
        this.internalSetState({
          type: controlledPropUpdatedSelectedItem,
          inputValue: this.props.itemToString(this.props.selectedItem)
        });
      }

      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {
        this.scrollHighlightedItemIntoView();
      }
      /* istanbul ignore else (react-native) */


      {
        this.updateStatus();
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cleanup(); // avoids memory leak
    };

    _proto.render = function render() {
      var children = unwrapArray(this.props.children, downshift_esm_noop); // because the items are rerendered every time we call the children
      // we clear this out each render and it will be populated again as
      // getItemProps is called.

      this.clearItems(); // we reset this so we know whether the user calls getRootProps during
      // this render. If they do then we don't need to do anything,
      // if they don't then we need to clone the element they return and
      // apply the props for them.

      this.getRootProps.called = false;
      this.getRootProps.refKey = undefined;
      this.getRootProps.suppressRefError = undefined; // we do something similar for getMenuProps

      this.getMenuProps.called = false;
      this.getMenuProps.refKey = undefined;
      this.getMenuProps.suppressRefError = undefined; // we do something similar for getLabelProps

      this.getLabelProps.called = false; // and something similar for getInputProps

      this.getInputProps.called = false;
      var element = unwrapArray(children(this.getStateAndHelpers()));

      if (!element) {
        return null;
      }

      if (this.getRootProps.called || this.props.suppressRefError) {
        if (false) {}

        return element;
      } else if (isDOMElement(element)) {
        // they didn't apply the root props, but we can clone
        // this and apply the props ourselves
        return /*#__PURE__*/Object(compat_module["cloneElement"])(element, this.getRootProps(getElementProps(element)));
      }
      /* istanbul ignore else */


      if (false) {}
      /* istanbul ignore next */


      return undefined;
    };

    return Downshift;
  }(compat_module["Component"]);

  Downshift.defaultProps = {
    defaultHighlightedIndex: null,
    defaultIsOpen: false,
    getA11yStatusMessage: getA11yStatusMessage$1,
    itemToString: function itemToString(i) {
      if (i == null) {
        return '';
      }

      if (false) {}

      return String(i);
    },
    onStateChange: downshift_esm_noop,
    onInputValueChange: downshift_esm_noop,
    onUserAction: downshift_esm_noop,
    onChange: downshift_esm_noop,
    onSelect: downshift_esm_noop,
    onOuterClick: downshift_esm_noop,
    selectedItemChanged: function selectedItemChanged(prevItem, item) {
      return prevItem !== item;
    },
    environment: typeof window === 'undefined'
    /* istanbul ignore next (ssr) */
    ? {} : window,
    stateReducer: function stateReducer(state, stateToSet) {
      return stateToSet;
    },
    suppressRefError: false,
    scrollIntoView: downshift_esm_scrollIntoView
  };
  Downshift.stateChangeTypes = stateChangeTypes$3;
  return Downshift;
}();

 false ? undefined : void 0;

function validateGetMenuPropsCalledCorrectly(node, _ref12) {
  var refKey = _ref12.refKey;

  if (!node) {
    // eslint-disable-next-line no-console
    console.error("downshift: The ref prop \"" + refKey + "\" from getMenuProps was not applied correctly on your menu element.");
  }
}

function validateGetRootPropsCalledCorrectly(element, _ref13) {
  var refKey = _ref13.refKey;
  var refKeySpecified = refKey !== 'ref';
  var isComposite = !isDOMElement(element);

  if (isComposite && !refKeySpecified && !Object(react_is["isForwardRef"])(element)) {
    // eslint-disable-next-line no-console
    console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');
  } else if (!isComposite && refKeySpecified) {
    // eslint-disable-next-line no-console
    console.error("downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \"" + refKey + "\"");
  }

  if (!Object(react_is["isForwardRef"])(element) && !getElementProps(element)[refKey]) {
    // eslint-disable-next-line no-console
    console.error("downshift: You must apply the ref prop \"" + refKey + "\" from getRootProps onto your root element.");
  }
}

var dropdownDefaultStateValues = {
  highlightedIndex: -1,
  isOpen: false,
  selectedItem: null,
  inputValue: ''
};

function callOnChangeProps(action, state, newState) {
  var props = action.props,
      type = action.type;
  var changes = {};
  Object.keys(state).forEach(function (key) {
    invokeOnChangeHandler(key, action, state, newState);

    if (newState[key] !== state[key]) {
      changes[key] = newState[key];
    }
  });

  if (props.onStateChange && Object.keys(changes).length) {
    props.onStateChange(_extends({
      type: type
    }, changes));
  }
}

function invokeOnChangeHandler(key, action, state, newState) {
  var props = action.props,
      type = action.type;
  var handler = "on" + capitalizeString(key) + "Change";

  if (props[handler] && newState[key] !== undefined && newState[key] !== state[key]) {
    props[handler](_extends({
      type: type
    }, newState));
  }
}
/**
 * Default state reducer that returns the changes.
 *
 * @param {Object} s state.
 * @param {Object} a action with changes.
 * @returns {Object} changes.
 */


function stateReducer(s, a) {
  return a.changes;
}
/**
 * Returns a message to be added to aria-live region when item is selected.
 *
 * @param {Object} selectionParameters Parameters required to build the message.
 * @returns {string} The a11y message.
 */


function downshift_esm_getA11ySelectionMessage(selectionParameters) {
  var selectedItem = selectionParameters.selectedItem,
      itemToStringLocal = selectionParameters.itemToString;
  return selectedItem ? itemToStringLocal(selectedItem) + " has been selected." : '';
}
/**
 * Debounced call for updating the a11y message.
 */


var updateA11yStatus = debounce(function (getA11yMessage, document) {
  setStatus(getA11yMessage(), document);
}, 200); // istanbul ignore next

var useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? compat_module["useLayoutEffect"] : compat_module["useEffect"];

function useElementIds(_ref) {
  var _ref$id = _ref.id,
      id = _ref$id === void 0 ? "downshift-" + generateId() : _ref$id,
      labelId = _ref.labelId,
      menuId = _ref.menuId,
      getItemId = _ref.getItemId,
      toggleButtonId = _ref.toggleButtonId,
      inputId = _ref.inputId;
  var elementIdsRef = Object(compat_module["useRef"])({
    labelId: labelId || id + "-label",
    menuId: menuId || id + "-menu",
    getItemId: getItemId || function (index) {
      return id + "-item-" + index;
    },
    toggleButtonId: toggleButtonId || id + "-toggle-button",
    inputId: inputId || id + "-input"
  });
  return elementIdsRef.current;
}

function getItemIndex(index, item, items) {
  if (index !== undefined) {
    return index;
  }

  if (items.length === 0) {
    return -1;
  }

  return items.indexOf(item);
}

function downshift_esm_itemToString(item) {
  return item ? String(item) : '';
}

function isAcceptedCharacterKey(key) {
  return /^\S{1}$/.test(key);
}

function capitalizeString(string) {
  return "" + string.slice(0, 1).toUpperCase() + string.slice(1);
}

function useLatestRef(val) {
  var ref = Object(compat_module["useRef"])(val); // technically this is not "concurrent mode safe" because we're manipulating
  // the value during render (so it's not idempotent). However, the places this
  // hook is used is to support memoizing callbacks which will be called
  // *during* render, so we need the latest values *during* render.
  // If not for this, then we'd probably want to use useLayoutEffect instead.

  ref.current = val;
  return ref;
}
/**
 * Computes the controlled state using a the previous state, props,
 * two reducers, one from downshift and an optional one from the user.
 * Also calls the onChange handlers for state values that have changed.
 *
 * @param {Function} reducer Reducer function from downshift.
 * @param {Object} initialState Initial state of the hook.
 * @param {Object} props The hook props.
 * @returns {Array} An array with the state and an action dispatcher.
 */


function useEnhancedReducer(reducer, initialState, props) {
  var prevStateRef = Object(compat_module["useRef"])();
  var actionRef = Object(compat_module["useRef"])();
  var enhancedReducer = Object(compat_module["useCallback"])(function (state, action) {
    actionRef.current = action;
    state = getState(state, action.props);
    var changes = reducer(state, action);
    var newState = action.props.stateReducer(state, _extends({}, action, {
      changes: changes
    }));
    return newState;
  }, [reducer]);

  var _useReducer = Object(compat_module["useReducer"])(enhancedReducer, initialState),
      state = _useReducer[0],
      dispatch = _useReducer[1];

  var propsRef = useLatestRef(props);
  var dispatchWithProps = Object(compat_module["useCallback"])(function (action) {
    return dispatch(_extends({
      props: propsRef.current
    }, action));
  }, [propsRef]);
  var action = actionRef.current;
  Object(compat_module["useEffect"])(function () {
    if (action && prevStateRef.current && prevStateRef.current !== state) {
      callOnChangeProps(action, getState(prevStateRef.current, action.props), state);
    }

    prevStateRef.current = state;
  }, [state, props, action]);
  return [state, dispatchWithProps];
}
/**
 * Wraps the useEnhancedReducer and applies the controlled prop values before
 * returning the new state.
 *
 * @param {Function} reducer Reducer function from downshift.
 * @param {Object} initialState Initial state of the hook.
 * @param {Object} props The hook props.
 * @returns {Array} An array with the state and an action dispatcher.
 */


function useControlledReducer$1(reducer, initialState, props) {
  var _useEnhancedReducer = useEnhancedReducer(reducer, initialState, props),
      state = _useEnhancedReducer[0],
      dispatch = _useEnhancedReducer[1];

  return [getState(state, props), dispatch];
}

var defaultProps$3 = {
  itemToString: downshift_esm_itemToString,
  stateReducer: stateReducer,
  getA11ySelectionMessage: downshift_esm_getA11ySelectionMessage,
  scrollIntoView: downshift_esm_scrollIntoView,
  circularNavigation: false,
  environment: typeof window === 'undefined'
  /* istanbul ignore next (ssr) */
  ? {} : window
};

function getDefaultValue$1(props, propKey, defaultStateValues) {
  if (defaultStateValues === void 0) {
    defaultStateValues = dropdownDefaultStateValues;
  }

  var defaultPropKey = "default" + capitalizeString(propKey);

  if (defaultPropKey in props) {
    return props[defaultPropKey];
  }

  return defaultStateValues[propKey];
}

function getInitialValue$1(props, propKey, defaultStateValues) {
  if (defaultStateValues === void 0) {
    defaultStateValues = dropdownDefaultStateValues;
  }

  if (propKey in props) {
    return props[propKey];
  }

  var initialPropKey = "initial" + capitalizeString(propKey);

  if (initialPropKey in props) {
    return props[initialPropKey];
  }

  return getDefaultValue$1(props, propKey, defaultStateValues);
}

function getInitialState$2(props) {
  var selectedItem = getInitialValue$1(props, 'selectedItem');
  var isOpen = getInitialValue$1(props, 'isOpen');
  var highlightedIndex = getInitialValue$1(props, 'highlightedIndex');
  var inputValue = getInitialValue$1(props, 'inputValue');
  return {
    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,
    isOpen: isOpen,
    selectedItem: selectedItem,
    inputValue: inputValue
  };
}

function getHighlightedIndexOnOpen(props, state, offset, getItemNodeFromIndex) {
  var items = props.items,
      initialHighlightedIndex = props.initialHighlightedIndex,
      defaultHighlightedIndex = props.defaultHighlightedIndex;
  var selectedItem = state.selectedItem,
      highlightedIndex = state.highlightedIndex;

  if (items.length === 0) {
    return -1;
  } // initialHighlightedIndex will give value to highlightedIndex on initial state only.


  if (initialHighlightedIndex !== undefined && highlightedIndex === initialHighlightedIndex) {
    return initialHighlightedIndex;
  }

  if (defaultHighlightedIndex !== undefined) {
    return defaultHighlightedIndex;
  }

  if (selectedItem) {
    if (offset === 0) {
      return items.indexOf(selectedItem);
    }

    return getNextWrappingIndex(offset, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);
  }

  if (offset === 0) {
    return -1;
  }

  return offset < 0 ? items.length - 1 : 0;
}
/**
 * Reuse the movement tracking of mouse and touch events.
 *
 * @param {boolean} isOpen Whether the dropdown is open or not.
 * @param {Array<Object>} downshiftElementRefs Downshift element refs to track movement (toggleButton, menu etc.)
 * @param {Object} environment Environment where component/hook exists.
 * @param {Function} handleBlur Handler on blur from mouse or touch.
 * @returns {Object} Ref containing whether mouseDown or touchMove event is happening
 */


function useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {
  var mouseAndTouchTrackersRef = Object(compat_module["useRef"])({
    isMouseDown: false,
    isTouchMove: false
  });
  Object(compat_module["useEffect"])(function () {
    // The same strategy for checking if a click occurred inside or outside downsift
    // as in downshift.js.
    var onMouseDown = function onMouseDown() {
      mouseAndTouchTrackersRef.current.isMouseDown = true;
    };

    var onMouseUp = function onMouseUp(event) {
      mouseAndTouchTrackersRef.current.isMouseDown = false;

      if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map(function (ref) {
        return ref.current;
      }), environment)) {
        handleBlur();
      }
    };

    var onTouchStart = function onTouchStart() {
      mouseAndTouchTrackersRef.current.isTouchMove = false;
    };

    var onTouchMove = function onTouchMove() {
      mouseAndTouchTrackersRef.current.isTouchMove = true;
    };

    var onTouchEnd = function onTouchEnd(event) {
      if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map(function (ref) {
        return ref.current;
      }), environment, false)) {
        handleBlur();
      }
    };

    environment.addEventListener('mousedown', onMouseDown);
    environment.addEventListener('mouseup', onMouseUp);
    environment.addEventListener('touchstart', onTouchStart);
    environment.addEventListener('touchmove', onTouchMove);
    environment.addEventListener('touchend', onTouchEnd);
    return function cleanup() {
      environment.removeEventListener('mousedown', onMouseDown);
      environment.removeEventListener('mouseup', onMouseUp);
      environment.removeEventListener('touchstart', onTouchStart);
      environment.removeEventListener('touchmove', onTouchMove);
      environment.removeEventListener('touchend', onTouchEnd);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOpen, environment]);
  return mouseAndTouchTrackersRef;
}
/* istanbul ignore next */
// eslint-disable-next-line import/no-mutable-exports


var useGetterPropsCalledChecker = function useGetterPropsCalledChecker() {
  return downshift_esm_noop;
};
/**
 * Custom hook that checks if getter props are called correctly.
 *
 * @param  {...any} propKeys Getter prop names to be handled.
 * @returns {Function} Setter function called inside getter props to set call information.
 */

/* istanbul ignore next */


if (false) {}

function useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {
  var isInitialMount = _ref2.isInitialMount,
      highlightedIndex = _ref2.highlightedIndex,
      items = _ref2.items,
      environment = _ref2.environment,
      rest = _objectWithoutPropertiesLoose(_ref2, ["isInitialMount", "highlightedIndex", "items", "environment"]); // Sets a11y status message on changes in state.


  Object(compat_module["useEffect"])(function () {
    if (isInitialMount) {
      return;
    }

    updateA11yStatus(function () {
      return getA11yMessage(_extends({
        highlightedIndex: highlightedIndex,
        highlightedItem: items[highlightedIndex],
        resultCount: items.length
      }, rest));
    }, environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, dependencyArray);
}

function useScrollIntoView(_ref3) {
  var highlightedIndex = _ref3.highlightedIndex,
      isOpen = _ref3.isOpen,
      itemRefs = _ref3.itemRefs,
      getItemNodeFromIndex = _ref3.getItemNodeFromIndex,
      menuElement = _ref3.menuElement,
      scrollIntoViewProp = _ref3.scrollIntoView; // used not to scroll on highlight by mouse.

  var shouldScrollRef = Object(compat_module["useRef"])(true); // Scroll on highlighted item if change comes from keyboard.

  useIsomorphicLayoutEffect(function () {
    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
      return;
    }

    if (shouldScrollRef.current === false) {
      shouldScrollRef.current = true;
    } else {
      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [highlightedIndex]);
  return shouldScrollRef;
} // eslint-disable-next-line import/no-mutable-exports


var useControlPropsValidator = downshift_esm_noop;
/* istanbul ignore next */

if (false) {}
/* eslint-disable complexity */


function downshiftCommonReducer(state, action, stateChangeTypes) {
  var type = action.type,
      props = action.props;
  var changes;

  switch (type) {
    case stateChangeTypes.ItemMouseMove:
      changes = {
        highlightedIndex: action.index
      };
      break;

    case stateChangeTypes.MenuMouseLeave:
      changes = {
        highlightedIndex: -1
      };
      break;

    case stateChangeTypes.ToggleButtonClick:
    case stateChangeTypes.FunctionToggleMenu:
      changes = {
        isOpen: !state.isOpen,
        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
      };
      break;

    case stateChangeTypes.FunctionOpenMenu:
      changes = {
        isOpen: true,
        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
      };
      break;

    case stateChangeTypes.FunctionCloseMenu:
      changes = {
        isOpen: false
      };
      break;

    case stateChangeTypes.FunctionSetHighlightedIndex:
      changes = {
        highlightedIndex: action.highlightedIndex
      };
      break;

    case stateChangeTypes.FunctionSetInputValue:
      changes = {
        inputValue: action.inputValue
      };
      break;

    case stateChangeTypes.FunctionReset:
      changes = {
        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),
        isOpen: getDefaultValue$1(props, 'isOpen'),
        selectedItem: getDefaultValue$1(props, 'selectedItem'),
        inputValue: getDefaultValue$1(props, 'inputValue')
      };
      break;

    default:
      throw new Error('Reducer called without proper action type.');
  }

  return _extends({}, state, changes);
}
/* eslint-enable complexity */


function getItemIndexByCharacterKey(keysSoFar, highlightedIndex, items, itemToString, getItemNodeFromIndex) {
  var lowerCasedKeysSoFar = keysSoFar.toLowerCase();

  for (var index = 0; index < items.length; index++) {
    var offsetIndex = (index + highlightedIndex + 1) % items.length;

    if (itemToString(items[offsetIndex]).toLowerCase().startsWith(lowerCasedKeysSoFar)) {
      var element = getItemNodeFromIndex(offsetIndex);

      if (!(element && element.hasAttribute('disabled'))) {
        return offsetIndex;
      }
    }
  }

  return highlightedIndex;
}

var propTypes$2 = {
  items: prop_types_default.a.array.isRequired,
  itemToString: prop_types_default.a.func,
  getA11yStatusMessage: prop_types_default.a.func,
  getA11ySelectionMessage: prop_types_default.a.func,
  circularNavigation: prop_types_default.a.bool,
  highlightedIndex: prop_types_default.a.number,
  defaultHighlightedIndex: prop_types_default.a.number,
  initialHighlightedIndex: prop_types_default.a.number,
  isOpen: prop_types_default.a.bool,
  defaultIsOpen: prop_types_default.a.bool,
  initialIsOpen: prop_types_default.a.bool,
  selectedItem: prop_types_default.a.any,
  initialSelectedItem: prop_types_default.a.any,
  defaultSelectedItem: prop_types_default.a.any,
  id: prop_types_default.a.string,
  labelId: prop_types_default.a.string,
  menuId: prop_types_default.a.string,
  getItemId: prop_types_default.a.func,
  toggleButtonId: prop_types_default.a.string,
  stateReducer: prop_types_default.a.func,
  onSelectedItemChange: prop_types_default.a.func,
  onHighlightedIndexChange: prop_types_default.a.func,
  onStateChange: prop_types_default.a.func,
  onIsOpenChange: prop_types_default.a.func,
  environment: prop_types_default.a.shape({
    addEventListener: prop_types_default.a.func,
    removeEventListener: prop_types_default.a.func,
    document: prop_types_default.a.shape({
      getElementById: prop_types_default.a.func,
      activeElement: prop_types_default.a.any,
      body: prop_types_default.a.any
    })
  })
};
/**
 * Default implementation for status message. Only added when menu is open.
 * Will specift if there are results in the list, and if so, how many,
 * and what keys are relevant.
 *
 * @param {Object} param the downshift state and other relevant properties
 * @return {String} the a11y status message
 */

function downshift_esm_getA11yStatusMessage(_ref) {
  var isOpen = _ref.isOpen,
      resultCount = _ref.resultCount,
      previousResultCount = _ref.previousResultCount;

  if (!isOpen) {
    return '';
  }

  if (!resultCount) {
    return 'No results are available.';
  }

  if (resultCount !== previousResultCount) {
    return resultCount + " result" + (resultCount === 1 ? ' is' : 's are') + " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.";
  }

  return '';
}

var defaultProps$2 = _extends({}, defaultProps$3, {
  getA11yStatusMessage: downshift_esm_getA11yStatusMessage
}); // eslint-disable-next-line import/no-mutable-exports


var validatePropTypes$2 = downshift_esm_noop;
/* istanbul ignore next */

if (false) {}

var MenuKeyDownArrowDown =  false ? undefined : 0;
var MenuKeyDownArrowUp =  false ? undefined : 1;
var MenuKeyDownEscape =  false ? undefined : 2;
var MenuKeyDownHome =  false ? undefined : 3;
var MenuKeyDownEnd =  false ? undefined : 4;
var MenuKeyDownEnter =  false ? undefined : 5;
var MenuKeyDownSpaceButton =  false ? undefined : 6;
var MenuKeyDownCharacter =  false ? undefined : 7;
var MenuBlur =  false ? undefined : 8;
var MenuMouseLeave$1 =  false ? undefined : 9;
var ItemMouseMove$1 =  false ? undefined : 10;
var ItemClick$1 =  false ? undefined : 11;
var ToggleButtonClick$1 =  false ? undefined : 12;
var ToggleButtonKeyDownArrowDown =  false ? undefined : 13;
var ToggleButtonKeyDownArrowUp =  false ? undefined : 14;
var ToggleButtonKeyDownCharacter =  false ? undefined : 15;
var FunctionToggleMenu$1 =  false ? undefined : 16;
var FunctionOpenMenu$1 =  false ? undefined : 17;
var FunctionCloseMenu$1 =  false ? undefined : 18;
var FunctionSetHighlightedIndex$1 =  false ? undefined : 19;
var FunctionSelectItem$1 =  false ? undefined : 20;
var FunctionSetInputValue$1 =  false ? undefined : 21;
var FunctionReset$2 =  false ? undefined : 22;
var stateChangeTypes$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  MenuKeyDownArrowDown: MenuKeyDownArrowDown,
  MenuKeyDownArrowUp: MenuKeyDownArrowUp,
  MenuKeyDownEscape: MenuKeyDownEscape,
  MenuKeyDownHome: MenuKeyDownHome,
  MenuKeyDownEnd: MenuKeyDownEnd,
  MenuKeyDownEnter: MenuKeyDownEnter,
  MenuKeyDownSpaceButton: MenuKeyDownSpaceButton,
  MenuKeyDownCharacter: MenuKeyDownCharacter,
  MenuBlur: MenuBlur,
  MenuMouseLeave: MenuMouseLeave$1,
  ItemMouseMove: ItemMouseMove$1,
  ItemClick: ItemClick$1,
  ToggleButtonClick: ToggleButtonClick$1,
  ToggleButtonKeyDownArrowDown: ToggleButtonKeyDownArrowDown,
  ToggleButtonKeyDownArrowUp: ToggleButtonKeyDownArrowUp,
  ToggleButtonKeyDownCharacter: ToggleButtonKeyDownCharacter,
  FunctionToggleMenu: FunctionToggleMenu$1,
  FunctionOpenMenu: FunctionOpenMenu$1,
  FunctionCloseMenu: FunctionCloseMenu$1,
  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,
  FunctionSelectItem: FunctionSelectItem$1,
  FunctionSetInputValue: FunctionSetInputValue$1,
  FunctionReset: FunctionReset$2
});
/* eslint-disable complexity */

function downshiftSelectReducer(state, action) {
  var type = action.type,
      props = action.props,
      shiftKey = action.shiftKey;
  var changes;

  switch (type) {
    case ItemClick$1:
      changes = {
        isOpen: getDefaultValue$1(props, 'isOpen'),
        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),
        selectedItem: props.items[action.index]
      };
      break;

    case ToggleButtonKeyDownCharacter:
      {
        var lowercasedKey = action.key;
        var inputValue = "" + state.inputValue + lowercasedKey;
        var itemIndex = getItemIndexByCharacterKey(inputValue, state.selectedItem ? props.items.indexOf(state.selectedItem) : -1, props.items, props.itemToString, action.getItemNodeFromIndex);
        changes = _extends({
          inputValue: inputValue
        }, itemIndex >= 0 && {
          selectedItem: props.items[itemIndex]
        });
      }
      break;

    case ToggleButtonKeyDownArrowDown:
      changes = {
        highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
        isOpen: true
      };
      break;

    case ToggleButtonKeyDownArrowUp:
      changes = {
        highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
        isOpen: true
      };
      break;

    case MenuKeyDownEnter:
    case MenuKeyDownSpaceButton:
      changes = _extends({
        isOpen: getDefaultValue$1(props, 'isOpen'),
        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex')
      }, state.highlightedIndex >= 0 && {
        selectedItem: props.items[state.highlightedIndex]
      });
      break;

    case MenuKeyDownHome:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;

    case MenuKeyDownEnd:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;

    case MenuKeyDownEscape:
      changes = {
        isOpen: false,
        highlightedIndex: -1
      };
      break;

    case MenuBlur:
      changes = {
        isOpen: false,
        highlightedIndex: -1
      };
      break;

    case MenuKeyDownCharacter:
      {
        var _lowercasedKey = action.key;

        var _inputValue = "" + state.inputValue + _lowercasedKey;

        var highlightedIndex = getItemIndexByCharacterKey(_inputValue, state.highlightedIndex, props.items, props.itemToString, action.getItemNodeFromIndex);
        changes = _extends({
          inputValue: _inputValue
        }, highlightedIndex >= 0 && {
          highlightedIndex: highlightedIndex
        });
      }
      break;

    case MenuKeyDownArrowDown:
      changes = {
        highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
      };
      break;

    case MenuKeyDownArrowUp:
      changes = {
        highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
      };
      break;

    case FunctionSelectItem$1:
      changes = {
        selectedItem: action.selectedItem
      };
      break;

    default:
      return downshiftCommonReducer(state, action, stateChangeTypes$2);
  }

  return _extends({}, state, changes);
}
/* eslint-enable complexity */


useSelect.stateChangeTypes = stateChangeTypes$2;

function useSelect(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }

  validatePropTypes$2(userProps, useSelect); // Props defaults and destructuring.

  var props = _extends({}, defaultProps$2, userProps);

  var items = props.items,
      scrollIntoView = props.scrollIntoView,
      environment = props.environment,
      initialIsOpen = props.initialIsOpen,
      defaultIsOpen = props.defaultIsOpen,
      itemToString = props.itemToString,
      getA11ySelectionMessage = props.getA11ySelectionMessage,
      getA11yStatusMessage = props.getA11yStatusMessage; // Initial state depending on controlled props.

  var initialState = getInitialState$2(props);

  var _useControlledReducer = useControlledReducer$1(downshiftSelectReducer, initialState, props),
      state = _useControlledReducer[0],
      dispatch = _useControlledReducer[1];

  var isOpen = state.isOpen,
      highlightedIndex = state.highlightedIndex,
      selectedItem = state.selectedItem,
      inputValue = state.inputValue; // Element efs.

  var toggleButtonRef = Object(compat_module["useRef"])(null);
  var menuRef = Object(compat_module["useRef"])(null);
  var itemRefs = Object(compat_module["useRef"])({}); // used not to trigger menu blur action in some scenarios.

  var shouldBlurRef = Object(compat_module["useRef"])(true); // used to keep the inputValue clearTimeout object between renders.

  var clearTimeoutRef = Object(compat_module["useRef"])(null); // prevent id re-generation between renders.

  var elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.

  var previousResultCountRef = Object(compat_module["useRef"])();
  var isInitialMountRef = Object(compat_module["useRef"])(true); // utility callback to get item element.

  var latest = useLatestRef({
    state: state,
    props: props
  }); // Some utils.

  var getItemNodeFromIndex = Object(compat_module["useCallback"])(function (index) {
    return itemRefs.current[elementIds.getItemId(index)];
  }, [elementIds]); // Effects.
  // Sets a11y status message on changes in state.

  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], _extends({
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items: items,
    environment: environment,
    itemToString: itemToString
  }, state)); // Sets a11y status message on changes in selectedItem.

  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], _extends({
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items: items,
    environment: environment,
    itemToString: itemToString
  }, state)); // Scroll on highlighted item if change comes from keyboard.

  var shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex: highlightedIndex,
    isOpen: isOpen,
    itemRefs: itemRefs,
    scrollIntoView: scrollIntoView,
    getItemNodeFromIndex: getItemNodeFromIndex
  }); // Sets cleanup for the keysSoFar callback, debounded after 500ms.

  Object(compat_module["useEffect"])(function () {
    // init the clean function here as we need access to dispatch.
    clearTimeoutRef.current = debounce(function (outerDispatch) {
      outerDispatch({
        type: FunctionSetInputValue$1,
        inputValue: ''
      });
    }, 500); // Cancel any pending debounced calls on mount

    return function () {
      clearTimeoutRef.current.cancel();
    };
  }, []); // Invokes the keysSoFar callback set up above.

  Object(compat_module["useEffect"])(function () {
    if (!inputValue) {
      return;
    }

    clearTimeoutRef.current(dispatch);
  }, [dispatch, inputValue]);
  useControlPropsValidator({
    isInitialMount: isInitialMountRef.current,
    props: props,
    state: state
  });
  /* Controls the focus on the menu or the toggle button. */

  Object(compat_module["useEffect"])(function () {
    // Don't focus menu on first render.
    if (isInitialMountRef.current) {
      // Unless it was initialised as open.
      if ((initialIsOpen || defaultIsOpen || isOpen) && menuRef.current) {
        menuRef.current.focus();
      }

      return;
    } // Focus menu on open.


    if (isOpen) {
      // istanbul ignore else
      if (menuRef.current) {
        menuRef.current.focus();
      }

      return;
    } // Focus toggleButton on close, but not if it was closed with (Shift+)Tab.


    if (environment.document.activeElement === menuRef.current) {
      // istanbul ignore else
      if (toggleButtonRef.current) {
        shouldBlurRef.current = false;
        toggleButtonRef.current.focus();
      }
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [isOpen]);
  Object(compat_module["useEffect"])(function () {
    if (isInitialMountRef.current) {
      return;
    }

    previousResultCountRef.current = items.length;
  }); // Add mouse/touch events to document.

  var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, function () {
    dispatch({
      type: MenuBlur
    });
  });
  var setGetterPropCallInfo = useGetterPropsCalledChecker('getMenuProps', 'getToggleButtonProps'); // Make initial ref false.

  Object(compat_module["useEffect"])(function () {
    isInitialMountRef.current = false;
  }, []); // Reset itemRefs on close.

  Object(compat_module["useEffect"])(function () {
    if (!isOpen) {
      itemRefs.current = {};
    }
  }, [isOpen]); // Event handler functions.

  var toggleButtonKeyDownHandlers = Object(compat_module["useMemo"])(function () {
    return {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowDown,
          getItemNodeFromIndex: getItemNodeFromIndex,
          shiftKey: event.shiftKey
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowUp,
          getItemNodeFromIndex: getItemNodeFromIndex,
          shiftKey: event.shiftKey
        });
      }
    };
  }, [dispatch, getItemNodeFromIndex]);
  var menuKeyDownHandlers = Object(compat_module["useMemo"])(function () {
    return {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownArrowDown,
          getItemNodeFromIndex: getItemNodeFromIndex,
          shiftKey: event.shiftKey
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownArrowUp,
          getItemNodeFromIndex: getItemNodeFromIndex,
          shiftKey: event.shiftKey
        });
      },
      Home: function Home(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownHome,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      },
      End: function End(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownEnd,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      },
      Escape: function Escape() {
        dispatch({
          type: MenuKeyDownEscape
        });
      },
      Enter: function Enter(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownEnter
        });
      },
      ' ': function _(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownSpaceButton
        });
      }
    };
  }, [dispatch, getItemNodeFromIndex]); // Action functions.

  var toggleMenu = Object(compat_module["useCallback"])(function () {
    dispatch({
      type: FunctionToggleMenu$1
    });
  }, [dispatch]);
  var closeMenu = Object(compat_module["useCallback"])(function () {
    dispatch({
      type: FunctionCloseMenu$1
    });
  }, [dispatch]);
  var openMenu = Object(compat_module["useCallback"])(function () {
    dispatch({
      type: FunctionOpenMenu$1
    });
  }, [dispatch]);
  var setHighlightedIndex = Object(compat_module["useCallback"])(function (newHighlightedIndex) {
    dispatch({
      type: FunctionSetHighlightedIndex$1,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  var selectItem = Object(compat_module["useCallback"])(function (newSelectedItem) {
    dispatch({
      type: FunctionSelectItem$1,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  var reset = Object(compat_module["useCallback"])(function () {
    dispatch({
      type: FunctionReset$2
    });
  }, [dispatch]);
  var setInputValue = Object(compat_module["useCallback"])(function (newInputValue) {
    dispatch({
      type: FunctionSetInputValue$1,
      inputValue: newInputValue
    });
  }, [dispatch]); // Getter functions.

  var getLabelProps = Object(compat_module["useCallback"])(function (labelProps) {
    return _extends({
      id: elementIds.labelId,
      htmlFor: elementIds.toggleButtonId
    }, labelProps);
  }, [elementIds]);
  var getMenuProps = Object(compat_module["useCallback"])(function (_temp, _temp2) {
    var _extends2;

    var _ref = _temp === void 0 ? {} : _temp,
        onMouseLeave = _ref.onMouseLeave,
        _ref$refKey = _ref.refKey,
        refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,
        onKeyDown = _ref.onKeyDown,
        onBlur = _ref.onBlur,
        ref = _ref.ref,
        rest = _objectWithoutPropertiesLoose(_ref, ["onMouseLeave", "refKey", "onKeyDown", "onBlur", "ref"]);

    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        _ref2$suppressRefErro = _ref2.suppressRefError,
        suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;

    var latestState = latest.current.state;

    var menuHandleKeyDown = function menuHandleKeyDown(event) {
      var key = normalizeArrowKey(event);

      if (key && menuKeyDownHandlers[key]) {
        menuKeyDownHandlers[key](event);
      } else if (isAcceptedCharacterKey(key)) {
        dispatch({
          type: MenuKeyDownCharacter,
          key: key,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      }
    };

    var menuHandleBlur = function menuHandleBlur() {
      // if the blur was a result of selection, we don't trigger this action.
      if (shouldBlurRef.current === false) {
        shouldBlurRef.current = true;
        return;
      }

      var shouldBlur = !mouseAndTouchTrackersRef.current.isMouseDown;
      /* istanbul ignore else */

      if (shouldBlur) {
        dispatch({
          type: MenuBlur
        });
      }
    };

    var menuHandleMouseLeave = function menuHandleMouseLeave() {
      dispatch({
        type: MenuMouseLeave$1
      });
    };

    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);
    return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref, function (menuNode) {
      menuRef.current = menuNode;
    }), _extends2.id = elementIds.menuId, _extends2.role = 'listbox', _extends2['aria-labelledby'] = elementIds.labelId, _extends2.tabIndex = -1, _extends2), latestState.isOpen && latestState.highlightedIndex > -1 && {
      'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)
    }, {
      onMouseLeave: callAllEventHandlers(onMouseLeave, menuHandleMouseLeave),
      onKeyDown: callAllEventHandlers(onKeyDown, menuHandleKeyDown),
      onBlur: callAllEventHandlers(onBlur, menuHandleBlur)
    }, rest);
  }, [dispatch, latest, menuKeyDownHandlers, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);
  var getToggleButtonProps = Object(compat_module["useCallback"])(function (_temp3, _temp4) {
    var _extends3;

    var _ref3 = _temp3 === void 0 ? {} : _temp3,
        onClick = _ref3.onClick,
        onKeyDown = _ref3.onKeyDown,
        _ref3$refKey = _ref3.refKey,
        refKey = _ref3$refKey === void 0 ? 'ref' : _ref3$refKey,
        ref = _ref3.ref,
        rest = _objectWithoutPropertiesLoose(_ref3, ["onClick", "onKeyDown", "refKey", "ref"]);

    var _ref4 = _temp4 === void 0 ? {} : _temp4,
        _ref4$suppressRefErro = _ref4.suppressRefError,
        suppressRefError = _ref4$suppressRefErro === void 0 ? false : _ref4$suppressRefErro;

    var toggleButtonHandleClick = function toggleButtonHandleClick() {
      dispatch({
        type: ToggleButtonClick$1
      });
    };

    var toggleButtonHandleKeyDown = function toggleButtonHandleKeyDown(event) {
      var key = normalizeArrowKey(event);

      if (key && toggleButtonKeyDownHandlers[key]) {
        toggleButtonKeyDownHandlers[key](event);
      } else if (isAcceptedCharacterKey(key)) {
        dispatch({
          type: ToggleButtonKeyDownCharacter,
          key: key,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      }
    };

    var toggleProps = _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function (toggleButtonNode) {
      toggleButtonRef.current = toggleButtonNode;
    }), _extends3.id = elementIds.toggleButtonId, _extends3['aria-haspopup'] = 'listbox', _extends3['aria-expanded'] = latest.current.state.isOpen, _extends3['aria-labelledby'] = elementIds.labelId + " " + elementIds.toggleButtonId, _extends3), rest);

    if (!rest.disabled) {
      toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);
      toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);
    }

    setGetterPropCallInfo('getToggleButtonProps', suppressRefError, refKey, toggleButtonRef);
    return toggleProps;
  }, [dispatch, latest, toggleButtonKeyDownHandlers, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);
  var getItemProps = Object(compat_module["useCallback"])(function (_temp5) {
    var _extends4;

    var _ref5 = _temp5 === void 0 ? {} : _temp5,
        item = _ref5.item,
        index = _ref5.index,
        onMouseMove = _ref5.onMouseMove,
        onClick = _ref5.onClick,
        _ref5$refKey = _ref5.refKey,
        refKey = _ref5$refKey === void 0 ? 'ref' : _ref5$refKey,
        ref = _ref5.ref,
        rest = _objectWithoutPropertiesLoose(_ref5, ["item", "index", "onMouseMove", "onClick", "refKey", "ref"]);

    var _latest$current = latest.current,
        latestState = _latest$current.state,
        latestProps = _latest$current.props;

    var itemHandleMouseMove = function itemHandleMouseMove() {
      if (index === latestState.highlightedIndex) {
        return;
      }

      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove$1,
        index: index
      });
    };

    var itemHandleClick = function itemHandleClick() {
      dispatch({
        type: ItemClick$1,
        index: index
      });
    };

    var itemIndex = getItemIndex(index, item, latestProps.items);

    if (itemIndex < 0) {
      throw new Error('Pass either item or item index in getItemProps!');
    }

    var itemProps = _extends((_extends4 = {
      role: 'option',
      'aria-selected': "" + (itemIndex === latestState.highlightedIndex),
      id: elementIds.getItemId(itemIndex)
    }, _extends4[refKey] = handleRefs(ref, function (itemNode) {
      if (itemNode) {
        itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;
      }
    }), _extends4), rest);

    if (!rest.disabled) {
      itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);
      itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);
    }

    return itemProps;
  }, [dispatch, latest, shouldScrollRef, elementIds]);
  return {
    // prop getters.
    getToggleButtonProps: getToggleButtonProps,
    getLabelProps: getLabelProps,
    getMenuProps: getMenuProps,
    getItemProps: getItemProps,
    // actions.
    toggleMenu: toggleMenu,
    openMenu: openMenu,
    closeMenu: closeMenu,
    setHighlightedIndex: setHighlightedIndex,
    selectItem: selectItem,
    reset: reset,
    setInputValue: setInputValue,
    // state.
    highlightedIndex: highlightedIndex,
    isOpen: isOpen,
    selectedItem: selectedItem,
    inputValue: inputValue
  };
}

var InputKeyDownArrowDown =  false ? undefined : 0;
var InputKeyDownArrowUp =  false ? undefined : 1;
var InputKeyDownEscape =  false ? undefined : 2;
var InputKeyDownHome =  false ? undefined : 3;
var InputKeyDownEnd =  false ? undefined : 4;
var InputKeyDownEnter =  false ? undefined : 5;
var InputChange =  false ? undefined : 6;
var InputBlur =  false ? undefined : 7;
var MenuMouseLeave =  false ? undefined : 8;
var ItemMouseMove =  false ? undefined : 9;
var ItemClick =  false ? undefined : 10;
var ToggleButtonClick =  false ? undefined : 11;
var FunctionToggleMenu =  false ? undefined : 12;
var FunctionOpenMenu =  false ? undefined : 13;
var FunctionCloseMenu =  false ? undefined : 14;
var FunctionSetHighlightedIndex =  false ? undefined : 15;
var FunctionSelectItem =  false ? undefined : 16;
var FunctionSetInputValue =  false ? undefined : 17;
var FunctionReset$1 =  false ? undefined : 18;
var ControlledPropUpdatedSelectedItem =  false ? undefined : 19;
var stateChangeTypes$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  InputKeyDownArrowDown: InputKeyDownArrowDown,
  InputKeyDownArrowUp: InputKeyDownArrowUp,
  InputKeyDownEscape: InputKeyDownEscape,
  InputKeyDownHome: InputKeyDownHome,
  InputKeyDownEnd: InputKeyDownEnd,
  InputKeyDownEnter: InputKeyDownEnter,
  InputChange: InputChange,
  InputBlur: InputBlur,
  MenuMouseLeave: MenuMouseLeave,
  ItemMouseMove: ItemMouseMove,
  ItemClick: ItemClick,
  ToggleButtonClick: ToggleButtonClick,
  FunctionToggleMenu: FunctionToggleMenu,
  FunctionOpenMenu: FunctionOpenMenu,
  FunctionCloseMenu: FunctionCloseMenu,
  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex,
  FunctionSelectItem: FunctionSelectItem,
  FunctionSetInputValue: FunctionSetInputValue,
  FunctionReset: FunctionReset$1,
  ControlledPropUpdatedSelectedItem: ControlledPropUpdatedSelectedItem
});

function getInitialState$1(props) {
  var initialState = getInitialState$2(props);
  var selectedItem = initialState.selectedItem;
  var inputValue = initialState.inputValue;

  if (inputValue === '' && selectedItem && props.defaultInputValue === undefined && props.initialInputValue === undefined && props.inputValue === undefined) {
    inputValue = props.itemToString(selectedItem);
  }

  return _extends({}, initialState, {
    inputValue: inputValue
  });
}

var propTypes$1 = {
  items: prop_types_default.a.array.isRequired,
  itemToString: prop_types_default.a.func,
  getA11yStatusMessage: prop_types_default.a.func,
  getA11ySelectionMessage: prop_types_default.a.func,
  circularNavigation: prop_types_default.a.bool,
  highlightedIndex: prop_types_default.a.number,
  defaultHighlightedIndex: prop_types_default.a.number,
  initialHighlightedIndex: prop_types_default.a.number,
  isOpen: prop_types_default.a.bool,
  defaultIsOpen: prop_types_default.a.bool,
  initialIsOpen: prop_types_default.a.bool,
  selectedItem: prop_types_default.a.any,
  initialSelectedItem: prop_types_default.a.any,
  defaultSelectedItem: prop_types_default.a.any,
  inputValue: prop_types_default.a.string,
  defaultInputValue: prop_types_default.a.string,
  initialInputValue: prop_types_default.a.string,
  id: prop_types_default.a.string,
  labelId: prop_types_default.a.string,
  menuId: prop_types_default.a.string,
  getItemId: prop_types_default.a.func,
  inputId: prop_types_default.a.string,
  toggleButtonId: prop_types_default.a.string,
  stateReducer: prop_types_default.a.func,
  onSelectedItemChange: prop_types_default.a.func,
  onHighlightedIndexChange: prop_types_default.a.func,
  onStateChange: prop_types_default.a.func,
  onIsOpenChange: prop_types_default.a.func,
  onInputValueChange: prop_types_default.a.func,
  environment: prop_types_default.a.shape({
    addEventListener: prop_types_default.a.func,
    removeEventListener: prop_types_default.a.func,
    document: prop_types_default.a.shape({
      getElementById: prop_types_default.a.func,
      activeElement: prop_types_default.a.any,
      body: prop_types_default.a.any
    })
  })
};
/**
 * The useCombobox version of useControlledReducer, which also
 * checks if the controlled prop selectedItem changed between
 * renders. If so, it will also update inputValue with its
 * string equivalent. It uses the common useEnhancedReducer to
 * compute the rest of the state.
 *
 * @param {Function} reducer Reducer function from downshift.
 * @param {Object} initialState Initial state of the hook.
 * @param {Object} props The hook props.
 * @returns {Array} An array with the state and an action dispatcher.
 */

function useControlledReducer(reducer, initialState, props) {
  var previousSelectedItemRef = Object(compat_module["useRef"])();

  var _useEnhancedReducer = useEnhancedReducer(reducer, initialState, props),
      state = _useEnhancedReducer[0],
      dispatch = _useEnhancedReducer[1]; // ToDo: if needed, make same approach as selectedItemChanged from Downshift.


  Object(compat_module["useEffect"])(function () {
    if (isControlledProp(props, 'selectedItem')) {
      if (previousSelectedItemRef.current !== props.selectedItem) {
        dispatch({
          type: ControlledPropUpdatedSelectedItem,
          inputValue: props.itemToString(props.selectedItem)
        });
      }

      previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;
    }
  });
  return [getState(state, props), dispatch];
} // eslint-disable-next-line import/no-mutable-exports


var validatePropTypes$1 = downshift_esm_noop;
/* istanbul ignore next */

if (false) {}

var defaultProps$1 = _extends({}, defaultProps$3, {
  getA11yStatusMessage: getA11yStatusMessage$1,
  circularNavigation: true
});
/* eslint-disable complexity */


function downshiftUseComboboxReducer(state, action) {
  var type = action.type,
      props = action.props,
      shiftKey = action.shiftKey;
  var changes;

  switch (type) {
    case ItemClick:
      changes = {
        isOpen: getDefaultValue$1(props, 'isOpen'),
        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),
        selectedItem: props.items[action.index],
        inputValue: props.itemToString(props.items[action.index])
      };
      break;

    case InputKeyDownArrowDown:
      if (state.isOpen) {
        changes = {
          highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
        };
      } else {
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
          isOpen: props.items.length >= 0
        };
      }

      break;

    case InputKeyDownArrowUp:
      if (state.isOpen) {
        changes = {
          highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
        };
      } else {
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
          isOpen: props.items.length >= 0
        };
      }

      break;

    case InputKeyDownEnter:
      changes = _extends({}, state.isOpen && state.highlightedIndex >= 0 && {
        selectedItem: props.items[state.highlightedIndex],
        isOpen: getDefaultValue$1(props, 'isOpen'),
        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),
        inputValue: props.itemToString(props.items[state.highlightedIndex])
      });
      break;

    case InputKeyDownEscape:
      changes = _extends({
        isOpen: false,
        highlightedIndex: -1
      }, !state.isOpen && {
        selectedItem: null,
        inputValue: ''
      });
      break;

    case InputKeyDownHome:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;

    case InputKeyDownEnd:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;

    case InputBlur:
      changes = _extends({
        isOpen: false,
        highlightedIndex: -1
      }, state.highlightedIndex >= 0 && action.selectItem && {
        selectedItem: props.items[state.highlightedIndex],
        inputValue: props.itemToString(props.items[state.highlightedIndex])
      });
      break;

    case InputChange:
      changes = {
        isOpen: true,
        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),
        inputValue: action.inputValue
      };
      break;

    case FunctionSelectItem:
      changes = {
        selectedItem: action.selectedItem,
        inputValue: props.itemToString(action.selectedItem)
      };
      break;

    case ControlledPropUpdatedSelectedItem:
      changes = {
        inputValue: action.inputValue
      };
      break;

    default:
      return downshiftCommonReducer(state, action, stateChangeTypes$1);
  }

  return _extends({}, state, changes);
}
/* eslint-enable complexity */


useCombobox.stateChangeTypes = stateChangeTypes$1;

function useCombobox(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }

  validatePropTypes$1(userProps, useCombobox); // Props defaults and destructuring.

  var props = _extends({}, defaultProps$1, userProps);

  var initialIsOpen = props.initialIsOpen,
      defaultIsOpen = props.defaultIsOpen,
      items = props.items,
      scrollIntoView = props.scrollIntoView,
      environment = props.environment,
      getA11yStatusMessage = props.getA11yStatusMessage,
      getA11ySelectionMessage = props.getA11ySelectionMessage,
      itemToString = props.itemToString; // Initial state depending on controlled props.

  var initialState = getInitialState$1(props);

  var _useControlledReducer = useControlledReducer(downshiftUseComboboxReducer, initialState, props),
      state = _useControlledReducer[0],
      dispatch = _useControlledReducer[1];

  var isOpen = state.isOpen,
      highlightedIndex = state.highlightedIndex,
      selectedItem = state.selectedItem,
      inputValue = state.inputValue; // Element refs.

  var menuRef = Object(compat_module["useRef"])(null);
  var itemRefs = Object(compat_module["useRef"])({});
  var inputRef = Object(compat_module["useRef"])(null);
  var toggleButtonRef = Object(compat_module["useRef"])(null);
  var comboboxRef = Object(compat_module["useRef"])(null);
  var isInitialMountRef = Object(compat_module["useRef"])(true); // prevent id re-generation between renders.

  var elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.

  var previousResultCountRef = Object(compat_module["useRef"])(); // utility callback to get item element.

  var latest = useLatestRef({
    state: state,
    props: props
  });
  var getItemNodeFromIndex = Object(compat_module["useCallback"])(function (index) {
    return itemRefs.current[elementIds.getItemId(index)];
  }, [elementIds]); // Effects.
  // Sets a11y status message on changes in state.

  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], _extends({
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items: items,
    environment: environment,
    itemToString: itemToString
  }, state)); // Sets a11y status message on changes in selectedItem.

  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], _extends({
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items: items,
    environment: environment,
    itemToString: itemToString
  }, state)); // Scroll on highlighted item if change comes from keyboard.

  var shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex: highlightedIndex,
    isOpen: isOpen,
    itemRefs: itemRefs,
    scrollIntoView: scrollIntoView,
    getItemNodeFromIndex: getItemNodeFromIndex
  });
  useControlPropsValidator({
    isInitialMount: isInitialMountRef.current,
    props: props,
    state: state
  }); // Focus the input on first render if required.

  Object(compat_module["useEffect"])(function () {
    var focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;

    if (focusOnOpen && inputRef.current) {
      inputRef.current.focus();
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  Object(compat_module["useEffect"])(function () {
    if (isInitialMountRef.current) {
      return;
    }

    previousResultCountRef.current = items.length;
  }); // Add mouse/touch events to document.

  var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [comboboxRef, menuRef, toggleButtonRef], environment, function () {
    dispatch({
      type: InputBlur,
      selectItem: false
    });
  });
  var setGetterPropCallInfo = useGetterPropsCalledChecker('getInputProps', 'getComboboxProps', 'getMenuProps'); // Make initial ref false.

  Object(compat_module["useEffect"])(function () {
    isInitialMountRef.current = false;
  }, []); // Reset itemRefs on close.

  Object(compat_module["useEffect"])(function () {
    if (!isOpen) {
      itemRefs.current = {};
    }
  }, [isOpen]);
  /* Event handler functions */

  var inputKeyDownHandlers = Object(compat_module["useMemo"])(function () {
    return {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        dispatch({
          type: InputKeyDownArrowDown,
          shiftKey: event.shiftKey,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        dispatch({
          type: InputKeyDownArrowUp,
          shiftKey: event.shiftKey,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      },
      Home: function Home(event) {
        if (!latest.current.state.isOpen) {
          return;
        }

        event.preventDefault();
        dispatch({
          type: InputKeyDownHome,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      },
      End: function End(event) {
        if (!latest.current.state.isOpen) {
          return;
        }

        event.preventDefault();
        dispatch({
          type: InputKeyDownEnd,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      },
      Escape: function Escape() {
        var latestState = latest.current.state;

        if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {
          dispatch({
            type: InputKeyDownEscape
          });
        }
      },
      Enter: function Enter(event) {
        var latestState = latest.current.state; // if closed or no highlighted index, do nothing.

        if (!latestState.isOpen || latestState.highlightedIndex < 0 || event.which === 229 // if IME composing, wait for next Enter keydown event.
        ) {
            return;
          }

        event.preventDefault();
        dispatch({
          type: InputKeyDownEnter,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      }
    };
  }, [dispatch, latest, getItemNodeFromIndex]); // Getter props.

  var getLabelProps = Object(compat_module["useCallback"])(function (labelProps) {
    return _extends({
      id: elementIds.labelId,
      htmlFor: elementIds.inputId
    }, labelProps);
  }, [elementIds]);
  var getMenuProps = Object(compat_module["useCallback"])(function (_temp, _temp2) {
    var _extends2;

    var _ref = _temp === void 0 ? {} : _temp,
        onMouseLeave = _ref.onMouseLeave,
        _ref$refKey = _ref.refKey,
        refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,
        ref = _ref.ref,
        rest = _objectWithoutPropertiesLoose(_ref, ["onMouseLeave", "refKey", "ref"]);

    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        _ref2$suppressRefErro = _ref2.suppressRefError,
        suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;

    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);
    return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref, function (menuNode) {
      menuRef.current = menuNode;
    }), _extends2.id = elementIds.menuId, _extends2.role = 'listbox', _extends2['aria-labelledby'] = elementIds.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, function () {
      dispatch({
        type: MenuMouseLeave
      });
    }), _extends2), rest);
  }, [dispatch, setGetterPropCallInfo, elementIds]);
  var getItemProps = Object(compat_module["useCallback"])(function (_temp3) {
    var _extends3, _ref4;

    var _ref3 = _temp3 === void 0 ? {} : _temp3,
        item = _ref3.item,
        index = _ref3.index,
        _ref3$refKey = _ref3.refKey,
        refKey = _ref3$refKey === void 0 ? 'ref' : _ref3$refKey,
        ref = _ref3.ref,
        onMouseMove = _ref3.onMouseMove,
        onClick = _ref3.onClick;

    _ref3.onPress;

    var rest = _objectWithoutPropertiesLoose(_ref3, ["item", "index", "refKey", "ref", "onMouseMove", "onClick", "onPress"]);

    var _latest$current = latest.current,
        latestProps = _latest$current.props,
        latestState = _latest$current.state;
    var itemIndex = getItemIndex(index, item, latestProps.items);

    if (itemIndex < 0) {
      throw new Error('Pass either item or item index in getItemProps!');
    }

    var onSelectKey = 'onClick';
    var customClickHandler = onClick;

    var itemHandleMouseMove = function itemHandleMouseMove() {
      if (index === latestState.highlightedIndex) {
        return;
      }

      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove,
        index: index
      });
    };

    var itemHandleClick = function itemHandleClick() {
      dispatch({
        type: ItemClick,
        index: index
      });

      if (inputRef.current) {
        inputRef.current.focus();
      }
    };

    return _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function (itemNode) {
      if (itemNode) {
        itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;
      }
    }), _extends3.role = 'option', _extends3['aria-selected'] = "" + (itemIndex === latestState.highlightedIndex), _extends3.id = elementIds.getItemId(itemIndex), _extends3), !rest.disabled && (_ref4 = {
      onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove)
    }, _ref4[onSelectKey] = callAllEventHandlers(customClickHandler, itemHandleClick), _ref4), rest);
  }, [dispatch, latest, shouldScrollRef, elementIds]);
  var getToggleButtonProps = Object(compat_module["useCallback"])(function (_temp4) {
    var _extends4;

    var _ref5 = _temp4 === void 0 ? {} : _temp4,
        onClick = _ref5.onClick;

    _ref5.onPress;

    var _ref5$refKey = _ref5.refKey,
        refKey = _ref5$refKey === void 0 ? 'ref' : _ref5$refKey,
        ref = _ref5.ref,
        rest = _objectWithoutPropertiesLoose(_ref5, ["onClick", "onPress", "refKey", "ref"]);

    var toggleButtonHandleClick = function toggleButtonHandleClick() {
      dispatch({
        type: ToggleButtonClick
      });

      if (!latest.current.state.isOpen && inputRef.current) {
        inputRef.current.focus();
      }
    };

    return _extends((_extends4 = {}, _extends4[refKey] = handleRefs(ref, function (toggleButtonNode) {
      toggleButtonRef.current = toggleButtonNode;
    }), _extends4.id = elementIds.toggleButtonId, _extends4.tabIndex = -1, _extends4), !rest.disabled && _extends({}, {
      onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)
    }), rest);
  }, [dispatch, latest, elementIds]);
  var getInputProps = Object(compat_module["useCallback"])(function (_temp5, _temp6) {
    var _extends5;

    var _ref6 = _temp5 === void 0 ? {} : _temp5,
        onKeyDown = _ref6.onKeyDown,
        onChange = _ref6.onChange,
        onInput = _ref6.onInput,
        onBlur = _ref6.onBlur;

    _ref6.onChangeText;

    var _ref6$refKey = _ref6.refKey,
        refKey = _ref6$refKey === void 0 ? 'ref' : _ref6$refKey,
        ref = _ref6.ref,
        rest = _objectWithoutPropertiesLoose(_ref6, ["onKeyDown", "onChange", "onInput", "onBlur", "onChangeText", "refKey", "ref"]);

    var _ref7 = _temp6 === void 0 ? {} : _temp6,
        _ref7$suppressRefErro = _ref7.suppressRefError,
        suppressRefError = _ref7$suppressRefErro === void 0 ? false : _ref7$suppressRefErro;

    setGetterPropCallInfo('getInputProps', suppressRefError, refKey, inputRef);
    var latestState = latest.current.state;

    var inputHandleKeyDown = function inputHandleKeyDown(event) {
      var key = normalizeArrowKey(event);

      if (key && inputKeyDownHandlers[key]) {
        inputKeyDownHandlers[key](event);
      }
    };

    var inputHandleChange = function inputHandleChange(event) {
      dispatch({
        type: InputChange,
        inputValue: event.target.value
      });
    };

    var inputHandleBlur = function inputHandleBlur() {
      /* istanbul ignore else */
      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {
        dispatch({
          type: InputBlur,
          selectItem: true
        });
      }
    };
    /* istanbul ignore next (preact) */


    var onChangeKey = 'onChange';
    var eventHandlers = {};

    if (!rest.disabled) {
      var _eventHandlers;

      eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, inputHandleBlur), _eventHandlers);
    }

    return _extends((_extends5 = {}, _extends5[refKey] = handleRefs(ref, function (inputNode) {
      inputRef.current = inputNode;
    }), _extends5.id = elementIds.inputId, _extends5['aria-autocomplete'] = 'list', _extends5['aria-controls'] = elementIds.menuId, _extends5), latestState.isOpen && latestState.highlightedIndex > -1 && {
      'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)
    }, {
      'aria-labelledby': elementIds.labelId,
      // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
      // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
      autoComplete: 'off',
      value: latestState.inputValue
    }, eventHandlers, rest);
  }, [dispatch, inputKeyDownHandlers, latest, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds]);
  var getComboboxProps = Object(compat_module["useCallback"])(function (_temp7, _temp8) {
    var _extends6;

    var _ref8 = _temp7 === void 0 ? {} : _temp7,
        _ref8$refKey = _ref8.refKey,
        refKey = _ref8$refKey === void 0 ? 'ref' : _ref8$refKey,
        ref = _ref8.ref,
        rest = _objectWithoutPropertiesLoose(_ref8, ["refKey", "ref"]);

    var _ref9 = _temp8 === void 0 ? {} : _temp8,
        _ref9$suppressRefErro = _ref9.suppressRefError,
        suppressRefError = _ref9$suppressRefErro === void 0 ? false : _ref9$suppressRefErro;

    setGetterPropCallInfo('getComboboxProps', suppressRefError, refKey, comboboxRef);
    return _extends((_extends6 = {}, _extends6[refKey] = handleRefs(ref, function (comboboxNode) {
      comboboxRef.current = comboboxNode;
    }), _extends6.role = 'combobox', _extends6['aria-haspopup'] = 'listbox', _extends6['aria-owns'] = elementIds.menuId, _extends6['aria-expanded'] = latest.current.state.isOpen, _extends6), rest);
  }, [latest, setGetterPropCallInfo, elementIds]); // returns

  var toggleMenu = Object(compat_module["useCallback"])(function () {
    dispatch({
      type: FunctionToggleMenu
    });
  }, [dispatch]);
  var closeMenu = Object(compat_module["useCallback"])(function () {
    dispatch({
      type: FunctionCloseMenu
    });
  }, [dispatch]);
  var openMenu = Object(compat_module["useCallback"])(function () {
    dispatch({
      type: FunctionOpenMenu
    });
  }, [dispatch]);
  var setHighlightedIndex = Object(compat_module["useCallback"])(function (newHighlightedIndex) {
    dispatch({
      type: FunctionSetHighlightedIndex,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  var selectItem = Object(compat_module["useCallback"])(function (newSelectedItem) {
    dispatch({
      type: FunctionSelectItem,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  var setInputValue = Object(compat_module["useCallback"])(function (newInputValue) {
    dispatch({
      type: FunctionSetInputValue,
      inputValue: newInputValue
    });
  }, [dispatch]);
  var reset = Object(compat_module["useCallback"])(function () {
    dispatch({
      type: FunctionReset$1
    });
  }, [dispatch]);
  return {
    // prop getters.
    getItemProps: getItemProps,
    getLabelProps: getLabelProps,
    getMenuProps: getMenuProps,
    getInputProps: getInputProps,
    getComboboxProps: getComboboxProps,
    getToggleButtonProps: getToggleButtonProps,
    // actions.
    toggleMenu: toggleMenu,
    openMenu: openMenu,
    closeMenu: closeMenu,
    setHighlightedIndex: setHighlightedIndex,
    setInputValue: setInputValue,
    selectItem: selectItem,
    reset: reset,
    // state.
    highlightedIndex: highlightedIndex,
    isOpen: isOpen,
    selectedItem: selectedItem,
    inputValue: inputValue
  };
}

var defaultStateValues = {
  activeIndex: -1,
  selectedItems: []
};
/**
 * Returns the initial value for a state key in the following order:
 * 1. controlled prop, 2. initial prop, 3. default prop, 4. default
 * value from Downshift.
 *
 * @param {Object} props Props passed to the hook.
 * @param {string} propKey Props key to generate the value for.
 * @returns {any} The initial value for that prop.
 */

function getInitialValue(props, propKey) {
  return getInitialValue$1(props, propKey, defaultStateValues);
}
/**
 * Returns the default value for a state key in the following order:
 * 1. controlled prop, 2. default prop, 3. default value from Downshift.
 *
 * @param {Object} props Props passed to the hook.
 * @param {string} propKey Props key to generate the value for.
 * @returns {any} The initial value for that prop.
 */


function getDefaultValue(props, propKey) {
  return getDefaultValue$1(props, propKey, defaultStateValues);
}
/**
 * Gets the initial state based on the provided props. It uses initial, default
 * and controlled props related to state in order to compute the initial value.
 *
 * @param {Object} props Props passed to the hook.
 * @returns {Object} The initial state.
 */


function getInitialState(props) {
  var activeIndex = getInitialValue(props, 'activeIndex');
  var selectedItems = getInitialValue(props, 'selectedItems');
  return {
    activeIndex: activeIndex,
    selectedItems: selectedItems
  };
}
/**
 * Returns true if dropdown keydown operation is permitted. Should not be
 * allowed on keydown with modifier keys (ctrl, alt, shift, meta), on
 * input element with text content that is either highlighted or selection
 * cursor is not at the starting position.
 *
 * @param {KeyboardEvent} event The event from keydown.
 * @returns {boolean} Whether the operation is allowed.
 */


function isKeyDownOperationPermitted(event) {
  if (event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {
    return false;
  }

  var element = event.target;

  if (element instanceof HTMLInputElement && // if element is a text input
  element.value !== '' && ( // and we have text in it
  // and cursor is either not at the start or is currently highlighting text.
  element.selectionStart !== 0 || element.selectionEnd !== 0)) {
    return false;
  }

  return true;
}
/**
 * Returns a message to be added to aria-live region when item is removed.
 *
 * @param {Object} selectionParameters Parameters required to build the message.
 * @returns {string} The a11y message.
 */


function downshift_esm_getA11yRemovalMessage(selectionParameters) {
  var removedSelectedItem = selectionParameters.removedSelectedItem,
      itemToStringLocal = selectionParameters.itemToString;
  return itemToStringLocal(removedSelectedItem) + " has been removed.";
}

var propTypes = {
  selectedItems: prop_types_default.a.array,
  initialSelectedItems: prop_types_default.a.array,
  defaultSelectedItems: prop_types_default.a.array,
  itemToString: prop_types_default.a.func,
  getA11yRemovalMessage: prop_types_default.a.func,
  stateReducer: prop_types_default.a.func,
  activeIndex: prop_types_default.a.number,
  initialActiveIndex: prop_types_default.a.number,
  defaultActiveIndex: prop_types_default.a.number,
  onActiveIndexChange: prop_types_default.a.func,
  onSelectedItemsChange: prop_types_default.a.func,
  keyNavigationNext: prop_types_default.a.string,
  keyNavigationPrevious: prop_types_default.a.string,
  environment: prop_types_default.a.shape({
    addEventListener: prop_types_default.a.func,
    removeEventListener: prop_types_default.a.func,
    document: prop_types_default.a.shape({
      getElementById: prop_types_default.a.func,
      activeElement: prop_types_default.a.any,
      body: prop_types_default.a.any
    })
  })
};
var downshift_esm_defaultProps = {
  itemToString: defaultProps$3.itemToString,
  stateReducer: defaultProps$3.stateReducer,
  environment: defaultProps$3.environment,
  getA11yRemovalMessage: downshift_esm_getA11yRemovalMessage,
  keyNavigationNext: 'ArrowRight',
  keyNavigationPrevious: 'ArrowLeft'
}; // eslint-disable-next-line import/no-mutable-exports

var validatePropTypes = downshift_esm_noop;
/* istanbul ignore next */

if (false) {}

var SelectedItemClick =  false ? undefined : 0;
var SelectedItemKeyDownDelete =  false ? undefined : 1;
var SelectedItemKeyDownBackspace =  false ? undefined : 2;
var SelectedItemKeyDownNavigationNext =  false ? undefined : 3;
var SelectedItemKeyDownNavigationPrevious =  false ? undefined : 4;
var DropdownKeyDownNavigationPrevious =  false ? undefined : 5;
var DropdownKeyDownBackspace =  false ? undefined : 6;
var DropdownClick =  false ? undefined : 7;
var FunctionAddSelectedItem =  false ? undefined : 8;
var FunctionRemoveSelectedItem =  false ? undefined : 9;
var FunctionSetSelectedItems =  false ? undefined : 10;
var FunctionSetActiveIndex =  false ? undefined : 11;
var FunctionReset =  false ? undefined : 12;
var downshift_esm_stateChangeTypes = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SelectedItemClick: SelectedItemClick,
  SelectedItemKeyDownDelete: SelectedItemKeyDownDelete,
  SelectedItemKeyDownBackspace: SelectedItemKeyDownBackspace,
  SelectedItemKeyDownNavigationNext: SelectedItemKeyDownNavigationNext,
  SelectedItemKeyDownNavigationPrevious: SelectedItemKeyDownNavigationPrevious,
  DropdownKeyDownNavigationPrevious: DropdownKeyDownNavigationPrevious,
  DropdownKeyDownBackspace: DropdownKeyDownBackspace,
  DropdownClick: DropdownClick,
  FunctionAddSelectedItem: FunctionAddSelectedItem,
  FunctionRemoveSelectedItem: FunctionRemoveSelectedItem,
  FunctionSetSelectedItems: FunctionSetSelectedItems,
  FunctionSetActiveIndex: FunctionSetActiveIndex,
  FunctionReset: FunctionReset
});
/* eslint-disable complexity */

function downshiftMultipleSelectionReducer(state, action) {
  var type = action.type,
      index = action.index,
      props = action.props,
      selectedItem = action.selectedItem;
  var activeIndex = state.activeIndex,
      selectedItems = state.selectedItems;
  var changes;

  switch (type) {
    case SelectedItemClick:
      changes = {
        activeIndex: index
      };
      break;

    case SelectedItemKeyDownNavigationPrevious:
      changes = {
        activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1
      };
      break;

    case SelectedItemKeyDownNavigationNext:
      changes = {
        activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1
      };
      break;

    case SelectedItemKeyDownBackspace:
    case SelectedItemKeyDownDelete:
      {
        var newActiveIndex = activeIndex;

        if (selectedItems.length === 1) {
          newActiveIndex = -1;
        } else if (activeIndex === selectedItems.length - 1) {
          newActiveIndex = selectedItems.length - 2;
        }

        changes = _extends({
          selectedItems: [].concat(selectedItems.slice(0, activeIndex), selectedItems.slice(activeIndex + 1))
        }, {
          activeIndex: newActiveIndex
        });
        break;
      }

    case DropdownKeyDownNavigationPrevious:
      changes = {
        activeIndex: selectedItems.length - 1
      };
      break;

    case DropdownKeyDownBackspace:
      changes = {
        selectedItems: selectedItems.slice(0, selectedItems.length - 1)
      };
      break;

    case FunctionAddSelectedItem:
      changes = {
        selectedItems: [].concat(selectedItems, [selectedItem])
      };
      break;

    case DropdownClick:
      changes = {
        activeIndex: -1
      };
      break;

    case FunctionRemoveSelectedItem:
      {
        var _newActiveIndex = activeIndex;
        var selectedItemIndex = selectedItems.indexOf(selectedItem);

        if (selectedItems.length === 1) {
          _newActiveIndex = -1;
        } else if (selectedItemIndex === selectedItems.length - 1) {
          _newActiveIndex = selectedItems.length - 2;
        }

        changes = _extends({
          selectedItems: [].concat(selectedItems.slice(0, selectedItemIndex), selectedItems.slice(selectedItemIndex + 1))
        }, {
          activeIndex: _newActiveIndex
        });
        break;
      }

    case FunctionSetSelectedItems:
      {
        var newSelectedItems = action.selectedItems;
        changes = {
          selectedItems: newSelectedItems
        };
        break;
      }

    case FunctionSetActiveIndex:
      {
        var _newActiveIndex2 = action.activeIndex;
        changes = {
          activeIndex: _newActiveIndex2
        };
        break;
      }

    case FunctionReset:
      changes = {
        activeIndex: getDefaultValue(props, 'activeIndex'),
        selectedItems: getDefaultValue(props, 'selectedItems')
      };
      break;

    default:
      throw new Error('Reducer called without proper action type.');
  }

  return _extends({}, state, changes);
}

useMultipleSelection.stateChangeTypes = downshift_esm_stateChangeTypes;

function useMultipleSelection(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }

  validatePropTypes(userProps, useMultipleSelection); // Props defaults and destructuring.

  var props = _extends({}, downshift_esm_defaultProps, userProps);

  var getA11yRemovalMessage = props.getA11yRemovalMessage,
      itemToString = props.itemToString,
      environment = props.environment,
      keyNavigationNext = props.keyNavigationNext,
      keyNavigationPrevious = props.keyNavigationPrevious; // Reducer init.

  var _useControlledReducer = useControlledReducer$1(downshiftMultipleSelectionReducer, getInitialState(props), props),
      state = _useControlledReducer[0],
      dispatch = _useControlledReducer[1];

  var activeIndex = state.activeIndex,
      selectedItems = state.selectedItems; // Refs.

  var isInitialMountRef = Object(compat_module["useRef"])(true);
  var dropdownRef = Object(compat_module["useRef"])(null);
  var previousSelectedItemsRef = Object(compat_module["useRef"])(selectedItems);
  var selectedItemRefs = Object(compat_module["useRef"])();
  selectedItemRefs.current = [];
  var latest = useLatestRef({
    state: state,
    props: props
  }); // Effects.

  /* Sets a11y status message on changes in selectedItem. */

  Object(compat_module["useEffect"])(function () {
    if (isInitialMountRef.current) {
      return;
    }

    if (selectedItems.length < previousSelectedItemsRef.current.length) {
      var removedSelectedItem = previousSelectedItemsRef.current.find(function (item) {
        return selectedItems.indexOf(item) < 0;
      });
      setStatus(getA11yRemovalMessage({
        itemToString: itemToString,
        resultCount: selectedItems.length,
        removedSelectedItem: removedSelectedItem,
        activeIndex: activeIndex,
        activeSelectedItem: selectedItems[activeIndex]
      }), environment.document);
    }

    previousSelectedItemsRef.current = selectedItems; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedItems.length]); // Sets focus on active item.

  Object(compat_module["useEffect"])(function () {
    if (isInitialMountRef.current) {
      return;
    }

    if (activeIndex === -1 && dropdownRef.current) {
      dropdownRef.current.focus();
    } else if (selectedItemRefs.current[activeIndex]) {
      selectedItemRefs.current[activeIndex].focus();
    }
  }, [activeIndex]);
  useControlPropsValidator({
    isInitialMount: isInitialMountRef.current,
    props: props,
    state: state
  });
  var setGetterPropCallInfo = useGetterPropsCalledChecker('getDropdownProps'); // Make initial ref false.

  Object(compat_module["useEffect"])(function () {
    isInitialMountRef.current = false;
  }, []); // Event handler functions.

  var selectedItemKeyDownHandlers = Object(compat_module["useMemo"])(function () {
    var _ref;

    return _ref = {}, _ref[keyNavigationPrevious] = function () {
      dispatch({
        type: SelectedItemKeyDownNavigationPrevious
      });
    }, _ref[keyNavigationNext] = function () {
      dispatch({
        type: SelectedItemKeyDownNavigationNext
      });
    }, _ref.Delete = function Delete() {
      dispatch({
        type: SelectedItemKeyDownDelete
      });
    }, _ref.Backspace = function Backspace() {
      dispatch({
        type: SelectedItemKeyDownBackspace
      });
    }, _ref;
  }, [dispatch, keyNavigationNext, keyNavigationPrevious]);
  var dropdownKeyDownHandlers = Object(compat_module["useMemo"])(function () {
    var _ref2;

    return _ref2 = {}, _ref2[keyNavigationPrevious] = function (event) {
      if (isKeyDownOperationPermitted(event)) {
        dispatch({
          type: DropdownKeyDownNavigationPrevious
        });
      }
    }, _ref2.Backspace = function Backspace(event) {
      if (isKeyDownOperationPermitted(event)) {
        dispatch({
          type: DropdownKeyDownBackspace
        });
      }
    }, _ref2;
  }, [dispatch, keyNavigationPrevious]); // Getter props.

  var getSelectedItemProps = Object(compat_module["useCallback"])(function (_temp) {
    var _extends2;

    var _ref3 = _temp === void 0 ? {} : _temp,
        _ref3$refKey = _ref3.refKey,
        refKey = _ref3$refKey === void 0 ? 'ref' : _ref3$refKey,
        ref = _ref3.ref,
        onClick = _ref3.onClick,
        onKeyDown = _ref3.onKeyDown,
        selectedItem = _ref3.selectedItem,
        index = _ref3.index,
        rest = _objectWithoutPropertiesLoose(_ref3, ["refKey", "ref", "onClick", "onKeyDown", "selectedItem", "index"]);

    var latestState = latest.current.state;
    var itemIndex = getItemIndex(index, selectedItem, latestState.selectedItems);

    if (itemIndex < 0) {
      throw new Error('Pass either selectedItem or index in getSelectedItemProps!');
    }

    var selectedItemHandleClick = function selectedItemHandleClick() {
      dispatch({
        type: SelectedItemClick,
        index: index
      });
    };

    var selectedItemHandleKeyDown = function selectedItemHandleKeyDown(event) {
      var key = normalizeArrowKey(event);

      if (key && selectedItemKeyDownHandlers[key]) {
        selectedItemKeyDownHandlers[key](event);
      }
    };

    return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref, function (selectedItemNode) {
      if (selectedItemNode) {
        selectedItemRefs.current.push(selectedItemNode);
      }
    }), _extends2.tabIndex = index === latestState.activeIndex ? 0 : -1, _extends2.onClick = callAllEventHandlers(onClick, selectedItemHandleClick), _extends2.onKeyDown = callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown), _extends2), rest);
  }, [dispatch, latest, selectedItemKeyDownHandlers]);
  var getDropdownProps = Object(compat_module["useCallback"])(function (_temp2, _temp3) {
    var _extends3;

    var _ref4 = _temp2 === void 0 ? {} : _temp2,
        _ref4$refKey = _ref4.refKey,
        refKey = _ref4$refKey === void 0 ? 'ref' : _ref4$refKey,
        ref = _ref4.ref,
        onKeyDown = _ref4.onKeyDown,
        onClick = _ref4.onClick,
        _ref4$preventKeyActio = _ref4.preventKeyAction,
        preventKeyAction = _ref4$preventKeyActio === void 0 ? false : _ref4$preventKeyActio,
        rest = _objectWithoutPropertiesLoose(_ref4, ["refKey", "ref", "onKeyDown", "onClick", "preventKeyAction"]);

    var _ref5 = _temp3 === void 0 ? {} : _temp3,
        _ref5$suppressRefErro = _ref5.suppressRefError,
        suppressRefError = _ref5$suppressRefErro === void 0 ? false : _ref5$suppressRefErro;

    setGetterPropCallInfo('getDropdownProps', suppressRefError, refKey, dropdownRef);

    var dropdownHandleKeyDown = function dropdownHandleKeyDown(event) {
      var key = normalizeArrowKey(event);

      if (key && dropdownKeyDownHandlers[key]) {
        dropdownKeyDownHandlers[key](event);
      }
    };

    var dropdownHandleClick = function dropdownHandleClick() {
      dispatch({
        type: DropdownClick
      });
    };

    return _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function (dropdownNode) {
      if (dropdownNode) {
        dropdownRef.current = dropdownNode;
      }
    }), _extends3), !preventKeyAction && {
      onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),
      onClick: callAllEventHandlers(onClick, dropdownHandleClick)
    }, rest);
  }, [dispatch, dropdownKeyDownHandlers, setGetterPropCallInfo]); // returns

  var addSelectedItem = Object(compat_module["useCallback"])(function (selectedItem) {
    dispatch({
      type: FunctionAddSelectedItem,
      selectedItem: selectedItem
    });
  }, [dispatch]);
  var removeSelectedItem = Object(compat_module["useCallback"])(function (selectedItem) {
    dispatch({
      type: FunctionRemoveSelectedItem,
      selectedItem: selectedItem
    });
  }, [dispatch]);
  var setSelectedItems = Object(compat_module["useCallback"])(function (newSelectedItems) {
    dispatch({
      type: FunctionSetSelectedItems,
      selectedItems: newSelectedItems
    });
  }, [dispatch]);
  var setActiveIndex = Object(compat_module["useCallback"])(function (newActiveIndex) {
    dispatch({
      type: FunctionSetActiveIndex,
      activeIndex: newActiveIndex
    });
  }, [dispatch]);
  var reset = Object(compat_module["useCallback"])(function () {
    dispatch({
      type: FunctionReset
    });
  }, [dispatch]);
  return {
    getSelectedItemProps: getSelectedItemProps,
    getDropdownProps: getDropdownProps,
    addSelectedItem: addSelectedItem,
    removeSelectedItem: removeSelectedItem,
    setSelectedItems: setSelectedItems,
    setActiveIndex: setActiveIndex,
    reset: reset,
    selectedItems: selectedItems,
    activeIndex: activeIndex
  };
}

/* harmony default export */ var downshift_esm = (downshift_esm_Downshift);

// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/editor/widgets/Autocomplete.jsx
function Autocomplete_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Autocomplete_typeof = function _typeof(obj) { return typeof obj; }; } else { Autocomplete_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Autocomplete_typeof(obj); }

function Autocomplete_extends() { Autocomplete_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Autocomplete_extends.apply(this, arguments); }

function Autocomplete_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Autocomplete_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Autocomplete_createClass(Constructor, protoProps, staticProps) { if (protoProps) Autocomplete_defineProperties(Constructor.prototype, protoProps); if (staticProps) Autocomplete_defineProperties(Constructor, staticProps); return Constructor; }

function Autocomplete_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Autocomplete_setPrototypeOf(subClass, superClass); }

function Autocomplete_setPrototypeOf(o, p) { Autocomplete_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Autocomplete_setPrototypeOf(o, p); }

function Autocomplete_createSuper(Derived) { var hasNativeReflectConstruct = Autocomplete_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Autocomplete_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Autocomplete_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Autocomplete_possibleConstructorReturn(this, result); }; }

function Autocomplete_possibleConstructorReturn(self, call) { if (call && (Autocomplete_typeof(call) === "object" || typeof call === "function")) { return call; } return Autocomplete_assertThisInitialized(self); }

function Autocomplete_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Autocomplete_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function Autocomplete_getPrototypeOf(o) { Autocomplete_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Autocomplete_getPrototypeOf(o); }

function Autocomplete_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var Autocomplete_Autocomplete = /*#__PURE__*/function (_Component) {
  Autocomplete_inherits(Autocomplete, _Component);

  var _super = Autocomplete_createSuper(Autocomplete);

  function Autocomplete(props) {
    var _this;

    Autocomplete_classCallCheck(this, Autocomplete);

    _this = _super.call(this, props);

    Autocomplete_defineProperty(Autocomplete_assertThisInitialized(_this), "onInputValueChange", function (_ref) {
      var inputValue = _ref.inputValue;

      if (inputValue.length > 0) {
        var prefixMatches = _this.props.vocabulary.filter(function (item) {
          return item.toLowerCase().startsWith(inputValue.toLowerCase());
        });

        _this.setState({
          inputItems: prefixMatches
        });
      } else {
        // ...or none, if the input is empty
        _this.setState({
          inputItems: []
        });
      }
    });

    _this.element = /*#__PURE__*/Object(compat_module["createRef"])();
    _this.state = {
      inputItems: props.vocabulary || []
    };
    return _this;
  }

  Autocomplete_createClass(Autocomplete, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.element.current) {
        if (this.props.initialValue) this.element.current.querySelector('input').value = this.props.initialValue;
        if (this.props.focus) this.element.current.querySelector('input').focus({
          preventScroll: true
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _useCombobox = useCombobox({
        items: this.state.inputItems,
        onInputValueChange: this.onInputValueChange,
        onSelectedItemChange: function onSelectedItemChange(_ref2) {
          var inputValue = _ref2.inputValue;
          onSubmit(inputValue);
          setInputValue('');
        }
      }),
          isOpen = _useCombobox.isOpen,
          getMenuProps = _useCombobox.getMenuProps,
          getInputProps = _useCombobox.getInputProps,
          getComboboxProps = _useCombobox.getComboboxProps,
          highlightedIndex = _useCombobox.highlightedIndex,
          getItemProps = _useCombobox.getItemProps,
          setInputValue = _useCombobox.setInputValue;

      var onSubmit = function onSubmit(inputValue) {
        setInputValue('');
        if (inputValue.trim().length > 0) _this2.props.onSubmit(inputValue);
      };

      var onKeyUp = function onKeyUp(evt) {
        var value = evt.target.value;

        if (evt.which == 13 && highlightedIndex == -1) {
          onSubmit(value);
        } else if (evt.which == 40 && value.length == 0) {
          _this2.setState({
            inputItems: _this2.props.vocabulary
          }); // Show all options on key down

        } else if (evt.which == 27) {
          _this2.props.onCancel && _this2.props.onCancel();
        } else {
          _this2.props.onChange && _this2.props.onChange(value);
        }
      };

      return /*#__PURE__*/compat_module["default"].createElement("div", {
        className: "r6o-autocomplete",
        ref: this.element
      }, /*#__PURE__*/compat_module["default"].createElement("div", getComboboxProps(), /*#__PURE__*/compat_module["default"].createElement("input", Autocomplete_extends({}, getInputProps({
        onKeyUp: onKeyUp
      }), {
        placeholder: this.props.placeholder
      }))), /*#__PURE__*/compat_module["default"].createElement("ul", getMenuProps(), isOpen && this.state.inputItems.map(function (item, index) {
        return /*#__PURE__*/compat_module["default"].createElement("li", Autocomplete_extends({
          style: highlightedIndex === index ? {
            backgroundColor: '#bde4ff'
          } : {},
          key: "".concat(item).concat(index)
        }, getItemProps({
          item: item,
          index: index
        })), item);
      })));
    }
  }]);

  return Autocomplete;
}(compat_module["Component"]);


// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/editor/widgets/tag/TagWidget.jsx
var _excluded = ["draft"];

function TagWidget_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TagWidget_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function TagWidget_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function TagWidget_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function TagWidget_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TagWidget_ownKeys(Object(source), true).forEach(function (key) { TagWidget_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TagWidget_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function TagWidget_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function TagWidget_slicedToArray(arr, i) { return TagWidget_arrayWithHoles(arr) || TagWidget_iterableToArrayLimit(arr, i) || TagWidget_unsupportedIterableToArray(arr, i) || TagWidget_nonIterableRest(); }

function TagWidget_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function TagWidget_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TagWidget_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TagWidget_arrayLikeToArray(o, minLen); }

function TagWidget_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function TagWidget_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function TagWidget_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







var getDraftTag = function getDraftTag(existingDraft) {
  return existingDraft ? existingDraft : {
    type: 'TextualBody',
    value: '',
    purpose: 'tagging',
    draft: true
  };
};
/** The basic freetext tag control from original Recogito **/


var TagWidget_TagWidget = function TagWidget(props) {
  // All tags (draft + non-draft)
  var all = props.annotation ? props.annotation.bodies.filter(function (b) {
    return b.type === 'TextualBody' && b.purpose === 'tagging';
  }) : []; // Last draft tag goes into the input field

  var draftTag = getDraftTag(all.slice().reverse().find(function (b) {
    return b.draft;
  })); // All except draft tag

  var tags = all.filter(function (b) {
    return b != draftTag;
  });

  var _useState = Object(compat_module["useState"])(false),
      _useState2 = TagWidget_slicedToArray(_useState, 2),
      showDelete = _useState2[0],
      setShowDelete = _useState2[1];

  var toggle = function toggle(tag) {
    return function (_) {
      if (showDelete === tag) // Removes delete button
        setShowDelete(false);else setShowDelete(tag); // Sets delete button on a different tag
    };
  };

  var onDelete = function onDelete(tag) {
    return function (evt) {
      evt.stopPropagation();
      props.onRemoveBody(tag);
    };
  };

  var onDraftChange = function onDraftChange(value) {
    var prev = draftTag.value.trim();
    var updated = value.trim();

    if (prev.length === 0 && updated.length > 0) {
      props.onAppendBody(TagWidget_objectSpread(TagWidget_objectSpread({}, draftTag), {}, {
        value: updated
      }));
    } else if (prev.length > 0 && updated.length === 0) {
      props.onRemoveBody(draftTag);
    } else {
      props.onUpdateBody(draftTag, TagWidget_objectSpread(TagWidget_objectSpread({}, draftTag), {}, {
        value: updated
      }));
    }
  };

  var onSubmit = function onSubmit(tag) {
    var _draftTag$value = TagWidget_objectSpread(TagWidget_objectSpread({}, draftTag), {}, {
      value: tag
    }),
        draft = _draftTag$value.draft,
        toSubmit = TagWidget_objectWithoutProperties(_draftTag$value, _excluded);

    if (draftTag.value.trim().length === 0) {
      props.onAppendBody(toSubmit);
    } else {
      props.onUpdateBody(draftTag, toSubmit);
    }
  };

  return /*#__PURE__*/compat_module["default"].createElement("div", {
    className: "r6o-widget r6o-tag r6o-nodrag"
  }, tags.length > 0 && /*#__PURE__*/compat_module["default"].createElement("ul", {
    className: "r6o-taglist"
  }, tags.map(function (tag) {
    return /*#__PURE__*/compat_module["default"].createElement("li", {
      key: tag.value,
      onClick: toggle(tag.value)
    }, /*#__PURE__*/compat_module["default"].createElement("span", {
      className: "r6o-label"
    }, tag.value), !props.readOnly && /*#__PURE__*/compat_module["default"].createElement(esm_CSSTransition, {
      "in": showDelete === tag.value,
      timeout: 200,
      classNames: "r6o-delete"
    }, /*#__PURE__*/compat_module["default"].createElement("span", {
      className: "r6o-delete-wrapper",
      onClick: onDelete(tag)
    }, /*#__PURE__*/compat_module["default"].createElement("span", {
      className: "r6o-delete"
    }, /*#__PURE__*/compat_module["default"].createElement(Icons_CloseIcon, {
      width: 12
    })))));
  })), !props.readOnly && /*#__PURE__*/compat_module["default"].createElement(Autocomplete_Autocomplete, {
    focus: props.focus,
    placeholder: src_i18n.t('Add tag...'),
    initialValue: draftTag.value,
    onChange: onDraftChange,
    onSubmit: onSubmit,
    vocabulary: props.vocabulary || []
  }));
};

/* harmony default export */ var tag_TagWidget = (TagWidget_TagWidget);
// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/editor/widgets/WrappedWidget.jsx
function WrappedWidget_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { WrappedWidget_typeof = function _typeof(obj) { return typeof obj; }; } else { WrappedWidget_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return WrappedWidget_typeof(obj); }

function WrappedWidget_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function WrappedWidget_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { WrappedWidget_ownKeys(Object(source), true).forEach(function (key) { WrappedWidget_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { WrappedWidget_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function WrappedWidget_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function WrappedWidget_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function WrappedWidget_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function WrappedWidget_createClass(Constructor, protoProps, staticProps) { if (protoProps) WrappedWidget_defineProperties(Constructor.prototype, protoProps); if (staticProps) WrappedWidget_defineProperties(Constructor, staticProps); return Constructor; }

function WrappedWidget_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) WrappedWidget_setPrototypeOf(subClass, superClass); }

function WrappedWidget_setPrototypeOf(o, p) { WrappedWidget_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return WrappedWidget_setPrototypeOf(o, p); }

function WrappedWidget_createSuper(Derived) { var hasNativeReflectConstruct = WrappedWidget_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = WrappedWidget_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = WrappedWidget_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return WrappedWidget_possibleConstructorReturn(this, result); }; }

function WrappedWidget_possibleConstructorReturn(self, call) { if (call && (WrappedWidget_typeof(call) === "object" || typeof call === "function")) { return call; } return WrappedWidget_assertThisInitialized(self); }

function WrappedWidget_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function WrappedWidget_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function WrappedWidget_getPrototypeOf(o) { WrappedWidget_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return WrappedWidget_getPrototypeOf(o); }



var WrappedWidget_WrappedWidget = /*#__PURE__*/function (_Component) {
  WrappedWidget_inherits(WrappedWidget, _Component);

  var _super = WrappedWidget_createSuper(WrappedWidget);

  function WrappedWidget(props) {
    var _this;

    WrappedWidget_classCallCheck(this, WrappedWidget);

    _this = _super.call(this, props);
    _this.element = /*#__PURE__*/compat_module["default"].createRef();
    return _this;
  }

  WrappedWidget_createClass(WrappedWidget, [{
    key: "renderWidget",
    value: function renderWidget(props) {
      var widgetEl = this.props.widget(WrappedWidget_objectSpread(WrappedWidget_objectSpread({
        annotation: props.annotation,
        readOnly: props.readOnly
      }, props.config), {}, {
        onAppendBody: function onAppendBody(body) {
          return props.onAppendBody(body);
        },
        onUpdateBody: function onUpdateBody(previous, updated) {
          return props.onUpdateBody(previous, updated);
        },
        onRemoveBody: function onRemoveBody(body) {
          return props.onRemoveBody(body);
        },
        onSaveAndClose: function onSaveAndClose() {
          return props.onSaveAndClose();
        }
      })); // Delete previous rendered state

      while (this.element.current.firstChild) {
        this.element.current.removeChild(this.element.current.lastChild);
      }

      this.element.current.appendChild(widgetEl);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.renderWidget(this.props);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(next) {
      if (this.element.current) {
        if (this.props.annotation !== next.annotation) {
          this.renderWidget(next);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/compat_module["default"].createElement("div", {
        ref: this.element,
        className: "widget"
      });
    }
  }]);

  return WrappedWidget;
}(compat_module["Component"]);


// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/editor/widgets/index.jsx
var widgets_excluded = ["widget"];

function widgets_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = widgets_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function widgets_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






/**
 * We'll add React and ReactDOM to the global window, so that 
 * plugins can use it without re-bundling. Also,
 * without this, hooks won't work!
 */

window.React = compat_module["default"];
window.ReactDOM = compat_module["default"];
/** Standard widgets included by default **/

var BUILTIN_WIDGETS = {
  COMMENT: comment_CommentWidget,
  TAG: tag_TagWidget
};
/** Defaults to use if there's no overrides from the host app **/

var DEFAULT_WIDGETS = [/*#__PURE__*/compat_module["default"].createElement(comment_CommentWidget, null), /*#__PURE__*/compat_module["default"].createElement(tag_TagWidget, null)]; // https://stackoverflow.com/questions/33199959/how-to-detect-a-react-component-vs-a-react-element

var isReactComponent = function isReactComponent(component) {
  var isClassComponent = function isClassComponent(component) {
    var _component$prototype;

    return typeof component === 'function' && !!((_component$prototype = component.prototype) !== null && _component$prototype !== void 0 && _component$prototype.isReactComponent);
  };

  var isFunctionComponent = function isFunctionComponent(component) {
    return (// There's no good way to match function components (they are just functions), but
      // this RegEx pattern should catch most minified and unminified variants, e.g.:
      // - return React.createElement('div', {
      // - return pe("div",{
      typeof component === 'function' && (String(component).match(/return .+\(['|"].+['|"],\s*\{/g) || String(component).match(/return .+preact_compat/) || String(component).match(/return .+\.createElement/g))
    );
  };

  return isClassComponent(component) || isFunctionComponent(component);
};
/**
 * There are multiple ways in which users can specify widgets:
 * 
 * 1. string -> name of a built-in widget
 * 2. function -> custom JS plugin
 * 3. React component custom JSX plugin
 * 4. an object in the following form: { widget: (...), args }
 * 
 * In case of 4, the 'widget' property may have the same allowed 
 * values (string, function, React component). The remaining parameters
 * are treated as widget configuration, and are passed along to the
 * widget.
 */


var widgets_getWidget = function getWidget(arg) {
  var instantiate = function instantiate(widget, config) {
    if (typeof widget === 'string' || widget instanceof String) {
      return /*#__PURE__*/compat_module["default"].createElement(BUILTIN_WIDGETS[widget], config);
    } else if (isReactComponent(widget)) {
      return /*#__PURE__*/compat_module["default"].createElement(widget, config);
    } else if (typeof widget === 'function' || widget instanceof Function) {
      return /*#__PURE__*/compat_module["default"].createElement(WrappedWidget_WrappedWidget, {
        widget: widget,
        config: config
      });
    } else {
      throw "".concat(widget, " is not a valid plugin");
    }
  }; // First, check 'top-level' vs. 'nested object' case


  if (arg.widget) {
    var widget = arg.widget,
        config = widgets_objectWithoutProperties(arg, widgets_excluded);

    return instantiate(widget, config);
  } else {
    // No object with args -> instantiate arg directly
    return instantiate(arg);
  }
};
// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/editor/setPosition.js
/** Sets the editor position and determines a proper orientation **/
var setPosition = function setPosition(wrapperEl, editorEl, selectedEl) {
  // Container element bounds
  var containerBounds = wrapperEl.getBoundingClientRect(); // Re-set orientation class

  editorEl.className = 'r6o-editor'; // Make visible

  editorEl.style.opacity = 1; // Default orientation (upwards arrow, at bottom-left of shape)

  var _selectedEl$getBoundi = selectedEl.getBoundingClientRect(),
      left = _selectedEl$getBoundi.left,
      top = _selectedEl$getBoundi.top,
      right = _selectedEl$getBoundi.right,
      height = _selectedEl$getBoundi.height,
      bottom = _selectedEl$getBoundi.bottom;

  editorEl.style.top = "".concat(top + height - containerBounds.top, "px");
  editorEl.style.left = "".concat(left - containerBounds.left, "px");
  var defaultOrientation = editorEl.children[1].getBoundingClientRect(); // Test 1: does right edge extend beyond the width of the page?
  // If so, flip horizontally

  if (defaultOrientation.right > window.innerWidth) {
    editorEl.classList.add('align-right');
    editorEl.style.left = "".concat(right - defaultOrientation.width - containerBounds.left, "px");
  } // Test 2: does the bottom edge extend beyond the height of the page?
  // If so, flip vertically


  if (defaultOrientation.bottom > window.innerHeight) {
    editorEl.classList.add('align-bottom');
    var editorHeight = editorEl.children[1].getBoundingClientRect().height;
    editorEl.style.top = "".concat(top - containerBounds.top - editorHeight, "px");
  } // Get bounding box in current orientation for next tests


  var currentOrientation = editorEl.children[1].getBoundingClientRect(); // Test 3: does the top (still?) extend beyond top of the page?
  // If so, push it down

  if (currentOrientation.top < 0) {
    editorEl.classList.add('pushed-down');
    editorEl.style.top = "".concat(-containerBounds.top, "px");
    var shapeBottom = bottom - containerBounds.top;
    var editorBottom = currentOrientation.height - containerBounds.top;
    if (editorBottom > shapeBottom) editorEl.classList.remove('align-bottom');
  } // Test 4: does the left edge extend beyond the start of the page?
  // If so, push inward


  if (currentOrientation.left < 0) editorEl.style.left = "".concat(-containerBounds.left, "px");
};

/* harmony default export */ var editor_setPosition = (setPosition);
// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/editor/Editor.jsx
function Editor_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Editor_typeof = function _typeof(obj) { return typeof obj; }; } else { Editor_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Editor_typeof(obj); }

var Editor_excluded = ["draft"];

function Editor_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Editor_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Editor_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Editor_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Editor_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Editor_ownKeys(Object(source), true).forEach(function (key) { Editor_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Editor_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Editor_toConsumableArray(arr) { return Editor_arrayWithoutHoles(arr) || Editor_iterableToArray(arr) || Editor_unsupportedIterableToArray(arr) || Editor_nonIterableSpread(); }

function Editor_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function Editor_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Editor_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Editor_arrayLikeToArray(o, minLen); }

function Editor_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function Editor_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return Editor_arrayLikeToArray(arr); }

function Editor_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function Editor_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Editor_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Editor_createClass(Constructor, protoProps, staticProps) { if (protoProps) Editor_defineProperties(Constructor.prototype, protoProps); if (staticProps) Editor_defineProperties(Constructor, staticProps); return Constructor; }

function Editor_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Editor_setPrototypeOf(subClass, superClass); }

function Editor_setPrototypeOf(o, p) { Editor_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Editor_setPrototypeOf(o, p); }

function Editor_createSuper(Derived) { var hasNativeReflectConstruct = Editor_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Editor_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Editor_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Editor_possibleConstructorReturn(this, result); }; }

function Editor_possibleConstructorReturn(self, call) { if (call && (Editor_typeof(call) === "object" || typeof call === "function")) { return call; } return Editor_assertThisInitialized(self); }

function Editor_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Editor_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function Editor_getPrototypeOf(o) { Editor_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Editor_getPrototypeOf(o); }

function Editor_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







/** We need to compare bounds by value, not by object ref **/

var bounds = function bounds(elem) {
  var _elem$getBoundingClie = elem.getBoundingClientRect(),
      top = _elem$getBoundingClie.top,
      left = _elem$getBoundingClie.left,
      width = _elem$getBoundingClie.width,
      height = _elem$getBoundingClie.height;

  return "".concat(top, ", ").concat(left, ", ").concat(width, ", ").concat(height);
};
/**
 * The popup editor component.
 * 
 * TODO instead of just updating the current annotation state,
 * we could create a stack of revisions, and allow going back
 * with CTRL+Z.
 */


var Editor_Editor = /*#__PURE__*/function (_Component) {
  Editor_inherits(Editor, _Component);

  var _super = Editor_createSuper(Editor);

  function Editor(props) {
    var _this;

    Editor_classCallCheck(this, Editor);

    _this = _super.call(this, props); // Reference to the DOM element, so we can set position

    Editor_defineProperty(Editor_assertThisInitialized(_this), "initResizeObserver", function () {
      var _window;

      if ((_window = window) !== null && _window !== void 0 && _window.ResizeObserver) {
        var resizeObserver = new ResizeObserver(function () {
          if (!_this.state.dragged) editor_setPosition(_this.props.wrapperEl, _this.element.current, _this.props.selectedElement);
        });
        resizeObserver.observe(_this.props.wrapperEl);
        return function () {
          return resizeObserver.disconnect();
        };
      } else {
        // Fire setPosition manually *only* for devices that don't support ResizeObserver
        if (!_this.state.dragged) editor_setPosition(_this.props.wrapperEl, _this.element.current, _this.props.selectedElement);
      }
    });

    Editor_defineProperty(Editor_assertThisInitialized(_this), "creationMeta", function (body) {
      var meta = {};
      var user = _this.props.env.user; // Metadata is only added when a user is set, otherwise
      // the Editor operates in 'anonymous mode'.

      if (user) {
        meta.creator = {};
        if (user.id) meta.creator.id = user.id;
        if (user.displayName) meta.creator.name = user.displayName;
        meta[body.created ? 'modified' : 'created'] = _this.props.env.getCurrentTimeAdjusted();
      }

      return meta;
    });

    Editor_defineProperty(Editor_assertThisInitialized(_this), "updateCurrentAnnotation", function (diff, saveImmediately) {
      return _this.setState({
        currentAnnotation: _this.state.currentAnnotation.clone(diff)
      }, function () {
        if (saveImmediately) _this.onOk();
      });
    });

    Editor_defineProperty(Editor_assertThisInitialized(_this), "onAppendBody", function (body, saveImmediately) {
      return _this.updateCurrentAnnotation({
        body: [].concat(Editor_toConsumableArray(_this.state.currentAnnotation.bodies), [Editor_objectSpread(Editor_objectSpread({}, body), _this.creationMeta(body))])
      }, saveImmediately);
    });

    Editor_defineProperty(Editor_assertThisInitialized(_this), "onUpdateBody", function (previous, updated, saveImmediately) {
      return _this.updateCurrentAnnotation({
        body: _this.state.currentAnnotation.bodies.map(function (body) {
          return body === previous ? Editor_objectSpread(Editor_objectSpread({}, updated), _this.creationMeta(updated)) : body;
        })
      }, saveImmediately);
    });

    Editor_defineProperty(Editor_assertThisInitialized(_this), "onRemoveBody", function (body, saveImmediately) {
      return _this.updateCurrentAnnotation({
        body: _this.state.currentAnnotation.bodies.filter(function (b) {
          return b !== body;
        })
      }, saveImmediately);
    });

    Editor_defineProperty(Editor_assertThisInitialized(_this), "onUpsertBody", function (arg1, arg2, saveImmediately) {
      if (arg1 == null && arg2 != null) {
        // Append arg 2 as a new body
        _this.onAppendBody(arg2, saveImmediately);
      } else if (arg1 != null && arg2 != null) {
        // Replace body arg1 with body arg2
        _this.onUpdateBody(arg1, arg2, saveImmediately);
      } else if (arg1 != null && arg2 == null) {
        // Find the first body with the same purpose as arg1,
        // and upsert
        var existing = _this.state.currentAnnotation.bodies.find(function (b) {
          return b.purpose === arg1.purpose;
        });

        if (existing) _this.onUpdateBody(existing, arg1, saveImmediately);else _this.onAppendBody(arg1, saveImmediately);
      }
    });

    Editor_defineProperty(Editor_assertThisInitialized(_this), "onBatchModify", function (diffs, saveImmediately) {
      // First, find previous bodies for auto upserts
      var autoUpserts = diffs.filter(function (d) {
        return d.action === 'upsert' && d.body;
      }).map(function (d) {
        return {
          previous: _this.state.currentAnnotation.bodies.find(function (b) {
            return b.purpose === d.body.purpose;
          }),
          updated: Editor_objectSpread(Editor_objectSpread({}, d.body), _this.creationMeta(d.body))
        };
      });
      var toRemove = diffs.filter(function (d) {
        return d.action === 'remove';
      }).map(function (d) {
        return d.body;
      });
      var toAppend = [].concat(Editor_toConsumableArray(diffs.filter(function (d) {
        return d.action === 'append' || d.action === 'upsert' && d.updated && !d.previous;
      }).map(function (d) {
        return Editor_objectSpread(Editor_objectSpread({}, d.body), _this.creationMeta(d.body));
      })), Editor_toConsumableArray(autoUpserts.filter(function (d) {
        return !d.previous;
      }).map(function (d) {
        return d.updated;
      })));
      var toUpdate = [].concat(Editor_toConsumableArray(diffs.filter(function (d) {
        return d.action === 'update' || d.action === 'upsert' && d.updated && d.previous;
      }).map(function (d) {
        return {
          previous: d.previous,
          updated: Editor_objectSpread(Editor_objectSpread({}, d.updated), _this.creationMeta(d.updated))
        };
      })), Editor_toConsumableArray(autoUpserts.filter(function (d) {
        return d.previous;
      })));
      var updatedBodies = [].concat(Editor_toConsumableArray(_this.state.currentAnnotation.bodies // Remvoe
      .filter(function (b) {
        return !toRemove.includes(b);
      }) // Update
      .map(function (b) {
        var _toUpdate$find = toUpdate.find(function (t) {
          return t.previous === b;
        }),
            updated = _toUpdate$find.updated;

        return updated ? updated : body;
      })), Editor_toConsumableArray(toAppend));

      _this.updateCurrentAnnotation({
        body: updatedBodies
      }, saveImmediately);
    });

    Editor_defineProperty(Editor_assertThisInitialized(_this), "onRemoveAndAppend", function (bodyOrBodiesToRemove, bodyOrBodiesToAppend, saveImmediately) {
      // Shorthand
      var toArray = function toArray(body) {
        return Array.isArray(body) ? body : [body];
      };

      var toRemove = toArray(bodyOrBodiesToRemove);
      var toAppend = toArray(bodyOrBodiesToAppend).map(function (b) {
        return Editor_objectSpread(Editor_objectSpread({}, b), _this.creationMeta(b));
      });

      _this.updateCurrentAnnotation({
        body: [].concat(Editor_toConsumableArray(_this.state.currentAnnotation.bodies.filter(function (b) {
          return !toRemove.includes(b);
        })), Editor_toConsumableArray(toAppend))
      }, saveImmediately);
    });

    Editor_defineProperty(Editor_assertThisInitialized(_this), "onSetProperty", function (property, value) {
      // A list of properties the user is NOT allowed to set
      var isForbidden = ['@context', 'id', 'type', 'body', 'target'].includes(property);
      if (isForbidden) throw new Exception("Cannot set ".concat(property, " - not allowed"));

      if (value) {
        _this.updateCurrentAnnotation(Editor_defineProperty({}, property, value));
      } else {
        var updated = _this.currentAnnotation.clone();

        delete updated[property];

        _this.setState({
          currentAnnotation: updated
        });
      }
    });

    Editor_defineProperty(Editor_assertThisInitialized(_this), "onCancel", function () {
      return _this.props.onCancel(_this.props.annotation);
    });

    Editor_defineProperty(Editor_assertThisInitialized(_this), "onOk", function () {
      // Removes the state payload from all bodies
      var undraft = function undraft(annotation) {
        return annotation.clone({
          body: annotation.bodies.map(function (_ref) {
            var draft = _ref.draft,
                rest = Editor_objectWithoutProperties(_ref, Editor_excluded);

            return rest;
          })
        });
      };

      var currentAnnotation = _this.state.currentAnnotation; // Current annotation is either a selection (if it was created from 
      // scratch just now) or an annotation (if it existed already and was
      // selected for editing)

      if (currentAnnotation.bodies.length === 0 && !_this.props.allowEmpty) {
        if (currentAnnotation.isSelection) _this.onCancel();else _this.props.onAnnotationDeleted(_this.props.annotation);
      } else {
        if (currentAnnotation.isSelection) _this.props.onAnnotationCreated(undraft(currentAnnotation).toAnnotation());else _this.props.onAnnotationUpdated(undraft(currentAnnotation), _this.props.annotation);
      }
    });

    Editor_defineProperty(Editor_assertThisInitialized(_this), "onDelete", function () {
      return _this.props.onAnnotationDeleted(_this.props.annotation);
    });

    _this.element = /*#__PURE__*/compat_module["default"].createRef();
    _this.state = {
      currentAnnotation: props.annotation,
      dragged: false,
      selectionBounds: bounds(props.selectedElement)
    };
    return _this;
  }

  Editor_createClass(Editor, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(next) {
      var selectionBounds = this.state.selectionBounds;
      var nextBounds = bounds(next.selectedElement);
      this.setState({
        currentAnnotation: next.annotation,
        selectionBounds: nextBounds
      });

      if (this.props.modifiedTarget != next.modifiedTarget) {
        // Update in case target was changed (move, resize)
        if (this.state.currentAnnotation) this.updateCurrentAnnotation({
          target: this.props.modifiedTarget
        });
      } // Change editor position if element has moved


      if (selectionBounds != nextBounds) {
        if (this.element.current) {
          this.removeObserver && this.removeObserver();
          this.removeObserver = this.initResizeObserver();
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      // Init observer (triggers setPosition once)
      this.removeObserver = this.initResizeObserver();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      // Remove the observer
      this.removeObserver && this.removeObserver();
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var currentAnnotation = this.state.currentAnnotation; // Use default comment + tag widget unless host app overrides

      var widgets = this.props.widgets ? this.props.widgets.map(widgets_getWidget) : DEFAULT_WIDGETS;

      var isReadOnlyWidget = function isReadOnlyWidget(w) {
        return w.type.disableDelete ? w.type.disableDelete(currentAnnotation, Editor_objectSpread(Editor_objectSpread({}, w.props), {}, {
          readOnly: _this2.props.readOnly,
          env: _this2.props.env
        })) : false;
      };

      var hasDelete = currentAnnotation && ( // annotation has bodies or allowEmpty,
      currentAnnotation.bodies.length > 0 || this.props.allowEmpty) && // AND
      !this.props.readOnly && // we are not in read-only mode AND
      !currentAnnotation.isSelection && // this is not a selection AND
      !widgets.some(isReadOnlyWidget); // every widget is deletable

      return /*#__PURE__*/compat_module["default"].createElement(cjs_default.a, {
        disabled: !this.props.detachable,
        cancel: ".r6o-btn, .r6o-nodrag",
        onDrag: function onDrag() {
          return _this2.setState({
            dragged: true
          });
        }
      }, /*#__PURE__*/compat_module["default"].createElement("div", {
        ref: this.element,
        className: this.state.dragged ? 'r6o-editor dragged' : 'r6o-editor'
      }, /*#__PURE__*/compat_module["default"].createElement("div", {
        className: "r6o-arrow"
      }), /*#__PURE__*/compat_module["default"].createElement("div", {
        className: "r6o-editor-inner"
      }, widgets.map(function (widget, idx) {
        return /*#__PURE__*/compat_module["default"].cloneElement(widget, {
          focus: idx === 0,
          annotation: currentAnnotation,
          readOnly: _this2.props.readOnly,
          env: _this2.props.env,
          onAppendBody: _this2.onAppendBody,
          onUpdateBody: _this2.onUpdateBody,
          onRemoveBody: _this2.onRemoveBody,
          onUpsertBody: _this2.onUpsertBody,
          onRemoveAndAppend: _this2.onRemoveAndAppend,
          onSetProperty: _this2.onSetProperty,
          onSaveAndClose: _this2.onOk
        });
      }), this.props.readOnly ? /*#__PURE__*/compat_module["default"].createElement("div", {
        className: "r6o-footer"
      }, /*#__PURE__*/compat_module["default"].createElement("button", {
        className: "r6o-btn",
        onClick: this.onCancel
      }, src_i18n.t('Close'))) : /*#__PURE__*/compat_module["default"].createElement("div", {
        className: "r6o-footer"
      }, hasDelete && /*#__PURE__*/compat_module["default"].createElement("button", {
        className: "r6o-btn left delete-annotation",
        title: src_i18n.t('Delete'),
        onClick: this.onDelete
      }, /*#__PURE__*/compat_module["default"].createElement(Icons_TrashIcon, {
        width: 12
      })), /*#__PURE__*/compat_module["default"].createElement("button", {
        className: "r6o-btn outline",
        onClick: this.onCancel
      }, src_i18n.t('Cancel')), /*#__PURE__*/compat_module["default"].createElement("button", {
        className: "r6o-btn ",
        onClick: this.onOk
      }, src_i18n.t('Ok'))))));
    }
  }]);

  return Editor;
}(compat_module["Component"]);


// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js
/* harmony default export */ var regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js


function validate(uuid) {
  return typeof uuid === 'string' && regex.test(uuid);
}

/* harmony default export */ var esm_browser_validate = (validate);
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var stringify_i = 0; stringify_i < 256; ++stringify_i) {
  byteToHex.push((stringify_i + 0x100).toString(16).substr(1));
}

function stringify_stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!esm_browser_validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ var esm_browser_stringify = (stringify_stringify);
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return esm_browser_stringify(rnds);
}

/* harmony default export */ var esm_browser_v4 = (v4);
// EXTERNAL MODULE: ./node_modules/fast-deep-equal/index.js
var fast_deep_equal = __webpack_require__(6);
var fast_deep_equal_default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal);

// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/WebAnnotation.js
function WebAnnotation_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function WebAnnotation_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { WebAnnotation_ownKeys(Object(source), true).forEach(function (key) { WebAnnotation_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { WebAnnotation_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function WebAnnotation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function WebAnnotation_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function WebAnnotation_createClass(Constructor, protoProps, staticProps) { if (protoProps) WebAnnotation_defineProperties(Constructor.prototype, protoProps); if (staticProps) WebAnnotation_defineProperties(Constructor, staticProps); return Constructor; }

function WebAnnotation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var WebAnnotation_WebAnnotation = /*#__PURE__*/function () {
  function WebAnnotation(annotation, opts) {
    var _this = this;

    WebAnnotation_classCallCheck(this, WebAnnotation);

    WebAnnotation_defineProperty(this, "clone", function (opt_props, opt_opts) {
      return new WebAnnotation(WebAnnotation_objectSpread(WebAnnotation_objectSpread({}, _this.underlying), opt_props), WebAnnotation_objectSpread(WebAnnotation_objectSpread({}, _this.opts), opt_opts));
    });

    WebAnnotation_defineProperty(this, "selector", function (type) {
      var target = _this.underlying.target;

      if (target.selector) {
        // Normalize to array
        var selectors = Array.isArray(target.selector) ? target.selector : [target.selector];
        return selectors.find(function (s) {
          return s.type === type;
        });
      }
    });

    this.underlying = annotation;
    this.opts = opts;
  }
  /** For convenience - creates an empty web annotation **/


  WebAnnotation_createClass(WebAnnotation, [{
    key: "isEqual",
    value:
    /** An equality check based on the underlying object **/
    function isEqual(other) {
      if ((other === null || other === void 0 ? void 0 : other.type) !== 'Annotation') {
        return false;
      } else if (this.underlying === other.underlying) {
        return true;
      } else if (!this.underlying.id || !other.underlying.id) {
        return false;
      } else {
        return fast_deep_equal_default()(this.underlying, other.underlying);
      }
    }
  }, {
    key: "readOnly",
    get: function get() {
      var _this$opts;

      return (_this$opts = this.opts) === null || _this$opts === void 0 ? void 0 : _this$opts.readOnly;
    }
    /*************************************/

    /* Getters to forward properties of  */

    /* the underlying annotation         */

    /*************************************/

  }, {
    key: "id",
    get: function get() {
      return this.underlying.id;
    }
  }, {
    key: "type",
    get: function get() {
      return this.underlying.type;
    }
  }, {
    key: "motivation",
    get: function get() {
      return this.underlying.motivation;
    }
  }, {
    key: "body",
    get: function get() {
      return this.underlying.body;
    }
  }, {
    key: "target",
    get: function get() {
      return this.underlying.target;
    }
    /** Same as .body, but guaranteed to return an array **/

  }, {
    key: "bodies",
    get: function get() {
      return Array.isArray(this.underlying.body) ? this.underlying.body : [this.underlying.body];
    }
    /** Only bodies are meant to be mutated by the application **/
    ,
    set: function set(bodies) {
      this.underlying.body = bodies;
    }
    /** Same as .target, but guaranteed to return an array **/

  }, {
    key: "targets",
    get: function get() {
      return Array.isArray(this.underlying.target) ? this.underlying.target : [this.underlying.target];
    }
    /*****************************************/

    /* Various access helpers and shorthands */

    /*****************************************/

    /** Selector of the given type **/

  }, {
    key: "quote",
    get:
    /** Shorthand for the 'exact' field of the TextQuoteSelector **/
    function get() {
      return this.selector('TextQuoteSelector').exact;
    }
    /** Shorthand for the 'start' field of the TextPositionSelector **/

  }, {
    key: "start",
    get: function get() {
      return this.selector('TextPositionSelector').start;
    }
    /** Shorthand for the 'end' field of the TextPositionSelector **/

  }, {
    key: "end",
    get: function get() {
      return this.selector('TextPositionSelector').end;
    }
  }]);

  return WebAnnotation;
}();

WebAnnotation_defineProperty(WebAnnotation_WebAnnotation, "create", function (args) {
  var stub = {
    '@context': 'http://www.w3.org/ns/anno.jsonld',
    'type': 'Annotation',
    'id': "#".concat(esm_browser_v4()),
    'body': []
  };
  return new WebAnnotation_WebAnnotation(WebAnnotation_objectSpread(WebAnnotation_objectSpread({}, stub), args));
});


// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/Selection.js
function Selection_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Selection_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Selection_ownKeys(Object(source), true).forEach(function (key) { Selection_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Selection_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Selection_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Selection_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Selection_createClass(Constructor, protoProps, staticProps) { if (protoProps) Selection_defineProperties(Constructor.prototype, protoProps); if (staticProps) Selection_defineProperties(Constructor, staticProps); return Constructor; }

function Selection_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * An "annotation in draft mode". Really the same
 * data structure, but as a separate class so we can
 * tell things apart properly.
 */

var Selection_Selection = /*#__PURE__*/function () {
  function Selection(_target, body) {
    var _this = this;

    Selection_classCallCheck(this, Selection);

    Selection_defineProperty(this, "clone", function (opt_props) {
      // Deep-clone
      var cloned = new Selection();
      cloned.underlying = JSON.parse(JSON.stringify(_this.underlying));
      if (opt_props) cloned.underlying = Selection_objectSpread(Selection_objectSpread({}, cloned.underlying), opt_props);
      return cloned;
    });

    Selection_defineProperty(this, "selector", function (type) {
      var target = _this.underlying.target;

      if (target.selector) {
        // Normalize to array
        var selectors = Array.isArray(target.selector) ? target.selector : [target.selector];
        return selectors.find(function (s) {
          return s.type === type;
        });
      }
    });

    Selection_defineProperty(this, "toAnnotation", function () {
      var a = Object.assign({}, _this.underlying, {
        '@context': 'http://www.w3.org/ns/anno.jsonld',
        'type': 'Annotation',
        'id': "#".concat(esm_browser_v4())
      });
      return new WebAnnotation_WebAnnotation(a);
    });

    this.underlying = {
      type: 'Selection',
      body: body || [],
      target: _target
    };
  }
  /** Creates a copy of this selection **/


  Selection_createClass(Selection, [{
    key: "type",
    get: function get() {
      return this.underlying.type;
    }
  }, {
    key: "body",
    get: function get() {
      return this.underlying.body;
    }
  }, {
    key: "target",
    get: function get() {
      return this.underlying.target;
    }
  }, {
    key: "targets",
    get: function get() {
      return Array.isArray(this.underlying.target) ? this.underlying.target : [this.underlying.target];
    }
    /** For consistency with WebAnnotation **/

  }, {
    key: "isEqual",
    value: function isEqual(other) {
      if (!other) {
        return false;
      } else {
        return fast_deep_equal_default()(this.underlying, other.underlying);
      }
    }
  }, {
    key: "bodies",
    get: function get() {
      return Array.isArray(this.underlying.body) ? this.underlying.body : [this.underlying.body];
    }
  }, {
    key: "quote",
    get:
    /** Shorthand for the 'exact' field of the TextQuoteSelector **/
    function get() {
      return this.selector('TextQuoteSelector').exact;
    }
    /*******************************************/

    /* Selection-specific properties & methods */

    /*******************************************/

  }, {
    key: "isSelection",
    get: function get() {
      return true;
    }
  }]);

  return Selection;
}();


// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/Environment.js
/**
 * Difference between server time and client time, in milliseconds
 */
var serverTimeDifference = 0;
/* harmony default export */ var Environment = (function () {
  return {
    /**
     * A generic container for RecogitoJS/Annotorious 
     * to store globally available environment info. The 
     * most important piece of information is user auth 
     * info. Example:
     *
     * user: { id, displayName, email, avatarURL }
     * 
     * id ........... the host application user ID (should be a URI, but could be username) REQUIRED
     * displayName .. screen display or nickname OPTIONAL (id is used when empty)
     * email ........ OPTIONAL
     * avatarURL .... OPTIONAL + not supported at the moment
     */

    /**
     * Sets a server time, so we can correct browser time error. 
     * Note for the super-picky: client-server latency will introduce
     * an error we don't account for.
     */
    setServerTime: function setServerTime(serverNow) {
      var browserNow = Date.now();
      serverTimeDifference = serverNow - browserNow;
    },

    /** 
     * Returns the current 'server time', i.e. browser time 
     * adjusted by the serverTimeDifference value.
     */
    getCurrentTimeAdjusted: function getCurrentTimeAdjusted() {
      return new Date(Date.now() + serverTimeDifference).toISOString();
    },

    /** Re-adjusts the given server timestamp to browser time **/
    toClientTime: function toClientTime(serverTime) {
      return Date.parse(serverTime) - serverTimeDifference;
    }
  };
});
// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/utils/index.js

/**
 * Helper to init the i18n class with a pre-defined or auto-detected locale.
 */

var utils_setLocale = function setLocale(locale, opt_messages) {
  if (locale) {
    var l = locale === 'auto' ? window.navigator.userLanguage || window.navigator.language : locale;

    try {
      src_i18n.init(l.split('-')[0].toLowerCase(), opt_messages);
    } catch (error) {
      console.warn("Unsupported locale '".concat(l, "'. Falling back to default en."));
    }
  } else {
    src_i18n.init(null, opt_messages);
  }
};
// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/src/index.js







// EXTERNAL MODULE: external {"root":"OpenSeadragon","commonjs":"openseadragon","commonjs2":"openseadragon","amd":"openseadragon"}
var external_root_OpenSeadragon_commonjs_openseadragon_commonjs2_openseadragon_amd_openseadragon_ = __webpack_require__(3);
var external_root_OpenSeadragon_commonjs_openseadragon_commonjs2_openseadragon_amd_openseadragon_default = /*#__PURE__*/__webpack_require__.n(external_root_OpenSeadragon_commonjs_openseadragon_commonjs2_openseadragon_amd_openseadragon_);

// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/util/SVG.js
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

var getClassNames = function getClassNames(el) {
  var attr = el.getAttribute('class');
  return attr ? new Set(attr.split(' ')) : new Set();
}; // IE11 doesn't support adding/removing classes to SVG elements except 
// via .setAttribute


var SVG_addClass = function addClass(el, className) {
  var classNames = getClassNames(el);
  classNames.add(className);
  el.setAttribute('class', Array.from(classNames).join(' '));
};
var SVG_removeClass = function removeClass(el, className) {
  var classNames = getClassNames(el);
  classNames["delete"](className);
  if (classNames.size === 0) el.removeAttribute('class');else el.setAttribute('class', Array.from(classNames).join(' '));
};
var SVG_hasClass = function hasClass(el, className) {
  return getClassNames(el).has(className);
};
// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/selectors/RectFragment.js
function RectFragment_slicedToArray(arr, i) { return RectFragment_arrayWithHoles(arr) || RectFragment_iterableToArrayLimit(arr, i) || RectFragment_unsupportedIterableToArray(arr, i) || RectFragment_nonIterableRest(); }

function RectFragment_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function RectFragment_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return RectFragment_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return RectFragment_arrayLikeToArray(o, minLen); }

function RectFragment_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function RectFragment_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function RectFragment_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


/** 
 * Parses a W3C Web Annotation FragmentSelector conforming
 * to the Media Fragments spec. This (currently) naive 
 * implementation can only deal with well-formed xywh=pixel
 * fragments. 
 */

var parseRectFragment = function parseRectFragment(annotation) {
  var selector = annotation.selector('FragmentSelector');

  if (selector !== null && selector !== void 0 && selector.conformsTo.startsWith('http://www.w3.org/TR/media-frags')) {
    var value = selector.value;
    var format = value.includes(':') ? value.substring(value.indexOf('=') + 1, value.indexOf(':')) : 'pixel';
    var coords = value.includes(':') ? value.substring(value.indexOf(':') + 1) : value.substring(value.indexOf('=') + 1);

    var _coords$split$map = coords.split(',').map(parseFloat),
        _coords$split$map2 = RectFragment_slicedToArray(_coords$split$map, 4),
        x = _coords$split$map2[0],
        y = _coords$split$map2[1],
        w = _coords$split$map2[2],
        h = _coords$split$map2[3];

    return {
      x: x,
      y: y,
      w: w,
      h: h,
      format: format
    };
  }
};
/** Serializes a (x, y, w, h)-tuple as Media Fragment selector **/

var toRectFragment = function toRectFragment(x, y, w, h, styleClass, image) {
  if (styleClass) {
    return {
      source: image.src,
      styleClass: styleClass,
      selector: {
        type: "FragmentSelector",
        conformsTo: "http://www.w3.org/TR/media-frags/",
        value: "xywh=pixel:".concat(x, ",").concat(y, ",").concat(w, ",").concat(h)
      }
    };
  } else {
    return {
      source: image.src,
      selector: {
        type: "FragmentSelector",
        conformsTo: "http://www.w3.org/TR/media-frags/",
        value: "xywh=pixel:".concat(x, ",").concat(y, ",").concat(w, ",").concat(h)
      }
    };
  }
};
/** Shorthand to apply the given (x, y, w, h) to the SVG shape **/

var setXYWH = function setXYWH(shape, x, y, w, h) {
  shape.setAttribute('x', x);
  shape.setAttribute('y', y);
  shape.setAttribute('width', w);
  shape.setAttribute('height', h);
};

var RectFragment_drawRectMask = function drawRectMask(imageDimensions, x, y, w, h) {
  var mask = document.createElementNS(SVG_NAMESPACE, 'path');
  mask.setAttribute('fill-rule', 'evenodd');
  var naturalWidth = imageDimensions.naturalWidth,
      naturalHeight = imageDimensions.naturalHeight;
  mask.setAttribute('d', "M0 0 h".concat(naturalWidth, " v").concat(naturalHeight, " h-").concat(naturalWidth, " z M").concat(x, " ").concat(y, " h").concat(w, " v").concat(h, " h-").concat(w, " z"));
  return mask;
};
var setRectMaskSize = function setRectMaskSize(mask, imageDimensions, x, y, w, h) {
  var naturalWidth = imageDimensions.naturalWidth,
      naturalHeight = imageDimensions.naturalHeight;
  mask.setAttribute('d', "M0 0 h".concat(naturalWidth, " v").concat(naturalHeight, " h-").concat(naturalWidth, " z M").concat(x, " ").concat(y, " h").concat(w, " v").concat(h, " h-").concat(w, " z"));
};
/** 
 * Draws an SVG rectangle, either from an annotation, or an
 * (x, y, w, h)-tuple.
 */

var RectFragment_drawRect = function drawRect(arg1, arg2, arg3, arg4) {
  var _ref = arg1.type === 'Annotation' || arg1.type === 'Selection' ? parseRectFragment(arg1) : {
    x: arg1,
    y: arg2,
    w: arg3,
    h: arg4
  },
      x = _ref.x,
      y = _ref.y,
      w = _ref.w,
      h = _ref.h;

  var g = document.createElementNS(SVG_NAMESPACE, 'g');
  var outerRect = document.createElementNS(SVG_NAMESPACE, 'rect');
  outerRect.setAttribute('class', 'a9s-outer');
  setXYWH(outerRect, x, y, w, h);
  g.appendChild(outerRect);
  return g;
};
/** Gets the (x, y, w, h)-values from the attributes of the SVG group **/

var getRectSize = function getRectSize(g) {
  var outerRect = g.querySelector('.a9s-outer');
  var x = parseFloat(outerRect.getAttribute('x'));
  var y = parseFloat(outerRect.getAttribute('y'));
  var w = parseFloat(outerRect.getAttribute('width'));
  var h = parseFloat(outerRect.getAttribute('height'));
  return {
    x: x,
    y: y,
    w: w,
    h: h
  };
};
/** Applies the (x, y, w, h)-values to the rects in the SVG group **/

var setRectSize = function setRectSize(g, x, y, w, h) {
  var outerRect = g.querySelector('.a9s-outer');
  setXYWH(outerRect, x, y, w, h);
};
/** 
 * Shorthand to get the area (rectangle w x h) from the 
 * annotation's fragment selector. 
 */

var rectArea = function rectArea(annotation) {
  var _parseRectFragment = parseRectFragment(annotation),
      w = _parseRectFragment.w,
      h = _parseRectFragment.h;

  return w * h;
};
// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/tools/rectangle/RubberbandRect.js
function RubberbandRect_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function RubberbandRect_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function RubberbandRect_createClass(Constructor, protoProps, staticProps) { if (protoProps) RubberbandRect_defineProperties(Constructor.prototype, protoProps); if (staticProps) RubberbandRect_defineProperties(Constructor, staticProps); return Constructor; }

function RubberbandRect_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * A 'rubberband' selection tool for creating a rectangle by
 * clicking and dragging.
 */

var RubberbandRect_RubberbandRect = /*#__PURE__*/function () {
  function RubberbandRect(anchorX, anchorY, g, config, env) {
    var _this = this;

    RubberbandRect_classCallCheck(this, RubberbandRect);

    RubberbandRect_defineProperty(this, "dragTo", function (oppositeX, oppositeY) {
      // Make visible
      _this.group.style.display = null;
      _this.opposite = [oppositeX, oppositeY];
      var _this$bbox = _this.bbox,
          x = _this$bbox.x,
          y = _this$bbox.y,
          w = _this$bbox.w,
          h = _this$bbox.h;
      setRectMaskSize(_this.mask, _this.env.image, x, y, w, h);
      setRectSize(_this.rect, x, y, w, h);
    });

    RubberbandRect_defineProperty(this, "getBoundingClientRect", function () {
      return _this.rect.getBoundingClientRect();
    });

    RubberbandRect_defineProperty(this, "toSelection", function () {
      var _this$bbox2 = _this.bbox,
          x = _this$bbox2.x,
          y = _this$bbox2.y,
          w = _this$bbox2.w,
          h = _this$bbox2.h;
      return new Selection_Selection(toRectFragment(x, y, w, h, _this.styleClass, _this.env.image));
    });

    RubberbandRect_defineProperty(this, "destroy", function () {
      _this.group.parentNode.removeChild(_this.group);

      _this.mask = null;
      _this.rect = null;
      _this.group = null;
    });

    this.anchor = [anchorX, anchorY];
    this.opposite = [anchorX, anchorY];
    this.env = env;
    this.group = document.createElementNS(SVG_NAMESPACE, 'g');
    this.styleClass = config.styleClass;

    if (config.styleClass) {
      this.group.setAttribute('class', config.styleClass);
    }

    this.mask = RectFragment_drawRectMask(env.image, anchorX, anchorY, 2, 2);
    this.mask.setAttribute('class', 'a9s-selection-mask');
    this.rect = RectFragment_drawRect(anchorX, anchorY, 2, 2);
    this.rect.setAttribute('class', 'a9s-selection'); // We make the selection transparent to 
    // pointer events because it would interfere with the 
    // rendered annotations' mouseleave/enter events

    this.group.style.pointerEvents = 'none'; // Additionally, selection remains hidden until 
    // the user actually moves the mouse

    this.group.style.display = 'none';
    this.group.appendChild(this.mask);
    this.group.appendChild(this.rect);
    g.appendChild(this.group);
  }

  RubberbandRect_createClass(RubberbandRect, [{
    key: "bbox",
    get: function get() {
      var w = this.opposite[0] - this.anchor[0];
      var h = this.opposite[1] - this.anchor[1];
      return {
        x: w > 0 ? this.anchor[0] : this.opposite[0],
        y: h > 0 ? this.anchor[1] : this.opposite[1],
        w: Math.max(1, Math.abs(w)),
        // Negative values
        h: Math.max(1, Math.abs(h))
      };
    }
  }, {
    key: "element",
    get: function get() {
      return this.rect;
    }
  }]);

  return RubberbandRect;
}();


// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/tools/EditableShape.js
function EditableShape_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { EditableShape_typeof = function _typeof(obj) { return typeof obj; }; } else { EditableShape_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return EditableShape_typeof(obj); }

function EditableShape_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EditableShape_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EditableShape_createClass(Constructor, protoProps, staticProps) { if (protoProps) EditableShape_defineProperties(Constructor.prototype, protoProps); if (staticProps) EditableShape_defineProperties(Constructor, staticProps); return Constructor; }

function EditableShape_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EditableShape_setPrototypeOf(subClass, superClass); }

function EditableShape_setPrototypeOf(o, p) { EditableShape_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EditableShape_setPrototypeOf(o, p); }

function EditableShape_createSuper(Derived) { var hasNativeReflectConstruct = EditableShape_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = EditableShape_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = EditableShape_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return EditableShape_possibleConstructorReturn(this, result); }; }

function EditableShape_possibleConstructorReturn(self, call) { if (call && (EditableShape_typeof(call) === "object" || typeof call === "function")) { return call; } return EditableShape_assertThisInitialized(self); }

function EditableShape_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EditableShape_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function EditableShape_getPrototypeOf(o) { EditableShape_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EditableShape_getPrototypeOf(o); }

function EditableShape_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var IMPLEMENTATION_MISSING = "An implementation is missing";

var EditableShape_EditableShape = /*#__PURE__*/function (_EventEmitter) {
  EditableShape_inherits(EditableShape, _EventEmitter);

  var _super = EditableShape_createSuper(EditableShape);

  function EditableShape(annotation, g, config, env) {
    var _this;

    EditableShape_classCallCheck(this, EditableShape);

    _this = _super.call(this);

    EditableShape_defineProperty(EditableShape_assertThisInitialized(_this), "enableResponsive", function () {
      if (window.ResizeObserver) {
        _this.resizeObserver = new ResizeObserver(function () {
          var svgBounds = _this.svg.getBoundingClientRect();

          var _this$svg$viewBox$bas = _this.svg.viewBox.baseVal,
              width = _this$svg$viewBox$bas.width,
              height = _this$svg$viewBox$bas.height;
          var scale = Math.max(width / svgBounds.width, height / svgBounds.height);

          _this.scaleHandles(scale);
        });

        _this.resizeObserver.observe(_this.svg.parentNode);
      }
    });

    EditableShape_defineProperty(EditableShape_assertThisInitialized(_this), "drawHandle", function (x, y) {
      var containerGroup = document.createElementNS(SVG_NAMESPACE, 'g');
      containerGroup.setAttribute('class', 'a9s-handle');
      var group = document.createElementNS(SVG_NAMESPACE, 'g');

      var drawCircle = function drawCircle(r) {
        var c = document.createElementNS(SVG_NAMESPACE, 'circle');
        c.setAttribute('cx', x);
        c.setAttribute('cy', y);
        c.setAttribute('r', r);
        return c;
      };

      var radius = _this.config.handleRadius || 6;
      var outer = drawCircle(radius + 1);
      outer.setAttribute('class', 'a9s-handle-outer');
      group.appendChild(outer);
      containerGroup.appendChild(group);
      return containerGroup;
    });

    EditableShape_defineProperty(EditableShape_assertThisInitialized(_this), "setHandleXY", function (handle, x, y) {
      var outer = handle.querySelector('.a9s-handle-outer');
      outer.setAttribute('cx', x);
      outer.setAttribute('cy', y);
    });

    EditableShape_defineProperty(EditableShape_assertThisInitialized(_this), "getHandleXY", function (handle) {
      var outer = handle.querySelector('.a9s-handle-outer');
      return {
        x: parseFloat(outer.getAttribute('cx')),
        y: parseFloat(outer.getAttribute('cy'))
      };
    });

    EditableShape_defineProperty(EditableShape_assertThisInitialized(_this), "scaleHandles", function (scale) {
      _this.handles.forEach(function (handle) {
        var outer = handle.querySelector('.a9s-handle-outer');
        var radius = scale * (_this.config.handleRadius || 6);
        outer.setAttribute('r', radius);
      });
    });

    EditableShape_defineProperty(EditableShape_assertThisInitialized(_this), "getSVGPoint", function (evt) {
      var bbox = _this.svg.getBoundingClientRect();

      var x = evt.clientX - bbox.x;
      var y = evt.clientY - bbox.y;

      var pt = _this.svg.createSVGPoint();

      var _this$svg$getBounding = _this.svg.getBoundingClientRect(),
          left = _this$svg$getBounding.left,
          top = _this$svg$getBounding.top;

      pt.x = x + left;
      pt.y = y + top;
      return pt.matrixTransform(_this.g.getScreenCTM().inverse());
    });

    _this.annotation = annotation;
    _this.g = g;
    _this.config = config;
    _this.env = env;
    _this.svg = g.closest('svg'); // Implementations need to override the handles list

    _this.handles = []; // Bit of a hack. If we are dealing with a 'real' image, we enable
    // reponsive mode. OpenSeadragon handles scaling in a different way,
    // so we don't need responsive mode.

    var image = env.image;
    if (image instanceof Element || image instanceof HTMLDocument) _this.enableResponsive();
    return _this;
  }

  EditableShape_createClass(EditableShape, [{
    key: "element",
    get: // Implementations MUST override theis method
    function get() {
      throw new Error(IMPLEMENTATION_MISSING);
    } // Implementations can extend this (calling super)

  }, {
    key: "destroy",
    value: function destroy() {
      if (this.resizeObserver) this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
  }]);

  return EditableShape;
}(tiny_emitter_default.a);


// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/util/Formatting.js


var Formatting_appendFormatterEl = function appendFormatterEl(formatterEl, shape) {
  var _shape$getBBox = shape.getBBox(),
      x = _shape$getBBox.x,
      y = _shape$getBBox.y,
      width = _shape$getBBox.width,
      height = _shape$getBBox.height;

  var svgEl = document.createElementNS(SVG_NAMESPACE, 'svg');
  svgEl.setAttribute('class', 'a9s-formatter-el');
  svgEl.setAttribute('x', x);
  svgEl.setAttribute('y', y);
  svgEl.setAttribute('width', width);
  svgEl.setAttribute('height', height);
  var g = document.createElementNS(SVG_NAMESPACE, 'g');
  g.appendChild(formatterEl);
  y;
  svgEl.appendChild(g);
  shape.append(svgEl);
};
/**
 * A formatter is a user-defined function that takes an annotation as input,
 * and returns either a string, or an object. If a string is returned, this
 * will be appended to the annotation element CSS class list. Otherwise, the
 * object can have the following properties: 
 * 
 * - 'className' added to the CSS class list
 * - 'data-*' added as data attributes
 * - 'style' a list of CSS styles (in the form of a string) 
 */


var Formatting_format = function format(shape, annotation, formatter) {
  // The formatter can be undefined
  if (!formatter) return shape;
  var format = formatter(annotation); // The formatter is allowed to return null

  if (!format) return shape;

  if (typeof format === 'string' || format instanceof String) {
    // Apply CSS class
    SVG_addClass(shape, format);
  } else if (format.nodeType === Node.ELEMENT_NODE) {
    Formatting_appendFormatterEl(format, shape);
  } else {
    var className = format.className,
        style = format.style,
        element = format.element;
    if (className) SVG_addClass(shape, className);

    if (style) {
      var outer = shape.querySelector('.a9s-outer');

      if (outer) {
        outer.setAttribute('style', style);
      } else {
        shape.setAttribute('style', style);
      }
    }

    if (element) Formatting_appendFormatterEl(element, shape);

    for (var key in format) {
      if (format.hasOwnProperty(key) && key.startsWith('data-')) {
        shape.setAttribute(key, format[key]);
      }
    }
  }
};
var setFormatterElSize = function setFormatterElSize(group, x, y, w, h) {
  var formatterEl = group.querySelector('.a9s-formatter-el');

  if (formatterEl) {
    formatterEl.setAttribute('x', x);
    formatterEl.setAttribute('y', y);
    formatterEl.setAttribute('width', w);
    formatterEl.setAttribute('height', h);
  }
};
// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/tools/rectangle/EditableRect.js
function EditableRect_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { EditableRect_typeof = function _typeof(obj) { return typeof obj; }; } else { EditableRect_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return EditableRect_typeof(obj); }

function EditableRect_slicedToArray(arr, i) { return EditableRect_arrayWithHoles(arr) || EditableRect_iterableToArrayLimit(arr, i) || EditableRect_unsupportedIterableToArray(arr, i) || EditableRect_nonIterableRest(); }

function EditableRect_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function EditableRect_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return EditableRect_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return EditableRect_arrayLikeToArray(o, minLen); }

function EditableRect_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function EditableRect_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function EditableRect_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function EditableRect_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EditableRect_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EditableRect_createClass(Constructor, protoProps, staticProps) { if (protoProps) EditableRect_defineProperties(Constructor.prototype, protoProps); if (staticProps) EditableRect_defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = EditableRect_getPrototypeOf(object); if (object === null) break; } return object; }

function EditableRect_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EditableRect_setPrototypeOf(subClass, superClass); }

function EditableRect_setPrototypeOf(o, p) { EditableRect_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EditableRect_setPrototypeOf(o, p); }

function EditableRect_createSuper(Derived) { var hasNativeReflectConstruct = EditableRect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = EditableRect_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = EditableRect_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return EditableRect_possibleConstructorReturn(this, result); }; }

function EditableRect_possibleConstructorReturn(self, call) { if (call && (EditableRect_typeof(call) === "object" || typeof call === "function")) { return call; } return EditableRect_assertThisInitialized(self); }

function EditableRect_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EditableRect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function EditableRect_getPrototypeOf(o) { EditableRect_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EditableRect_getPrototypeOf(o); }

function EditableRect_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





/**
 * An editable rectangle shape.
 */

var EditableRect_EditableRect = /*#__PURE__*/function (_EditableShape) {
  EditableRect_inherits(EditableRect, _EditableShape);

  var _super = EditableRect_createSuper(EditableRect);

  function EditableRect(annotation, g, config, env) {
    var _this;

    EditableRect_classCallCheck(this, EditableRect);

    _this = _super.call(this, annotation, g, config, env);

    EditableRect_defineProperty(EditableRect_assertThisInitialized(_this), "setSize", function (x, y, w, h) {
      setRectSize(_this.rectangle, x, y, w, h);
      setRectMaskSize(_this.mask, _this.env.image, x, y, w, h);
      setFormatterElSize(_this.elementGroup, x, y, w, h);

      var _this$handles = EditableRect_slicedToArray(_this.handles, 4),
          topleft = _this$handles[0],
          topright = _this$handles[1],
          bottomright = _this$handles[2],
          bottomleft = _this$handles[3];

      _this.setHandleXY(topleft, x, y);

      _this.setHandleXY(topright, x + w, y);

      _this.setHandleXY(bottomright, x + w, y + h);

      _this.setHandleXY(bottomleft, x, y + h);
    });

    EditableRect_defineProperty(EditableRect_assertThisInitialized(_this), "stretchCorners", function (draggedHandleIdx, anchorHandle, mousePos) {
      var anchor = _this.getHandleXY(anchorHandle);

      var width = mousePos.x - anchor.x;
      var height = mousePos.y - anchor.y;
      var x = width > 0 ? anchor.x : mousePos.x;
      var y = height > 0 ? anchor.y : mousePos.y;
      var w = Math.abs(width);
      var h = Math.abs(height);
      setRectSize(_this.rectangle, x, y, w, h);
      setRectMaskSize(_this.mask, _this.env.image, x, y, w, h);
      setFormatterElSize(_this.elementGroup, x, y, w, h); // Anchor (=opposite handle) stays in place, dragged handle moves with mouse

      _this.setHandleXY(_this.handles[draggedHandleIdx], mousePos.x, mousePos.y); // Handles left and right of the dragged handle


      var left = _this.handles[(draggedHandleIdx + 3) % 4];

      _this.setHandleXY(left, anchor.x, mousePos.y);

      var right = _this.handles[(draggedHandleIdx + 5) % 4];

      _this.setHandleXY(right, mousePos.x, anchor.y);

      return {
        x: x,
        y: y,
        w: w,
        h: h
      };
    });

    EditableRect_defineProperty(EditableRect_assertThisInitialized(_this), "onGrab", function (grabbedElem) {
      return function (evt) {
        _this.grabbedElem = grabbedElem;

        var pos = _this.getSVGPoint(evt);

        var _getRectSize = getRectSize(_this.rectangle),
            x = _getRectSize.x,
            y = _getRectSize.y;

        _this.mouseOffset = {
          x: pos.x - x,
          y: pos.y - y
        };
      };
    });

    EditableRect_defineProperty(EditableRect_assertThisInitialized(_this), "onMouseMove", function (evt) {
      var constrain = function constrain(coord, max) {
        return coord < 0 ? 0 : coord > max ? max : coord;
      };

      if (_this.grabbedElem) {
        var pos = _this.getSVGPoint(evt);

        if (_this.grabbedElem === _this.rectangle) {
          // x/y changes by mouse offset, w/h remains unchanged
          var _getRectSize2 = getRectSize(_this.rectangle),
              w = _getRectSize2.w,
              h = _getRectSize2.h;

          var _this$env$image = _this.env.image,
              naturalWidth = _this$env$image.naturalWidth,
              naturalHeight = _this$env$image.naturalHeight;
          var x = constrain(pos.x - _this.mouseOffset.x, naturalWidth - w);
          var y = constrain(pos.y - _this.mouseOffset.y, naturalHeight - h);

          _this.setSize(x, y, w, h);

          _this.emit('update', toRectFragment(x, y, w, h, _this.styleClass, _this.env.image));
        } else {
          // Mouse position replaces one of the corner coords, depending
          // on which handle is the grabbed element
          var handleIdx = _this.handles.indexOf(_this.grabbedElem);

          var oppositeHandle = handleIdx < 2 ? _this.handles[handleIdx + 2] : _this.handles[handleIdx - 2];

          var _this$stretchCorners = _this.stretchCorners(handleIdx, oppositeHandle, pos),
              _x2 = _this$stretchCorners.x,
              _y2 = _this$stretchCorners.y,
              _w2 = _this$stretchCorners.w,
              _h2 = _this$stretchCorners.h;

          _this.emit('update', toRectFragment(_x2, _y2, _w2, _h2, _this.styleClass, _this.env.image));
        }
      }
    });

    EditableRect_defineProperty(EditableRect_assertThisInitialized(_this), "onMouseUp", function (evt) {
      _this.grabbedElem = null;
      _this.mouseOffset = null;
    });

    _this.svg.addEventListener('mousemove', _this.onMouseMove);

    _this.svg.addEventListener('mouseup', _this.onMouseUp);

    var _parseRectFragment = parseRectFragment(annotation),
        _x = _parseRectFragment.x,
        _y = _parseRectFragment.y,
        _w = _parseRectFragment.w,
        _h = _parseRectFragment.h; // SVG markup for this class looks like this:
    // 
    // <g>
    //   <path class="a9s-selection mask"... />
    //   <g> <-- return this node as .element
    //     <rect class="a9s-outer" ... />
    //     <g class="a9s-handle" ...> ... </g>
    //     <g class="a9s-handle" ...> ... </g>
    //     <g class="a9s-handle" ...> ... </g>
    //     <g class="a9s-handle" ...> ... </g>
    //   </g> 
    // </g>


    _this.styleClass = annotation.target.styleClass; // 'g' for the editable rect compound shape

    _this.containerGroup = document.createElementNS(SVG_NAMESPACE, 'g');

    if (_this.styleClass) {
      _this.containerGroup.setAttribute('class', _this.styleClass);
    }

    _this.mask = RectFragment_drawRectMask(env.image, _x, _y, _w, _h);

    _this.mask.setAttribute('class', 'a9s-selection-mask');

    _this.containerGroup.appendChild(_this.mask); // The 'element' = rectangles + handles


    _this.elementGroup = document.createElementNS(SVG_NAMESPACE, 'g');

    _this.elementGroup.setAttribute('class', 'a9s-annotation editable selected');

    _this.rectangle = RectFragment_drawRect(_x, _y, _w, _h);

    _this.rectangle.querySelector('.a9s-outer').addEventListener('mousedown', _this.onGrab(_this.rectangle));

    _this.elementGroup.appendChild(_this.rectangle);

    _this.handles = [[_x, _y], [_x + _w, _y], [_x + _w, _y + _h], [_x, _y + _h]].map(function (t) {
      var _t = EditableRect_slicedToArray(t, 2),
          x = _t[0],
          y = _t[1];

      var handle = _this.drawHandle(x, y);

      handle.addEventListener('mousedown', _this.onGrab(handle));

      _this.elementGroup.appendChild(handle);

      return handle;
    });

    _this.containerGroup.appendChild(_this.elementGroup);

    g.appendChild(_this.containerGroup);
    Formatting_format(_this.rectangle, annotation, config.formatter); // The grabbed element (handle or entire group), if any

    _this.grabbedElem = null; // Mouse xy offset inside the shape, if mouse pressed

    _this.mouseOffset = null;
    return _this;
  }

  EditableRect_createClass(EditableRect, [{
    key: "element",
    get: function get() {
      return this.elementGroup;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.containerGroup.parentNode.removeChild(this.containerGroup);

      _get(EditableRect_getPrototypeOf(EditableRect.prototype), "destroy", this).call(this);
    }
  }]);

  return EditableRect;
}(EditableShape_EditableShape);


// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/util/Touch.js
var SIM_EVENTS = {
  touchstart: 'mousedown',
  touchmove: 'mousemove',
  touchend: 'mouseup'
};
var Touch_isTouchDevice = function isTouchDevice() {
  return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
};
var enableTouchTranslation = function enableTouchTranslation(el) {
  var pressAndHoldTrigger = null;

  var simulateEvent = function simulateEvent(type, e) {
    return new MouseEvent(type, {
      screenX: e.screenX,
      screenY: e.screenY,
      clientX: e.clientX,
      clientY: e.clientY,
      pageX: e.pageX,
      pageY: e.pageY,
      bubbles: true
    });
  };

  var touchHandler = function touchHandler(evt) {
    var touch = evt.changedTouches[0];
    var simulatedEvent = simulateEvent(SIM_EVENTS[evt.type], touch);
    touch.target.dispatchEvent(simulatedEvent);
    evt.preventDefault();

    if (evt.type === 'touchstart' || evt.type === 'touchmove') {
      pressAndHoldTrigger && clearTimeout(pressAndHoldTrigger);
      pressAndHoldTrigger = setTimeout(function () {
        var simulatedEvent = simulateEvent('dblclick', touch);
        touch.target.dispatchEvent(simulatedEvent);
      }, 800);
    }

    if (evt.type === 'touchend') pressAndHoldTrigger && clearTimeout(pressAndHoldTrigger);
  };

  el.addEventListener('touchstart', touchHandler, true);
  el.addEventListener('touchmove', touchHandler, true);
  el.addEventListener('touchend', touchHandler, true);
  el.addEventListener('touchcancel', touchHandler, true);
};
// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/tools/Tool.js
function Tool_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Tool_typeof = function _typeof(obj) { return typeof obj; }; } else { Tool_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Tool_typeof(obj); }

function Tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tool_defineProperties(Constructor, staticProps); return Constructor; }

function Tool_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tool_setPrototypeOf(subClass, superClass); }

function Tool_setPrototypeOf(o, p) { Tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tool_setPrototypeOf(o, p); }

function Tool_createSuper(Derived) { var hasNativeReflectConstruct = Tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Tool_possibleConstructorReturn(this, result); }; }

function Tool_possibleConstructorReturn(self, call) { if (call && (Tool_typeof(call) === "object" || typeof call === "function")) { return call; } return Tool_assertThisInitialized(self); }

function Tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tool_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function Tool_getPrototypeOf(o) { Tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tool_getPrototypeOf(o); }

function Tool_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Tool_IMPLEMENTATION_MISSING = "An implementation is missing";
var isTouch = Touch_isTouchDevice();
/**
 * Base class that adds some convenience stuff for tool plugins.
 */

var Tool = /*#__PURE__*/function (_EventEmitter) {
  Tool_inherits(Tool, _EventEmitter);

  var _super = Tool_createSuper(Tool);

  function Tool(g, config, env) {
    var _this;

    Tool_classCallCheck(this, Tool);

    _this = _super.call(this); // Annotationlayer SVG element

    Tool_defineProperty(Tool_assertThisInitialized(_this), "getSVGPoint", function (evt) {
      var pt = _this.svg.createSVGPoint();

      if (isTouch) {
        var bbox = _this.svg.getBoundingClientRect();

        var x = evt.clientX - bbox.x;
        var y = evt.clientY - bbox.y;

        var _this$svg$getBounding = _this.svg.getBoundingClientRect(),
            left = _this$svg$getBounding.left,
            top = _this$svg$getBounding.top;

        pt.x = x + left;
        pt.y = y + top;
        return pt.matrixTransform(_this.g.getScreenCTM().inverse());
      } else {
        pt.x = evt.offsetX;
        pt.y = evt.offsetY;
        return pt.matrixTransform(_this.g.getCTM().inverse());
      }
    });

    Tool_defineProperty(Tool_assertThisInitialized(_this), "attachListeners", function (_ref) {
      var mouseMove = _ref.mouseMove,
          mouseUp = _ref.mouseUp,
          dblClick = _ref.dblClick;

      // Handle SVG conversion on behalf of tool implementations
      if (mouseMove) {
        _this.mouseMove = function (evt) {
          var _this$getSVGPoint = _this.getSVGPoint(evt),
              x = _this$getSVGPoint.x,
              y = _this$getSVGPoint.y;

          if (!_this.started) {
            _this.emit('startSelection', {
              x: x,
              y: y
            });

            _this.started = true;
          }

          mouseMove(x, y, evt);
        }; // Mouse move goes on SVG element


        _this.svg.addEventListener('mousemove', _this.mouseMove);
      }

      if (mouseUp) {
        _this.mouseUp = function (evt) {
          var _this$getSVGPoint2 = _this.getSVGPoint(evt),
              x = _this$getSVGPoint2.x,
              y = _this$getSVGPoint2.y;

          mouseUp(x, y, evt);
        }; // Mouse up goes on doc, so we capture events outside, too


        document.addEventListener('mouseup', _this.mouseUp);
      }

      if (dblClick) {
        _this.dblClick = function (evt) {
          var _this$getSVGPoint3 = _this.getSVGPoint(evt),
              x = _this$getSVGPoint3.x,
              y = _this$getSVGPoint3.y;

          dblClick(x, y, evt);
        };

        _this.svg.addEventListener('dblclick', _this.dblClick);
      }
    });

    Tool_defineProperty(Tool_assertThisInitialized(_this), "detachListeners", function () {
      if (_this.mouseMove) _this.svg.removeEventListener('mousemove', _this.mouseMove);
      if (_this.mouseUp) document.removeEventListener('mouseup', _this.mouseUp);
      if (_this.dblClick) _this.svg.removeEventListener('dblclick', _this.dblClick);
    });

    Tool_defineProperty(Tool_assertThisInitialized(_this), "start", function (evt) {
      // Handle SVG conversion on behalf of tool implementations
      var _this$getSVGPoint4 = _this.getSVGPoint(evt),
          x = _this$getSVGPoint4.x,
          y = _this$getSVGPoint4.y;

      _this.startDrawing(x, y, evt);
    });

    Tool_defineProperty(Tool_assertThisInitialized(_this), "startDrawing", function (evt) {
      throw new Error(Tool_IMPLEMENTATION_MISSING);
    });

    Tool_defineProperty(Tool_assertThisInitialized(_this), "createEditableShape", function (annotation) {
      throw new Error(Tool_IMPLEMENTATION_MISSING);
    });

    _this.svg = g.closest('svg'); // SVG group holding all the a9s contents.
    // In AnnotoriousOSD, this is the element the 
    // transoform gets applied to.

    _this.g = g;
    _this.config = config;
    _this.env = env; // We'll keep a flag set to false until
    // the user has started moving, so we can 
    // fire the startSelection event

    _this.started = false;
    return _this;
  }

  Tool_createClass(Tool, [{
    key: "isDrawing",
    get:
    /** 
     * Tool implementations MUST override these
     */
    function get() {
      throw new Error(Tool_IMPLEMENTATION_MISSING);
    }
  }]);

  return Tool;
}(tiny_emitter_default.a); // In addition, Tool implementations need to implement the following static methods
// Tool.identifier = '...'




Tool.supports = function (annotation) {
  throw new Error(Tool_IMPLEMENTATION_MISSING);
}; // Just some convenience shortcuts to client-core, for quicker 
// importing in plugins. (In a way, the intention is to make the 
// Tool class serve as a kind of mini-SDK).




// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/tools/rectangle/RubberbandRectTool.js
function RubberbandRectTool_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { RubberbandRectTool_typeof = function _typeof(obj) { return typeof obj; }; } else { RubberbandRectTool_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return RubberbandRectTool_typeof(obj); }

function RubberbandRectTool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function RubberbandRectTool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function RubberbandRectTool_createClass(Constructor, protoProps, staticProps) { if (protoProps) RubberbandRectTool_defineProperties(Constructor.prototype, protoProps); if (staticProps) RubberbandRectTool_defineProperties(Constructor, staticProps); return Constructor; }

function RubberbandRectTool_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) RubberbandRectTool_setPrototypeOf(subClass, superClass); }

function RubberbandRectTool_setPrototypeOf(o, p) { RubberbandRectTool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return RubberbandRectTool_setPrototypeOf(o, p); }

function RubberbandRectTool_createSuper(Derived) { var hasNativeReflectConstruct = RubberbandRectTool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = RubberbandRectTool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = RubberbandRectTool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return RubberbandRectTool_possibleConstructorReturn(this, result); }; }

function RubberbandRectTool_possibleConstructorReturn(self, call) { if (call && (RubberbandRectTool_typeof(call) === "object" || typeof call === "function")) { return call; } return RubberbandRectTool_assertThisInitialized(self); }

function RubberbandRectTool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function RubberbandRectTool_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function RubberbandRectTool_getPrototypeOf(o) { RubberbandRectTool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return RubberbandRectTool_getPrototypeOf(o); }

function RubberbandRectTool_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * A rubberband selector for rectangle fragments.
 */

var RubberbandRectTool_RubberbandRectTool = /*#__PURE__*/function (_Tool) {
  RubberbandRectTool_inherits(RubberbandRectTool, _Tool);

  var _super = RubberbandRectTool_createSuper(RubberbandRectTool);

  function RubberbandRectTool(g, config, env) {
    var _this;

    RubberbandRectTool_classCallCheck(this, RubberbandRectTool);

    // Most of the basics are handled in the Tool base class
    _this = _super.call(this, g, config, env);

    RubberbandRectTool_defineProperty(RubberbandRectTool_assertThisInitialized(_this), "startDrawing", function (x, y) {
      _this.attachListeners({
        mouseMove: _this.onMouseMove,
        mouseUp: _this.onMouseUp
      });

      _this.rubberband = new RubberbandRect_RubberbandRect(x, y, _this.g, _this.config, _this.env);
    });

    RubberbandRectTool_defineProperty(RubberbandRectTool_assertThisInitialized(_this), "stop", function () {
      if (_this.rubberband) {
        _this.rubberband.destroy();

        _this.rubberband = null;
      }
    });

    RubberbandRectTool_defineProperty(RubberbandRectTool_assertThisInitialized(_this), "onMouseMove", function (x, y) {
      return _this.rubberband.dragTo(x, y);
    });

    RubberbandRectTool_defineProperty(RubberbandRectTool_assertThisInitialized(_this), "onMouseUp", function () {
      _this.detachListeners();

      _this.started = false;

      var _this$rubberband$getB = _this.rubberband.getBoundingClientRect(),
          width = _this$rubberband$getB.width,
          height = _this$rubberband$getB.height;

      var minWidth = _this.config.minSelectionWidth || 4;
      var minHeight = _this.config.minSelectionHeight || 4;

      if (width >= minWidth && height >= minHeight) {
        // Emit the SVG shape with selection attached    
        var element = _this.rubberband.element;
        element.annotation = _this.rubberband.toSelection(); // Emit the completed shape...

        _this.emit('complete', element);
      } else {
        _this.emit('cancel');
      }

      _this.stop();
    });

    RubberbandRectTool_defineProperty(RubberbandRectTool_assertThisInitialized(_this), "createEditableShape", function (annotation) {
      return new EditableRect_EditableRect(annotation, _this.g, _this.config, _this.env);
    });

    _this.rubberband = null;
    return _this;
  }

  RubberbandRectTool_createClass(RubberbandRectTool, [{
    key: "isDrawing",
    get: function get() {
      return this.rubberband != null;
    }
  }]);

  return RubberbandRectTool;
}(Tool);


RubberbandRectTool_RubberbandRectTool.identifier = 'rect';

RubberbandRectTool_RubberbandRectTool.supports = function (annotation) {
  var fragmentSelector = annotation.selector('FragmentSelector');
  return fragmentSelector === null || fragmentSelector === void 0 ? void 0 : fragmentSelector.conformsTo.startsWith('http://www.w3.org/TR/media-frags');
};
// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/selectors/EmbeddedSVG.js

/** Helper that forces an un-namespaced node to SVG **/

var EmbeddedSVG_insertSVGNamespace = function insertSVGNamespace(originalDoc) {
  // Serialize and parse for the namespace to take effect on every node
  var serializer = new XMLSerializer();
  var str = serializer.serializeToString(originalDoc.documentElement); // Doesn't seem that there's a clean cross-browser way for this...

  var namespaced = str.replace('<svg>', "<svg xmlns=\"".concat(SVG_NAMESPACE, "\">"));
  var parser = new DOMParser();
  var namespacedDoc = parser.parseFromString(namespaced, "image/svg+xml");
  return namespacedDoc.documentElement;
};

var sanitize = function sanitize(doc) {
  // Cf. https://github.com/mattkrick/sanitize-svg#readme  
  // for the basic approach
  var cleanEl = function cleanEl(el) {
    Array.from(el.attributes).forEach(function (attr) {
      if (attr.name.startsWith('on')) el.removeAttribute(attr.name);
    });
  }; // Remove script tags


  var scripts = doc.getElementsByTagName('script');
  Array.from(scripts).reverse().forEach(function (el) {
    return el.parentNode.removeChild(el);
  }); // Remove on... attributes

  cleanEl(doc);
  Array.from(doc.querySelectorAll('*')).forEach(cleanEl);
  return doc;
};

var EmbeddedSVG_svgFragmentToShape = function svgFragmentToShape(annotation) {
  var selector = annotation.selector('SvgSelector');

  if (selector) {
    var parser = new DOMParser(); // Parse the XML document, assuming SVG

    var value = selector.value;
    var doc = parser.parseFromString(value, "image/svg+xml"); // SVG needs a namespace declaration - check if it's set or insert if not

    var isPrefixDeclared = doc.lookupPrefix(SVG_NAMESPACE); // SVG declared via prefix

    var isDefaultNamespaceSVG = doc.lookupNamespaceURI(null); // SVG declared as default namespace

    if (isPrefixDeclared || isDefaultNamespaceSVG) {
      return sanitize(doc).firstChild;
    } else {
      return sanitize(EmbeddedSVG_insertSVGNamespace(doc)).firstChild;
    }
  }
};
var EmbeddedSVG_drawEmbeddedSVG = function drawEmbeddedSVG(annotation) {
  var shape = EmbeddedSVG_svgFragmentToShape(annotation);
  var g = document.createElementNS(SVG_NAMESPACE, 'g');
  var outer = shape.cloneNode(true);
  outer.setAttribute('class', 'a9s-outer');
  g.appendChild(outer);
  return g;
};
var EmbeddedSVG_toSVGTarget = function toSVGTarget(shape, styleClass, image) {
  var outer = shape.querySelector('.a9s-outer').cloneNode(true);
  outer.removeAttribute('class');
  outer.removeAttribute('xmlns');
  var serialized = outer.outerHTML || new XMLSerializer().serializeToString(outer);
  serialized = serialized.replace(" xmlns=\"".concat(SVG_NAMESPACE, "\""), '');

  if (styleClass) {
    return {
      source: image.src,
      styleClass: styleClass,
      selector: {
        type: "SvgSelector",
        value: "<svg>".concat(serialized, "</svg>")
      }
    };
  } else {
    return {
      source: image.src,
      selector: {
        type: "SvgSelector",
        value: "<svg>".concat(serialized, "</svg>")
      }
    };
  }
};
var svgArea = function svgArea(annotation) {
  var shape = EmbeddedSVG_svgFragmentToShape(annotation);
  var nodeName = shape.nodeName.toLowerCase();
  if (nodeName === 'polygon') return polygonArea(shape);else if (nodeName === 'circle') return circleArea(shape);else if (nodeName === 'ellipse') return ellipseArea(shape);else if (nodeName == 'path') return pathArea(shape);else throw "Unsupported SVG shape type: ".concat(nodeName);
};

var polygonArea = function polygonArea(polygon) {
  var points = polygon.getAttribute('points').split(' ') // Split x/y tuples
  .map(function (xy) {
    return xy.split(',').map(function (str) {
      return parseFloat(str.trim());
    });
  });
  var area = 0;
  var j = points.length - 1;

  for (var i = 0; i < points.length; i++) {
    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);
    j = i;
  }

  return Math.abs(0.5 * area);
};

var circleArea = function circleArea(circle) {
  var r = circle.getAttribute('r');
  return r * r * Math.PI;
};

var ellipseArea = function ellipseArea(ellipse) {
  var rx = ellipse.getAttribute('rx');
  var ry = ellipse.getAttribute('ry');
  return rx * ry * Math.PI;
};

var pathArea = function pathArea(path) {
  var pointList = path.getAttribute('d').split('L');
  var area = 0;

  if (pointList.length > 1) {
    var point = pointList[pointList.length - 1].trim().split(' ');
    var lastX = parseFloat(point[0]);
    var lastY = parseFloat(point[1]);
    point = pointList[0].substring(1).trim().split(' ');
    var x = parseFloat(point[0]);
    var y = parseFloat(point[1]);
    area += (lastX + x) * (lastY - y);
    lastX = x;
    lastY = y;

    for (var i = 1; i < pointList.length; i++) {
      point = pointList[i].trim().split(' ');
      x = parseFloat(point[0]);
      y = parseFloat(point[1]);
      area += (lastX + x) * (lastY - y);
      lastX = x;
      lastY = y;
    }
  }

  return Math.abs(0.5 * area);
};
// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/tools/polygon/PolygonMask.js
function PolygonMask_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function PolygonMask_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function PolygonMask_createClass(Constructor, protoProps, staticProps) { if (protoProps) PolygonMask_defineProperties(Constructor.prototype, protoProps); if (staticProps) PolygonMask_defineProperties(Constructor, staticProps); return Constructor; }

function PolygonMask_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var PolygonMask_PolygonMask = /*#__PURE__*/function () {
  function PolygonMask(imageDimensions, polygon) {
    var _this = this;

    PolygonMask_classCallCheck(this, PolygonMask);

    PolygonMask_defineProperty(this, "redraw", function () {
      _this.mask.setAttribute('d', "M0 0 h".concat(_this.w, " v").concat(_this.h, " h-").concat(_this.w, " z M").concat(_this.polygon.getAttribute('points'), " z"));
    });

    PolygonMask_defineProperty(this, "destroy", function () {
      return _this.mask.parentNode.removeChild(_this.mask);
    });

    this.w = imageDimensions.naturalWidth;
    this.h = imageDimensions.naturalHeight;
    this.polygon = polygon;
    this.mask = document.createElementNS(SVG_NAMESPACE, 'path');
    this.mask.setAttribute('fill-rule', 'evenodd');
    this.mask.setAttribute('class', 'a9s-selection-mask');
    this.mask.setAttribute('d', "M0 0 h".concat(this.w, " v").concat(this.h, " h-").concat(this.w, " z M").concat(this.polygon.getAttribute('points'), " z"));
  }

  PolygonMask_createClass(PolygonMask, [{
    key: "element",
    get: function get() {
      return this.mask;
    }
  }]);

  return PolygonMask;
}();


// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/tools/polygon/RubberbandPolygon.js
function RubberbandPolygon_toConsumableArray(arr) { return RubberbandPolygon_arrayWithoutHoles(arr) || RubberbandPolygon_iterableToArray(arr) || RubberbandPolygon_unsupportedIterableToArray(arr) || RubberbandPolygon_nonIterableSpread(); }

function RubberbandPolygon_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function RubberbandPolygon_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return RubberbandPolygon_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return RubberbandPolygon_arrayLikeToArray(o, minLen); }

function RubberbandPolygon_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function RubberbandPolygon_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return RubberbandPolygon_arrayLikeToArray(arr); }

function RubberbandPolygon_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function RubberbandPolygon_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function RubberbandPolygon_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function RubberbandPolygon_createClass(Constructor, protoProps, staticProps) { if (protoProps) RubberbandPolygon_defineProperties(Constructor.prototype, protoProps); if (staticProps) RubberbandPolygon_defineProperties(Constructor, staticProps); return Constructor; }

function RubberbandPolygon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var RubberbandPolygon_RubberbandPolygon = /*#__PURE__*/function () {
  function RubberbandPolygon(anchor, g, config, env) {
    var _this = this;

    RubberbandPolygon_classCallCheck(this, RubberbandPolygon);

    RubberbandPolygon_defineProperty(this, "setPoints", function (points) {
      var attr = points.map(function (t) {
        return "".concat(t[0], ",").concat(t[1]);
      }).join(' ');

      _this.outer.setAttribute('points', attr);
    });

    RubberbandPolygon_defineProperty(this, "getBoundingClientRect", function () {
      return _this.outer.getBoundingClientRect();
    });

    RubberbandPolygon_defineProperty(this, "dragTo", function (xy) {
      // Make visible
      _this.group.style.display = null;
      var rubberband = [].concat(RubberbandPolygon_toConsumableArray(_this.points), [xy]);

      _this.setPoints(rubberband);

      _this.mask.redraw();
    });

    RubberbandPolygon_defineProperty(this, "addPoint", function (xy) {
      // Don't add a new point if distance < 2 pixels
      var lastCorner = _this.points[_this.points.length - 1];
      var dist = Math.pow(xy[0] - lastCorner[0], 2) + Math.pow(xy[1] - lastCorner[1], 2);

      if (dist > 4) {
        _this.points = [].concat(RubberbandPolygon_toConsumableArray(_this.points), [xy]);

        _this.setPoints(_this.points);

        _this.mask.redraw();
      }
    });

    RubberbandPolygon_defineProperty(this, "destroy", function () {
      _this.group.parentNode.removeChild(_this.group);

      _this.polygon = null;
      _this.group = null;
    });

    RubberbandPolygon_defineProperty(this, "toSelection", function () {
      return new Selection_Selection(EmbeddedSVG_toSVGTarget(_this.group, _this.styleClass, _this.env.image));
    });

    this.points = [anchor];
    this.env = env;
    this.group = document.createElementNS(SVG_NAMESPACE, 'g');
    this.styleClass = config.styleClass;

    if (this.styleClass) {
      this.group.setAttribute('class', this.styleClass);
    }

    this.polygon = document.createElementNS(SVG_NAMESPACE, 'g');
    this.polygon.setAttribute('class', 'a9s-selection');
    this.outer = document.createElementNS(SVG_NAMESPACE, 'polygon');
    this.outer.setAttribute('class', 'a9s-outer');
    this.setPoints(this.points);
    this.mask = new PolygonMask_PolygonMask(env.image, this.outer);
    this.polygon.appendChild(this.outer); // Additionally, selection remains hidden until 
    // the user actually moves the mouse

    this.group.style.display = 'none';
    this.group.appendChild(this.mask.element);
    this.group.appendChild(this.polygon);
    g.appendChild(this.group);
  }

  RubberbandPolygon_createClass(RubberbandPolygon, [{
    key: "element",
    get: function get() {
      return this.polygon;
    }
  }]);

  return RubberbandPolygon;
}();


// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/tools/polygon/EditablePolygon.js
function EditablePolygon_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { EditablePolygon_typeof = function _typeof(obj) { return typeof obj; }; } else { EditablePolygon_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return EditablePolygon_typeof(obj); }

function EditablePolygon_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EditablePolygon_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EditablePolygon_createClass(Constructor, protoProps, staticProps) { if (protoProps) EditablePolygon_defineProperties(Constructor.prototype, protoProps); if (staticProps) EditablePolygon_defineProperties(Constructor, staticProps); return Constructor; }

function EditablePolygon_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EditablePolygon_setPrototypeOf(subClass, superClass); }

function EditablePolygon_setPrototypeOf(o, p) { EditablePolygon_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EditablePolygon_setPrototypeOf(o, p); }

function EditablePolygon_createSuper(Derived) { var hasNativeReflectConstruct = EditablePolygon_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = EditablePolygon_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = EditablePolygon_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return EditablePolygon_possibleConstructorReturn(this, result); }; }

function EditablePolygon_possibleConstructorReturn(self, call) { if (call && (EditablePolygon_typeof(call) === "object" || typeof call === "function")) { return call; } return EditablePolygon_assertThisInitialized(self); }

function EditablePolygon_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EditablePolygon_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function EditablePolygon_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { EditablePolygon_get = Reflect.get; } else { EditablePolygon_get = function _get(target, property, receiver) { var base = EditablePolygon_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return EditablePolygon_get(target, property, receiver || target); }

function EditablePolygon_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = EditablePolygon_getPrototypeOf(object); if (object === null) break; } return object; }

function EditablePolygon_getPrototypeOf(o) { EditablePolygon_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EditablePolygon_getPrototypeOf(o); }

function EditablePolygon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var getPoints = function getPoints(shape) {
  // Could just be Array.from(shape.querySelector('.outer').points) but...
  // IE11 :-(
  var pointList = shape.querySelectorAll('.a9s-outer')[0].points;
  var points = [];

  for (var i = 0; i < pointList.numberOfItems; i++) {
    points.push(pointList.getItem(i));
  }

  return points;
};

var getBBox = function getBBox(shape) {
  return shape.querySelector('.a9s-outer').getBBox();
};
/**
 * An editable polygon shape.
 */


var EditablePolygon_EditablePolygon = /*#__PURE__*/function (_EditableShape) {
  EditablePolygon_inherits(EditablePolygon, _EditableShape);

  var _super = EditablePolygon_createSuper(EditablePolygon);

  function EditablePolygon(annotation, g, config, env) {
    var _thisSuper, _this;

    EditablePolygon_classCallCheck(this, EditablePolygon);

    _this = _super.call(this, annotation, g, config, env);

    EditablePolygon_defineProperty(EditablePolygon_assertThisInitialized(_this), "setPoints", function (points) {
      // Not using .toFixed(1) because that will ALWAYS
      // return one decimal, e.g. "15.0" (when we want "15")
      var round = function round(num) {
        return Math.round(10 * num) / 10;
      };

      var str = points.map(function (pt) {
        return "".concat(round(pt.x), ",").concat(round(pt.y));
      }).join(' ');

      var outer = _this.shape.querySelector('.a9s-outer');

      outer.setAttribute('points', str);

      _this.mask.redraw();

      var _outer$getBBox = outer.getBBox(),
          x = _outer$getBBox.x,
          y = _outer$getBBox.y,
          width = _outer$getBBox.width,
          height = _outer$getBBox.height;

      setFormatterElSize(_this.elementGroup, x, y, width, height);
    });

    EditablePolygon_defineProperty(EditablePolygon_assertThisInitialized(_this), "onGrab", function (grabbedElem) {
      return function (evt) {
        _this.grabbedElem = grabbedElem;
        _this.grabbedAt = _this.getSVGPoint(evt);
      };
    });

    EditablePolygon_defineProperty(EditablePolygon_assertThisInitialized(_this), "onMouseMove", function (evt) {
      var constrain = function constrain(coord, delta, max) {
        return coord + delta < 0 ? -coord : coord + delta > max ? max - coord : delta;
      };

      if (_this.grabbedElem) {
        var pos = _this.getSVGPoint(evt);

        if (_this.grabbedElem === _this.shape) {
          var _getBBox = getBBox(_this.shape),
              x = _getBBox.x,
              y = _getBBox.y,
              width = _getBBox.width,
              height = _getBBox.height;

          var _this$env$image = _this.env.image,
              naturalWidth = _this$env$image.naturalWidth,
              naturalHeight = _this$env$image.naturalHeight;
          var dx = constrain(x, pos.x - _this.grabbedAt.x, naturalWidth - width);
          var dy = constrain(y, pos.y - _this.grabbedAt.y, naturalHeight - height);
          var updatedPoints = getPoints(_this.shape).map(function (pt) {
            return {
              x: pt.x + dx,
              y: pt.y + dy
            };
          });
          _this.grabbedAt = pos;

          _this.setPoints(updatedPoints);

          updatedPoints.forEach(function (pt, idx) {
            return _this.setHandleXY(_this.handles[idx], pt.x, pt.y);
          });

          _this.emit('update', EmbeddedSVG_toSVGTarget(_this.shape, _this.styleClass, _this.env.image));
        } else {
          var handleIdx = _this.handles.indexOf(_this.grabbedElem);

          var _updatedPoints = getPoints(_this.shape).map(function (pt, idx) {
            return idx === handleIdx ? pos : pt;
          });

          _this.setPoints(_updatedPoints);

          _this.setHandleXY(_this.handles[handleIdx], pos.x, pos.y);

          _this.emit('update', EmbeddedSVG_toSVGTarget(_this.shape, _this.styleClass, _this.env.image));
        }
      }
    });

    EditablePolygon_defineProperty(EditablePolygon_assertThisInitialized(_this), "onMouseUp", function (evt) {
      _this.grabbedElem = null;
      _this.grabbedAt = null;
    });

    EditablePolygon_defineProperty(EditablePolygon_assertThisInitialized(_this), "destroy", function () {
      _this.containerGroup.parentNode.removeChild(_this.containerGroup);

      EditablePolygon_get((_thisSuper = EditablePolygon_assertThisInitialized(_this), EditablePolygon_getPrototypeOf(EditablePolygon.prototype)), "destroy", _thisSuper).call(_thisSuper);
    });

    _this.svg.addEventListener('mousemove', _this.onMouseMove);

    _this.svg.addEventListener('mouseup', _this.onMouseUp); // SVG markup for this class looks like this:
    // 
    // <g>
    //   <path class="a9s-selection mask"... />
    //   <g> <-- return this node as .element
    //     <polygon class="a9s-outer" ... />
    //     <g class="a9s-handle" ...> ... </g>
    //     <g class="a9s-handle" ...> ... </g>
    //     <g class="a9s-handle" ...> ... </g>
    //     ...
    //   </g> 
    // </g>


    _this.styleClass = annotation.target.styleClass; // 'g' for the editable polygon compound shape

    _this.containerGroup = document.createElementNS(SVG_NAMESPACE, 'g');

    if (_this.styleClass) {
      _this.containerGroup.setAttribute('class', _this.styleClass);
    }

    _this.shape = EmbeddedSVG_drawEmbeddedSVG(annotation);

    _this.shape.querySelector('.a9s-outer').addEventListener('mousedown', _this.onGrab(_this.shape));

    _this.mask = new PolygonMask_PolygonMask(env.image, _this.shape.querySelector('.a9s-outer'));

    _this.containerGroup.appendChild(_this.mask.element);

    _this.elementGroup = document.createElementNS(SVG_NAMESPACE, 'g');

    _this.elementGroup.setAttribute('class', 'a9s-annotation editable selected');

    _this.elementGroup.appendChild(_this.shape);

    _this.handles = getPoints(_this.shape).map(function (pt) {
      var handle = _this.drawHandle(pt.x, pt.y);

      handle.addEventListener('mousedown', _this.onGrab(handle));

      _this.elementGroup.appendChild(handle);

      return handle;
    });

    _this.containerGroup.appendChild(_this.elementGroup);

    g.appendChild(_this.containerGroup);
    Formatting_format(_this.shape, annotation, config.formatter); // The grabbed element (handle or entire shape), if any

    _this.grabbedElem = null; // Mouse grab point

    _this.grabbedAt = null;
    return _this;
  }

  EditablePolygon_createClass(EditablePolygon, [{
    key: "element",
    get: function get() {
      return this.elementGroup;
    }
  }]);

  return EditablePolygon;
}(EditableShape_EditableShape);


// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/tools/polygon/RubberbandPolygonTool.js
function RubberbandPolygonTool_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { RubberbandPolygonTool_typeof = function _typeof(obj) { return typeof obj; }; } else { RubberbandPolygonTool_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return RubberbandPolygonTool_typeof(obj); }

function RubberbandPolygonTool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function RubberbandPolygonTool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function RubberbandPolygonTool_createClass(Constructor, protoProps, staticProps) { if (protoProps) RubberbandPolygonTool_defineProperties(Constructor.prototype, protoProps); if (staticProps) RubberbandPolygonTool_defineProperties(Constructor, staticProps); return Constructor; }

function RubberbandPolygonTool_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) RubberbandPolygonTool_setPrototypeOf(subClass, superClass); }

function RubberbandPolygonTool_setPrototypeOf(o, p) { RubberbandPolygonTool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return RubberbandPolygonTool_setPrototypeOf(o, p); }

function RubberbandPolygonTool_createSuper(Derived) { var hasNativeReflectConstruct = RubberbandPolygonTool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = RubberbandPolygonTool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = RubberbandPolygonTool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return RubberbandPolygonTool_possibleConstructorReturn(this, result); }; }

function RubberbandPolygonTool_possibleConstructorReturn(self, call) { if (call && (RubberbandPolygonTool_typeof(call) === "object" || typeof call === "function")) { return call; } return RubberbandPolygonTool_assertThisInitialized(self); }

function RubberbandPolygonTool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function RubberbandPolygonTool_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function RubberbandPolygonTool_getPrototypeOf(o) { RubberbandPolygonTool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return RubberbandPolygonTool_getPrototypeOf(o); }

function RubberbandPolygonTool_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * A rubberband selector for polygon fragments.
 */

var RubberbandPolygonTool_RubberbandPolygonTool = /*#__PURE__*/function (_Tool) {
  RubberbandPolygonTool_inherits(RubberbandPolygonTool, _Tool);

  var _super = RubberbandPolygonTool_createSuper(RubberbandPolygonTool);

  function RubberbandPolygonTool(g, config, env) {
    var _this;

    RubberbandPolygonTool_classCallCheck(this, RubberbandPolygonTool);

    _this = _super.call(this, g, config, env);

    RubberbandPolygonTool_defineProperty(RubberbandPolygonTool_assertThisInitialized(_this), "startDrawing", function (x, y) {
      _this._isDrawing = true;

      _this.attachListeners({
        mouseMove: _this.onMouseMove,
        mouseUp: _this.onMouseUp,
        dblClick: _this.onDblClick
      });

      _this.rubberband = new RubberbandPolygon_RubberbandPolygon([x, y], _this.g, _this.config, _this.env);
    });

    RubberbandPolygonTool_defineProperty(RubberbandPolygonTool_assertThisInitialized(_this), "stop", function () {
      _this.detachListeners();

      _this._isDrawing = false;

      if (_this.rubberband) {
        _this.rubberband.destroy();

        _this.rubberband = null;
      }
    });

    RubberbandPolygonTool_defineProperty(RubberbandPolygonTool_assertThisInitialized(_this), "onMouseMove", function (x, y) {
      return _this.rubberband.dragTo([x, y]);
    });

    RubberbandPolygonTool_defineProperty(RubberbandPolygonTool_assertThisInitialized(_this), "onMouseUp", function (x, y) {
      var _this$rubberband$getB = _this.rubberband.getBoundingClientRect(),
          width = _this$rubberband$getB.width,
          height = _this$rubberband$getB.height;

      var minWidth = _this.config.minSelectionWidth || 4;
      var minHeight = _this.config.minSelectionHeight || 4;

      if (width >= minWidth || height >= minHeight) {
        _this.rubberband.addPoint([x, y]);
      } else {
        _this.emit('cancel');

        _this.stop();
      }
    });

    RubberbandPolygonTool_defineProperty(RubberbandPolygonTool_assertThisInitialized(_this), "onDblClick", function (x, y) {
      _this._isDrawing = false;

      _this.rubberband.addPoint([x, y]);

      var shape = _this.rubberband.element;
      shape.annotation = _this.rubberband.toSelection();

      _this.emit('complete', shape);

      _this.stop();
    });

    RubberbandPolygonTool_defineProperty(RubberbandPolygonTool_assertThisInitialized(_this), "createEditableShape", function (annotation) {
      return new EditablePolygon_EditablePolygon(annotation, _this.g, _this.config, _this.env);
    });

    _this._isDrawing = false;
    return _this;
  }

  RubberbandPolygonTool_createClass(RubberbandPolygonTool, [{
    key: "isDrawing",
    get: function get() {
      return this._isDrawing;
    }
  }]);

  return RubberbandPolygonTool;
}(Tool);


RubberbandPolygonTool_RubberbandPolygonTool.identifier = 'polygon';

RubberbandPolygonTool_RubberbandPolygonTool.supports = function (annotation) {
  var _selector$value;

  var selector = annotation.selector('SvgSelector');
  if (selector) return (_selector$value = selector.value) === null || _selector$value === void 0 ? void 0 : _selector$value.match(/^<svg.*<polygon/g);
};
// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/tools/ToolsRegistry.js
function ToolsRegistry_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ToolsRegistry_typeof = function _typeof(obj) { return typeof obj; }; } else { ToolsRegistry_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ToolsRegistry_typeof(obj); }

function _toArray(arr) { return ToolsRegistry_arrayWithHoles(arr) || ToolsRegistry_iterableToArray(arr) || ToolsRegistry_unsupportedIterableToArray(arr) || ToolsRegistry_nonIterableRest(); }

function ToolsRegistry_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function ToolsRegistry_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ToolsRegistry_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ToolsRegistry_arrayLikeToArray(o, minLen); }

function ToolsRegistry_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ToolsRegistry_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function ToolsRegistry_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ToolsRegistry_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ToolsRegistry_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ToolsRegistry_createClass(Constructor, protoProps, staticProps) { if (protoProps) ToolsRegistry_defineProperties(Constructor.prototype, protoProps); if (staticProps) ToolsRegistry_defineProperties(Constructor, staticProps); return Constructor; }

function ToolsRegistry_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) ToolsRegistry_setPrototypeOf(subClass, superClass); }

function ToolsRegistry_setPrototypeOf(o, p) { ToolsRegistry_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ToolsRegistry_setPrototypeOf(o, p); }

function ToolsRegistry_createSuper(Derived) { var hasNativeReflectConstruct = ToolsRegistry_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ToolsRegistry_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ToolsRegistry_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ToolsRegistry_possibleConstructorReturn(this, result); }; }

function ToolsRegistry_possibleConstructorReturn(self, call) { if (call && (ToolsRegistry_typeof(call) === "object" || typeof call === "function")) { return call; } return ToolsRegistry_assertThisInitialized(self); }

function ToolsRegistry_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function ToolsRegistry_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ToolsRegistry_getPrototypeOf(o) { ToolsRegistry_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ToolsRegistry_getPrototypeOf(o); }

function ToolsRegistry_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var ToolsRegistry_ToolRegistry = /*#__PURE__*/function (_EventEmitter) {
  ToolsRegistry_inherits(ToolRegistry, _EventEmitter);

  var _super = ToolsRegistry_createSuper(ToolRegistry);

  function ToolRegistry(g, config, env) {
    var _this;

    ToolsRegistry_classCallCheck(this, ToolRegistry);

    _this = _super.call(this); // SVG annotation layer group

    ToolsRegistry_defineProperty(ToolsRegistry_assertThisInitialized(_this), "listTools", function () {
      return _this._registered.map(function (impl) {
        return impl.identifier;
      });
    });

    ToolsRegistry_defineProperty(ToolsRegistry_assertThisInitialized(_this), "registerTool", function (impl) {
      return _this._registered.push(impl);
    });

    ToolsRegistry_defineProperty(ToolsRegistry_assertThisInitialized(_this), "unregisterTool", function (id) {
      return _this._registered = _this._registered.filter(function (impl) {
        return impl.identifier !== id;
      });
    });

    ToolsRegistry_defineProperty(ToolsRegistry_assertThisInitialized(_this), "setCurrent", function (toolOrId) {
      var Tool = typeof toolOrId === 'string' || toolOrId instanceof String ? _this._registered.find(function (impl) {
        return impl.identifier === toolOrId;
      }) : toolOrId;
      _this._current = new Tool(_this._g, _this._config, _this._env);

      _this._current.on('startSelection', function (pt) {
        return _this.emit('startSelection', pt);
      });

      _this._current.on('complete', function (evt) {
        return _this.emit('complete', evt);
      });

      _this._current.on('cancel', function (evt) {
        return _this.emit('cancel', evt);
      });
    });

    ToolsRegistry_defineProperty(ToolsRegistry_assertThisInitialized(_this), "forAnnotation", function (annotation) {
      var _target$renderedVia;

      // First target
      var _annotation$targets = _toArray(annotation.targets),
          target = _annotation$targets[0],
          _ = _annotation$targets.slice(1);

      var renderedVia = (_target$renderedVia = target.renderedVia) === null || _target$renderedVia === void 0 ? void 0 : _target$renderedVia.name;
      var Tool = renderedVia ? _this._registered.find(function (impl) {
        return impl.identifier === renderedVia;
      }) : _this._registered.find(function (impl) {
        return impl.supports(annotation);
      });
      return Tool ? new Tool(_this._g, _this._config, _this._env) : null;
    });

    _this._g = g; // Annotorious user config

    _this._config = config; // Environment settings

    _this._env = env; // Registered tool implementations

    _this._registered = [RubberbandRectTool_RubberbandRectTool, RubberbandPolygonTool_RubberbandPolygonTool];

    _this.setCurrent(RubberbandRectTool_RubberbandRectTool);

    return _this;
  }

  ToolsRegistry_createClass(ToolRegistry, [{
    key: "current",
    get: function get() {
      return this._current;
    }
  }]);

  return ToolRegistry;
}(tiny_emitter_default.a);


// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/Crosshair.js
function Crosshair_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var Crosshair_Crosshair = function Crosshair(layerGroup, width, height) {
  var _this = this;

  Crosshair_classCallCheck(this, Crosshair);

  this.svg = layerGroup.closest('svg');
  this.g = document.createElementNS(SVG_NAMESPACE, 'g');
  this.g.setAttribute('class', 'a9s-crosshair');
  var h = document.createElementNS(SVG_NAMESPACE, 'line');
  var v = document.createElementNS(SVG_NAMESPACE, 'line');
  this.g.appendChild(h);
  this.g.appendChild(v);
  layerGroup.appendChild(this.g);

  var getSVGPoint = function getSVGPoint(evt) {
    var bbox = _this.svg.getBoundingClientRect();

    var x = evt.clientX - bbox.x;
    var y = evt.clientY - bbox.y;

    var pt = _this.svg.createSVGPoint();

    var _this$svg$getBounding = _this.svg.getBoundingClientRect(),
        left = _this$svg$getBounding.left,
        top = _this$svg$getBounding.top;

    pt.x = x + left;
    pt.y = y + top;
    return pt.matrixTransform(layerGroup.getScreenCTM().inverse());
  };

  this.svg.addEventListener('mousemove', function (evt) {
    var _getSVGPoint = getSVGPoint(evt),
        x = _getSVGPoint.x,
        y = _getSVGPoint.y;

    h.setAttribute('x1', 0);
    h.setAttribute('y1', y);
    h.setAttribute('x2', width);
    h.setAttribute('y2', y);
    v.setAttribute('x1', x);
    v.setAttribute('y1', 0);
    v.setAttribute('x2', x);
    v.setAttribute('y2', height);
  });
};


// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/selectors/index.js

 // Drawing functions per selector type

var drawFn = {
  'FragmentSelector': RectFragment_drawRect,
  'SvgSelector': EmbeddedSVG_drawEmbeddedSVG
}; // Area computation functions per selector type

var areaFn = {
  'FragmentSelector': rectArea,
  'SvgSelector': svgArea
}; // Helper to get the first selector from an annotation

var getFirstSelector = function getFirstSelector(annotation) {
  var firstTarget = annotation.targets[0];
  if (firstTarget) return Array.isArray(firstTarget.selector) ? firstTarget.selector[0] : firstTarget.selector;
};
/** 
 * Evaluates the annotation target and picks the right drawing functions. 
 * 
 * We currently support the following selectors
 * - MediaFragment
 * - SVG (with embedded SVG shape)
 */


var drawShape = function drawShape(annotation) {
  return drawFn[getFirstSelector(annotation).type](annotation);
};
var shapeArea = function shapeArea(annotation) {
  return areaFn[getFirstSelector(annotation).type](annotation);
};



// CONCATENATED MODULE: ./src/util/ImageSnippet.js

var ImageSnippet_getSnippet = function getSnippet(viewer, element) {
  // Annotation shape could be the element itself or a 
  // child (in case of editable shapes, the element would be 
  // the group with shape + handles)
  var shape = SVG_hasClass(element, '.a9s-annotation') ? element : element.querySelectorAll('.a9s-annotation')[0]; // Scale factor for OSD canvas element (physical vs. logical resolution)

  var canvas = viewer.drawer.canvas;
  var canvasBounds = canvas.getBoundingClientRect();
  var kx = canvas.width / canvasBounds.width;
  var ky = canvas.height / canvasBounds.height;
  var shapeBounds = shape.getBoundingClientRect();
  var x = shapeBounds.x - canvasBounds.x;
  var y = shapeBounds.y - canvasBounds.y;
  var width = shapeBounds.width,
      height = shapeBounds.height; // Cut out the image snippet as in-memory canvas element

  var snippet = document.createElement('CANVAS');
  var ctx = snippet.getContext('2d');
  snippet.width = width;
  snippet.height = height;
  ctx.drawImage(canvas, x * kx, y * ky, width * kx, height * ky, 0, 0, width, height); // Compute reverse transform

  var topLeft = viewer.viewport.viewportToImageCoordinates(shapeBounds.x, shapeBounds.y);
  var imageZoom = viewer.viewport.viewportToImageZoom(viewer.viewport.getZoom());
  return {
    snippet: snippet,
    transform: function transform(xy) {
      var px = topLeft.x + xy[0] / kx / imageZoom;
      var py = topLeft.y + xy[1] / ky / imageZoom;
      return [px, py];
    }
  };
};
// CONCATENATED MODULE: ./src/OSDAnnotationLayer.js
function OSDAnnotationLayer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { OSDAnnotationLayer_typeof = function _typeof(obj) { return typeof obj; }; } else { OSDAnnotationLayer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return OSDAnnotationLayer_typeof(obj); }

function OSDAnnotationLayer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function OSDAnnotationLayer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function OSDAnnotationLayer_createClass(Constructor, protoProps, staticProps) { if (protoProps) OSDAnnotationLayer_defineProperties(Constructor.prototype, protoProps); if (staticProps) OSDAnnotationLayer_defineProperties(Constructor, staticProps); return Constructor; }

function OSDAnnotationLayer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) OSDAnnotationLayer_setPrototypeOf(subClass, superClass); }

function OSDAnnotationLayer_setPrototypeOf(o, p) { OSDAnnotationLayer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return OSDAnnotationLayer_setPrototypeOf(o, p); }

function OSDAnnotationLayer_createSuper(Derived) { var hasNativeReflectConstruct = OSDAnnotationLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = OSDAnnotationLayer_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = OSDAnnotationLayer_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return OSDAnnotationLayer_possibleConstructorReturn(this, result); }; }

function OSDAnnotationLayer_possibleConstructorReturn(self, call) { if (call && (OSDAnnotationLayer_typeof(call) === "object" || typeof call === "function")) { return call; } return OSDAnnotationLayer_assertThisInitialized(self); }

function OSDAnnotationLayer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function OSDAnnotationLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function OSDAnnotationLayer_getPrototypeOf(o) { OSDAnnotationLayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return OSDAnnotationLayer_getPrototypeOf(o); }

function OSDAnnotationLayer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }











var OSDAnnotationLayer_OSDAnnotationLayer = /*#__PURE__*/function (_EventEmitter) {
  OSDAnnotationLayer_inherits(OSDAnnotationLayer, _EventEmitter);

  var _super = OSDAnnotationLayer_createSuper(OSDAnnotationLayer);

  function OSDAnnotationLayer(props) {
    var _this;

    OSDAnnotationLayer_classCallCheck(this, OSDAnnotationLayer);

    _this = _super.call(this);

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "_initDrawingMouseTracker", function () {
      var started = false;
      _this.mouseTracker = new external_root_OpenSeadragon_commonjs_openseadragon_commonjs2_openseadragon_amd_openseadragon_default.a.MouseTracker({
        element: _this.svg,
        pressHandler: function pressHandler(evt) {
          if (!_this.tools.current.isDrawing) _this.tools.current.start(evt.originalEvent);
        },
        moveHandler: function moveHandler(evt) {
          if (_this.tools.current.isDrawing) {
            var _this$tools$current$g = _this.tools.current.getSVGPoint(evt.originalEvent),
                x = _this$tools$current$g.x,
                y = _this$tools$current$g.y;

            _this.tools.current.onMouseMove(x, y, evt.originalEvent);

            if (!started) {
              _this.emit('startSelection', {
                x: x,
                y: y
              });

              started = true;
            }
          }
        },
        releaseHandler: function releaseHandler(evt) {
          if (_this.tools.current.isDrawing) {
            var _this$tools$current$g2 = _this.tools.current.getSVGPoint(evt.originalEvent),
                x = _this$tools$current$g2.x,
                y = _this$tools$current$g2.y;

            _this.tools.current.onMouseUp(x, y, evt.originalEvent);
          }

          started = false;
        }
      }).setTracking(false);

      _this.tools.on('complete', function (shape) {
        _this.selectShape(shape);

        _this.emit('createSelection', shape.annotation);

        _this.mouseTracker.setTracking(false);
      }); // Keep tracker disabled until Shift is held


      document.addEventListener('keydown', function (evt) {
        if (evt.which === 16 && !_this.selectedShape) {
          // Shift
          _this.mouseTracker.setTracking(!_this.readOnly);
        }
      });
      document.addEventListener('keyup', function (evt) {
        if (evt.which === 16 && !_this.tools.current.isDrawing) {
          _this.mouseTracker.setTracking(false);
        }
      });
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "_attachMouseListeners", function (shape, annotation) {
      shape.addEventListener('mouseenter', function () {
        var _this$tools;

        _this.viewer.gestureSettingsByDeviceType('mouse').clickToZoom = false;
        if (!((_this$tools = _this.tools) !== null && _this$tools !== void 0 && _this$tools.current.isDrawing)) _this.emit('mouseEnterAnnotation', annotation, shape);
      });
      shape.addEventListener('mouseleave', function () {
        var _this$tools2;

        _this.viewer.gestureSettingsByDeviceType('mouse').clickToZoom = true;
        if (!((_this$tools2 = _this.tools) !== null && _this$tools2 !== void 0 && _this$tools2.current.isDrawing)) _this.emit('mouseLeaveAnnotation', annotation, shape);
      }); // Common click/tap handler

      var onClick = function onClick() {
        var _this$selectedShape;

        // Unfortunately, click also fires after drag, which means
        // a new selection on top of this shape will be inerpreted 
        // as click. Identify this case and pervent the default
        // selection action!
        var isSelection = (_this$selectedShape = _this.selectedShape) === null || _this$selectedShape === void 0 ? void 0 : _this$selectedShape.annotation.isSelection;

        if (!isSelection) {
          if (_this.disableSelect) {
            _this.emit('clickAnnotation', shape.annotation, shape);
          } else {
            _this.selectShape(shape);
          }
        }
      };

      shape.addEventListener('click', onClick);
      shape.addEventListener('touchend', onClick);
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "addAnnotation", function (annotation) {
      var shape = drawShape(annotation);

      if (annotation.target.styleClass) {
        shape.setAttribute('class', 'a9s-annotation ' + annotation.target.styleClass);
      } else {
        shape.setAttribute('class', 'a9s-annotation');
      }

      shape.setAttribute('data-id', annotation.id);
      shape.annotation = annotation;

      _this._attachMouseListeners(shape, annotation);

      _this.g.appendChild(shape);

      Formatting_format(shape, annotation, _this.formatter);

      _this.scaleFormatterElements(shape);
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "addDrawingTool", function (plugin) {
      return _this.tools.registerTool(plugin);
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "addOrUpdateAnnotation", function (annotation, previous) {
      var _this$selectedShape2, _this$selectedShape3;

      if (((_this$selectedShape2 = _this.selectedShape) === null || _this$selectedShape2 === void 0 ? void 0 : _this$selectedShape2.annotation) === annotation || ((_this$selectedShape3 = _this.selectedShape) === null || _this$selectedShape3 === void 0 ? void 0 : _this$selectedShape3.annotation) == previous) _this.deselect();
      if (previous) _this.removeAnnotation(annotation);

      _this.removeAnnotation(annotation);

      _this.addAnnotation(annotation); // Make sure rendering order is large-to-small


      _this.redraw();
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "currentScale", function () {
      var containerWidth = _this.viewer.viewport.getContainerSize().x;

      var zoom = _this.viewer.viewport.getZoom(true);

      return zoom * containerWidth / _this.viewer.world.getContentFactor();
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "deselect", function (skipRedraw) {
      var _this$tools3;

      (_this$tools3 = _this.tools) === null || _this$tools3 === void 0 ? void 0 : _this$tools3.current.stop();

      if (_this.selectedShape) {
        var annotation = _this.selectedShape.annotation;

        if (_this.selectedShape.destroy) {
          // Modifiable shape: destroy and re-add the annotation
          _this.selectedShape.mouseTracker.destroy();

          _this.selectedShape.destroy();

          if (!annotation.isSelection) _this.addAnnotation(annotation);
          if (!skipRedraw) _this.redraw();
        }

        _this.selectedShape = null;
      }
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "destroy", function () {
      _this.deselect();

      _this.mouseTracker.destroy();

      _this.svg.parentNode.removeChild(_this.svg);
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "findShape", function (annotationOrId) {
      var id = annotationOrId !== null && annotationOrId !== void 0 && annotationOrId.id ? annotationOrId.id : annotationOrId;
      return _this.g.querySelector(".a9s-annotation[data-id=\"".concat(id, "\"]"));
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "fitBounds", function (annotationOrId, immediately) {
      var shape = _this.findShape(annotationOrId);

      if (shape) {
        var _shape$getBBox = shape.getBBox(),
            x = _shape$getBBox.x,
            y = _shape$getBBox.y,
            width = _shape$getBBox.width,
            height = _shape$getBBox.height; // SVG element bounds, image coordinates


        var rect = _this.viewer.viewport.imageToViewportRectangle(x, y, width, height);

        _this.viewer.viewport.fitBounds(rect, immediately);
      }
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "getAnnotations", function () {
      var shapes = Array.from(_this.g.querySelectorAll('.a9s-annotation'));
      return shapes.map(function (s) {
        return s.annotation;
      });
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "getSelected", function () {
      if (_this.selectedShape) {
        var annotation = _this.selectedShape.annotation;
        var element = _this.selectedShape.element || _this.selectedShape;
        return {
          annotation: annotation,
          element: element
        };
      }
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "getSelectedImageSnippet", function () {
      if (_this.selectedShape) {
        var _this$selectedShape$e;

        var shape = (_this$selectedShape$e = _this.selectedShape.element) !== null && _this$selectedShape$e !== void 0 ? _this$selectedShape$e : _this.selectedShape;
        return ImageSnippet_getSnippet(_this.viewer, shape);
      }
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "init", function (annotations) {
      // Clear existing
      _this.deselect();

      var shapes = Array.from(_this.g.querySelectorAll('.a9s-annotation'));
      shapes.forEach(function (s) {
        return _this.g.removeChild(s);
      }); // Add

      annotations.sort(function (a, b) {
        return shapeArea(b) - shapeArea(a);
      });
      annotations.forEach(_this.addAnnotation);
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "listDrawingTools", function () {
      return _this.tools.listTools();
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "overrideId", function (originalId, forcedId) {
      // Update SVG shape data attribute
      var shape = _this.findShape(originalId);

      shape.setAttribute('data-id', forcedId); // Update annotation

      var annotation = shape.annotation;
      var updated = annotation.clone({
        id: forcedId
      });
      shape.annotation = updated;
      return updated;
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "panTo", function (annotationOrId, immediately) {
      var shape = _this.findShape(annotationOrId);

      if (shape) {
        var _shape$getBoundingCli = shape.getBoundingClientRect(),
            top = _shape$getBoundingCli.top,
            left = _shape$getBoundingCli.left,
            width = _shape$getBoundingCli.width,
            height = _shape$getBoundingCli.height;

        var x = left + width / 2 + window.scrollX;
        var y = top + height / 2 + window.scrollY;

        var center = _this.viewer.viewport.windowToViewportCoordinates(new external_root_OpenSeadragon_commonjs_openseadragon_commonjs2_openseadragon_amd_openseadragon_default.a.Point(x, y));

        _this.viewer.viewport.panTo(center, immediately);
      }
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "redraw", function () {
      var shapes = Array.from(_this.g.querySelectorAll('.a9s-annotation'));
      var annotations = shapes.map(function (s) {
        return s.annotation;
      });
      annotations.sort(function (a, b) {
        return shapeArea(b) - shapeArea(a);
      }); // Clear the SVG element

      shapes.forEach(function (s) {
        return _this.g.removeChild(s);
      }); // Redraw

      annotations.forEach(_this.addAnnotation);
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "removeAnnotation", function (annotationOrId) {
      var _this$selectedShape4;

      // Removal won't work if the annotation is currently selected - deselect!
      var id = annotationOrId.type ? annotationOrId.id : annotationOrId;
      if (((_this$selectedShape4 = _this.selectedShape) === null || _this$selectedShape4 === void 0 ? void 0 : _this$selectedShape4.annotation.id) === id) _this.deselect();

      var toRemove = _this.findShape(annotationOrId);

      if (toRemove) {
        var _this$selectedShape5;

        if (((_this$selectedShape5 = _this.selectedShape) === null || _this$selectedShape5 === void 0 ? void 0 : _this$selectedShape5.annotation) === toRemove.annotation) _this.deselect();

        if (toRemove.mouseTracker != null) {
          toRemove.mouseTracker.destroy();
        }

        toRemove.parentNode.removeChild(toRemove);
      }
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "scaleFormatterElements", function (opt_shape) {
      var scale = 1 / _this.currentScale();

      if (opt_shape) {
        var el = opt_shape.querySelector('.a9s-formatter-el');
        if (el) el.firstChild.setAttribute('transform', "scale(".concat(scale, ")"));
      } else {
        var elements = Array.from(_this.g.querySelectorAll('.a9s-formatter-el'));
        elements.forEach(function (el) {
          return el.firstChild.setAttribute('transform', "scale(".concat(scale, ")"));
        });
      }
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "selectAnnotation", function (annotationOrId, skipEvent) {
      if (_this.selectedShape) _this.deselect();

      var selected = _this.findShape(annotationOrId);

      if (selected) {
        _this.selectShape(selected, skipEvent);

        var element = _this.selectedShape.element ? _this.selectedShape.element : _this.selectedShape;
        return {
          annotation: selected.annotation,
          element: element
        };
      } else {
        _this.deselect();
      }
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "selectShape", function (shape, skipEvent) {
      var _this$selectedShape6;

      if (!skipEvent) _this.emit('clickAnnotation', shape.annotation, shape); // Don't re-select

      if (((_this$selectedShape6 = _this.selectedShape) === null || _this$selectedShape6 === void 0 ? void 0 : _this$selectedShape6.annotation) === (shape === null || shape === void 0 ? void 0 : shape.annotation)) return; // If another shape is currently selected, deselect first

      if (_this.selectedShape && _this.selectedShape.annotation !== shape.annotation) _this.deselect(true);
      var annotation = shape.annotation;
      var readOnly = _this.readOnly || annotation.readOnly;

      if (!(readOnly || _this.headless)) {
        setTimeout(function () {
          shape.parentNode.removeChild(shape); // Fire the event AFTER the original shape was removed. Otherwise,
          // people calling `.getAnnotations()` in the `onSelectAnnotation` 
          // handler will receive a duplicate annotation
          // (See issue https://github.com/recogito/annotorious-openseadragon/issues/63)

          if (!skipEvent) _this.emit('select', {
            annotation: annotation,
            element: _this.selectedShape.element
          });
        }, 1);

        var toolForAnnotation = _this.tools.forAnnotation(annotation);

        _this.selectedShape = toolForAnnotation.createEditableShape(annotation);

        _this.selectedShape.scaleHandles(1 / _this.currentScale());

        _this.scaleFormatterElements(_this.selectedShape.element);

        _this.selectedShape.element.annotation = annotation;

        _this.selectedShape.element.addEventListener('click', function () {
          _this.emit('clickAnnotation', annotation, _this.selectedShape.element);
        }); // Disable normal OSD nav


        var editableShapeMouseTracker = new external_root_OpenSeadragon_commonjs_openseadragon_commonjs2_openseadragon_amd_openseadragon_default.a.MouseTracker({
          element: _this.svg
        }).setTracking(true); // En-/disable OSD nav based on hover status

        _this.selectedShape.element.addEventListener('mouseenter', function (evt) {
          return editableShapeMouseTracker.setTracking(true);
        });

        _this.selectedShape.element.addEventListener('mouseleave', function (evt) {
          return editableShapeMouseTracker.setTracking(false);
        });

        _this.selectedShape.mouseTracker = editableShapeMouseTracker;

        _this.selectedShape.on('update', function (fragment) {
          return _this.emit('updateTarget', _this.selectedShape.element, fragment);
        });
      } else {
        _this.selectedShape = shape;
        if (!skipEvent) _this.emit('select', {
          annotation: annotation,
          element: shape,
          skipEvent: skipEvent
        });
      }
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "setDrawingEnabled", function (enable) {
      var _this$mouseTracker;

      return (_this$mouseTracker = _this.mouseTracker) === null || _this$mouseTracker === void 0 ? void 0 : _this$mouseTracker.setTracking(enable && !_this.readOnly);
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "setDrawingTool", function (shape) {
      if (_this.tools) {
        var _this$tools$current;

        (_this$tools$current = _this.tools.current) === null || _this$tools$current === void 0 ? void 0 : _this$tools$current.stop();

        _this.tools.setCurrent(shape);
      }
    });

    OSDAnnotationLayer_defineProperty(OSDAnnotationLayer_assertThisInitialized(_this), "setVisible", function (visible) {
      if (visible) {
        _this.svg.style.display = null;
      } else {
        _this.deselect();

        _this.svg.style.display = 'none';
      }
    });

    _this.viewer = props.viewer;
    _this.readOnly = props.config.readOnly;
    _this.headless = props.config.headless;
    _this.formatter = props.config.formatter;
    _this.disableSelect = false;
    _this.svg = document.createElementNS(SVG_NAMESPACE, 'svg');

    if (Touch_isTouchDevice()) {
      _this.svg.setAttribute('class', 'a9s-annotationlayer a9s-osd-annotationlayer touch');

      enableTouchTranslation(_this.svg);
    } else {
      _this.svg.setAttribute('class', 'a9s-annotationlayer a9s-osd-annotationlayer');
    }

    _this.g = document.createElementNS(SVG_NAMESPACE, 'g');

    _this.svg.appendChild(_this.g);

    _this.viewer.canvas.appendChild(_this.svg);

    _this.viewer.addHandler('animation', function () {
      return _this.resize();
    });

    _this.viewer.addHandler('rotate', function () {
      return _this.resize();
    });

    _this.viewer.addHandler('resize', function () {
      return _this.resize();
    });

    _this.viewer.addHandler('flip', function () {
      return _this.resize();
    });

    var onLoad = function onLoad() {
      var _this$viewer$world$ge = _this.viewer.world.getItemAt(0).source.dimensions,
          x = _this$viewer$world$ge.x,
          y = _this$viewer$world$ge.y;

      props.env.image = {
        src: _this.viewer.world.getItemAt(0).source['@id'] || new URL(_this.viewer.world.getItemAt(0).source.url, document.baseURI).href,
        naturalWidth: x,
        naturalHeight: y
      };

      if (props.config.crosshair) {
        _this.crosshair = new Crosshair_Crosshair(_this.g, x, y);
        SVG_addClass(_this.svg, 'has-crosshair');
      }

      _this.resize();
    }; // Store image properties on open (incl. after page change) and on addTiledImage


    _this.viewer.addHandler('open', onLoad);

    _this.viewer.world.addHandler('add-item', onLoad);

    _this.selectedShape = null;
    _this.tools = new ToolsRegistry_ToolRegistry(_this.g, props.config, props.env);

    _this._initDrawingMouseTracker();

    return _this;
  }
  /** Initializes the OSD MouseTracker used for drawing **/


  OSDAnnotationLayer_createClass(OSDAnnotationLayer, [{
    key: "resize",
    value: function resize() {
      var flipped = this.viewer.viewport.getFlip();
      var p = this.viewer.viewport.pixelFromPoint(new external_root_OpenSeadragon_commonjs_openseadragon_commonjs2_openseadragon_amd_openseadragon_default.a.Point(0, 0), true);
      if (flipped) p.x = this.viewer.viewport._containerInnerSize.x - p.x;
      var scaleY = this.currentScale();
      var scaleX = flipped ? -scaleY : scaleY;
      var rotation = this.viewer.viewport.getRotation();
      this.g.setAttribute('transform', "translate(".concat(p.x, ", ").concat(p.y, ") scale(").concat(scaleX, ", ").concat(scaleY, ") rotate(").concat(rotation, ")"));
      this.scaleFormatterElements();

      if (this.selectedShape) {
        if (this.selectedShape.element) {
          // Editable shape
          this.selectedShape.scaleHandles(1 / scaleY);
          this.emit('viewportChange', this.selectedShape.element);
        } else {
          this.emit('viewportChange', this.selectedShape);
        }
      }
    }
  }]);

  return OSDAnnotationLayer;
}(tiny_emitter_default.a);


// CONCATENATED MODULE: ./src/OpenSeadragonAnnotator.jsx
function OpenSeadragonAnnotator_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { OpenSeadragonAnnotator_typeof = function _typeof(obj) { return typeof obj; }; } else { OpenSeadragonAnnotator_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return OpenSeadragonAnnotator_typeof(obj); }

function OpenSeadragonAnnotator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function OpenSeadragonAnnotator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function OpenSeadragonAnnotator_createClass(Constructor, protoProps, staticProps) { if (protoProps) OpenSeadragonAnnotator_defineProperties(Constructor.prototype, protoProps); if (staticProps) OpenSeadragonAnnotator_defineProperties(Constructor, staticProps); return Constructor; }

function OpenSeadragonAnnotator_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) OpenSeadragonAnnotator_setPrototypeOf(subClass, superClass); }

function OpenSeadragonAnnotator_setPrototypeOf(o, p) { OpenSeadragonAnnotator_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return OpenSeadragonAnnotator_setPrototypeOf(o, p); }

function OpenSeadragonAnnotator_createSuper(Derived) { var hasNativeReflectConstruct = OpenSeadragonAnnotator_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = OpenSeadragonAnnotator_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = OpenSeadragonAnnotator_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return OpenSeadragonAnnotator_possibleConstructorReturn(this, result); }; }

function OpenSeadragonAnnotator_possibleConstructorReturn(self, call) { if (call && (OpenSeadragonAnnotator_typeof(call) === "object" || typeof call === "function")) { return call; } return OpenSeadragonAnnotator_assertThisInitialized(self); }

function OpenSeadragonAnnotator_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function OpenSeadragonAnnotator_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function OpenSeadragonAnnotator_getPrototypeOf(o) { OpenSeadragonAnnotator_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return OpenSeadragonAnnotator_getPrototypeOf(o); }

function OpenSeadragonAnnotator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var OpenSeadragonAnnotator_OpenSeadragonAnnotator = /*#__PURE__*/function (_Component) {
  OpenSeadragonAnnotator_inherits(OpenSeadragonAnnotator, _Component);

  var _super = OpenSeadragonAnnotator_createSuper(OpenSeadragonAnnotator);

  function OpenSeadragonAnnotator() {
    var _this;

    OpenSeadragonAnnotator_classCallCheck(this, OpenSeadragonAnnotator);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "state", {
      selectedAnnotation: null,
      selectedDOMElement: null,
      modifiedTarget: null,
      // ReadOnly mode
      readOnly: _this.props.config.readOnly,
      // Headless mode
      editorDisabled: _this.props.config.disableEditor,
      // Widgets
      widgets: _this.props.config.widgets,
      // Records the state before any potential headless modify (done via
      // .updateSelected) so we can properly fire the updateAnnotation(a, previous)
      // event, and distinguish between headless Save and Cancel 
      beforeHeadlessModify: null
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "clearState", function (opt_callback) {
      return _this.setState({
        selectedAnnotation: null,
        selectedDOMElement: null,
        modifiedTarget: null,
        beforeHeadlessModify: null
      }, opt_callback);
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "forwardEvent", function (from, to) {
      _this.annotationLayer.on(from, function (annotation, elem) {
        _this.props[to](annotation.clone(), elem);
      });
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "escapeKeyCancel", function (evt) {
      if (evt.which === 27) {
        // Escape
        var selectedAnnotation = _this.state.selectedAnnotation;

        if (selectedAnnotation) {
          _this.cancelSelected();

          _this.props.onCancelSelected(selectedAnnotation);
        }
      }
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "handleStartSelect", function (pt) {
      return _this.props.onSelectionStarted(pt);
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "handleSelect", function (evt, skipEvent) {
      _this.state.editorDisabled ? _this.onHeadlessSelect(evt, skipEvent) : _this.onNormalSelect(evt, skipEvent);
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "onNormalSelect", function (evt, skipEvent) {
      var annotation = evt.annotation,
          element = evt.element;

      if (annotation) {
        // Select action needs to run immediately if no annotation was
        // selected before. Otherwise, make a deselect state change first,
        // and then select after this state change has completed. (This is
        // keep our external event cycle clean!)
        var select = function select() {
          _this.setState({
            selectedAnnotation: annotation,
            selectedDOMElement: element,
            modifiedTarget: null
          }, function () {
            if (!skipEvent) {
              if (annotation.isSelection) {
                _this.props.onSelectionCreated(annotation.clone());
              } else {
                _this.props.onAnnotationSelected(annotation.clone(), element);
              }
            }
          });
        }; // If there is another selected annotation,
        // fire cancel before making the new selection


        var selectedAnnotation = _this.state.selectedAnnotation;

        if (selectedAnnotation && !selectedAnnotation.isEqual(annotation)) {
          _this.clearState(function () {
            _this.props.onCancelSelected(selectedAnnotation);

            select();
          });
        } else {
          select();
        }
      } else {
        var _selectedAnnotation = _this.state.selectedAnnotation;
        if (_selectedAnnotation) _this.clearState(function () {
          return _this.props.onCancelSelected(_selectedAnnotation);
        });else _this.clearState();
      }
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "onHeadlessSelect", function (evt, skipEvent) {
      // When in headless mode, changing selection acts as 'Ok' - changes
      // to the previous annotation are stored! (In normal mode, selection
      // acts as 'Cancel'.)
      _this.saveSelected().then(function () {
        _this.onNormalSelect(evt, skipEvent);

        var annotation = evt.annotation;

        if (annotation && !annotation.isSelection) {
          var selection = _this.annotationLayer.selectAnnotation(evt.annotation, true);

          _this.setState({
            selectedDOMElement: selection.element
          });
        }
      });
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "handleUpdateTarget", function (selectedDOMElement, modifiedTarget) {
      _this.setState({
        selectedDOMElement: selectedDOMElement,
        modifiedTarget: modifiedTarget
      });

      var clone = JSON.parse(JSON.stringify(modifiedTarget));

      _this.props.onSelectionTargetChanged(clone);
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "handleViewportChange", function (selectedDOMElement) {
      return _this.setState({
        selectedDOMElement: selectedDOMElement
      });
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "overrideAnnotationId", function (originalAnnotation) {
      return function (forcedId) {
        var id = originalAnnotation.id; // Force the editor to close first, otherwise there's a risk of orphaned annotation

        if (_this.state.selectedAnnotation) {
          _this.setState({
            selectedAnnotation: null,
            selectedDOMElement: null,
            modifiedTarget: null
          }, function () {
            _this.annotationLayer.overrideId(id, forcedId);
          });
        } else {
          _this.annotationLayer.overrideId(id, forcedId);
        }
      };
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "onCreateOrUpdateAnnotation", function (method, opt_callback) {
      return function (annotation, previous) {
        // Merge updated target if necessary
        var a = annotation.isSelection ? annotation.toAnnotation() : annotation;
        a = _this.state.modifiedTarget ? a.clone({
          target: _this.state.modifiedTarget
        }) : a.clone();

        _this.clearState(function () {
          _this.annotationLayer.deselect();

          _this.annotationLayer.addOrUpdateAnnotation(a, previous); // Call CREATE or UPDATE handler


          if (previous) _this.props[method](a, previous.clone());else _this.props[method](a, _this.overrideAnnotationId(annotation));
          opt_callback && opt_callback();
        });
      };
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "onDeleteAnnotation", function (annotation) {
      _this.clearState();

      _this.annotationLayer.removeAnnotation(annotation);

      _this.props.onAnnotationDeleted(annotation);
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "onCancelAnnotation", function (annotation, opt_callback) {
      if (!_this.state.editorDisabled) _this.annotationLayer.deselect();

      _this.props.onCancelSelected(annotation);

      _this.clearState(opt_callback);
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "addAnnotation", function (annotation) {
      return _this.annotationLayer.addOrUpdateAnnotation(annotation.clone());
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "addDrawingTool", function (plugin) {
      return _this.annotationLayer.addDrawingTool(plugin);
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "cancelSelected", function () {
      _this.annotationLayer.deselect();

      if (_this.state.selectedAnnotation) _this.clearState();
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "fitBounds", function (annotationOrId, immediately) {
      return _this.annotationLayer.fitBounds(annotationOrId, immediately);
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "getAnnotations", function () {
      return _this.annotationLayer.getAnnotations().map(function (a) {
        return a.clone();
      });
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "getSelected", function () {
      var selected = _this.annotationLayer.getSelected();

      return selected ? selected.annotation.clone() : null;
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "getSelectedImageSnippet", function () {
      return _this.annotationLayer.getSelectedImageSnippet();
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "listDrawingTools", function () {
      return _this.annotationLayer.listDrawingTools();
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "panTo", function (annotationOrId, immediately) {
      return _this.annotationLayer.panTo(annotationOrId, immediately);
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "removeAnnotation", function (annotationOrId) {
      return _this.annotationLayer.removeAnnotation(annotationOrId);
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "saveSelected", function () {
      return new Promise(function (resolve) {
        var a = _this.state.selectedAnnotation;

        if (a) {
          if (a.isSelection) {
            if (a.bodies.length > 0 || _this.props.config.allowEmpty) {
              _this.onCreateOrUpdateAnnotation('onAnnotationCreated', resolve)(a, a);
            } else {
              _this.annotationLayer.deselect();

              resolve();
            }
          } else {
            // Headless update?
            var _this$state = _this.state,
                beforeHeadlessModify = _this$state.beforeHeadlessModify,
                modifiedTarget = _this$state.modifiedTarget;

            if (beforeHeadlessModify) {
              // Annotation was modified using '.updateSelected()'
              _this.onCreateOrUpdateAnnotation('onAnnotationUpdated', resolve)(a, beforeHeadlessModify);
            } else if (modifiedTarget) {
              // Target was modified, but otherwise no change
              _this.onCreateOrUpdateAnnotation('onAnnotationUpdated', resolve)(a, a);
            } else {
              _this.onCancelAnnotation(a, resolve);
            }
          }
        } else {
          resolve();
        }
      });
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "selectAnnotation", function (arg) {
      var selected = _this.annotationLayer.selectAnnotation(arg, true);

      if (selected) {
        _this.handleSelect(selected, true);

        return selected.annotation.clone();
      } else {
        _this.clearState(); // Deselect

      }
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "setAnnotations", function (annotations) {
      return _this.annotationLayer.init(annotations.map(function (a) {
        return a.clone();
      }));
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "setDrawingEnabled", function (enable) {
      return _this.annotationLayer.setDrawingEnabled(enable);
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "setDrawingTool", function (shape) {
      return _this.annotationLayer.setDrawingTool(shape);
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "setVisible", function (visible) {
      _this.annotationLayer.setVisible(visible);

      if (!visible) _this.clearState();
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "setWidgets", function (widgets) {
      return _this.setState({
        widgets: widgets
      });
    });

    OpenSeadragonAnnotator_defineProperty(OpenSeadragonAnnotator_assertThisInitialized(_this), "updateSelected", function (annotation, saveImmediately) {
      return new Promise(function (resolve) {
        if (_this.state.selectedAnnotation) {
          if (saveImmediately) {
            if (_this.state.selectedAnnotation.isSelection) {
              _this.onCreateOrUpdateAnnotation('onAnnotationCreated', resolve)(annotation);
            } else {
              _this.onCreateOrUpdateAnnotation('onAnnotationUpdated', resolve)(annotation, _this.state.selectedAnnotation);
            }
          } else {
            _this.setState({
              selectedAnnotation: annotation,
              beforeHeadlessModify: _this.state.beforeHeadlessModify || _this.state.selectedAnnotation
            }, resolve);
          }
        }
      });
    });

    return _this;
  }

  OpenSeadragonAnnotator_createClass(OpenSeadragonAnnotator, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.annotationLayer = new OSDAnnotationLayer_OSDAnnotationLayer(this.props);
      this.annotationLayer.on('startSelection', this.handleStartSelect);
      this.annotationLayer.on('select', this.handleSelect);
      this.annotationLayer.on('updateTarget', this.handleUpdateTarget);
      this.annotationLayer.on('viewportChange', this.handleViewportChange);
      this.forwardEvent('mouseEnterAnnotation', 'onMouseEnterAnnotation');
      this.forwardEvent('mouseLeaveAnnotation', 'onMouseLeaveAnnotation');
      this.forwardEvent('clickAnnotation', 'onClickAnnotation'); // Escape cancels editing

      document.addEventListener('keyup', this.escapeKeyCancel);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.annotationLayer.destroy();
      document.removeEventListener('keyup', this.escapeKeyCancel);
    }
  }, {
    key: "disableEditor",
    get: function get() {
      return this.state.editorDisabled;
    },
    set: function set(disabled) {
      var _this2 = this;

      this.setState({
        editorDisabled: disabled
      }, function () {
        // En- or disable Esc key listener
        if (disabled) document.addEventListener('keyup', _this2.escapeKeyCancel);else document.removeEventListener('keyup', _this2.escapeKeyCancel);
      });
    }
  }, {
    key: "disableSelect",
    get: function get() {
      return this.annotationLayer.disableSelect;
    },
    set: function set(disable) {
      this.annotationLayer.disableSelect = disable;

      if (disable) {
        this.annotationLayer.deselect();
        this.clearState();
      }
    }
  }, {
    key: "readOnly",
    get: function get() {
      return this.state.readOnly;
    },
    set: function set(readOnly) {
      this.annotationLayer.readOnly = readOnly;
      this.setState({
        readOnly: readOnly
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state$selectedA;

      // The editor should open under normal conditions - annotation was selected, no headless mode
      var open = this.state.selectedAnnotation && !this.state.editorDisabled;
      var readOnly = this.state.readOnly || ((_this$state$selectedA = this.state.selectedAnnotation) === null || _this$state$selectedA === void 0 ? void 0 : _this$state$selectedA.readOnly);
      return open && /*#__PURE__*/compat_module["default"].createElement(Editor_Editor, {
        wrapperEl: this.props.wrapperEl,
        annotation: this.state.selectedAnnotation,
        modifiedTarget: this.state.modifiedTarget,
        selectedElement: this.state.selectedDOMElement,
        readOnly: readOnly,
        allowEmpty: this.props.config.allowEmpty,
        widgets: this.state.widgets,
        env: this.props.env,
        onAnnotationCreated: this.onCreateOrUpdateAnnotation('onAnnotationCreated'),
        onAnnotationUpdated: this.onCreateOrUpdateAnnotation('onAnnotationUpdated'),
        onAnnotationDeleted: this.onDeleteAnnotation,
        onCancel: this.onCancelAnnotation
      });
    }
  }]);

  return OpenSeadragonAnnotator;
}(compat_module["Component"]);


// CONCATENATED MODULE: ./node_modules/@recogito/annotorious/src/ImageAnnotator.scss
// extracted by mini-css-extract-plugin

// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/themes/default/theme.scss
// extracted by mini-css-extract-plugin

// CONCATENATED MODULE: ./node_modules/@recogito/recogito-client-core/themes/default/index.js

// CONCATENATED MODULE: ./src/index.jsx
function src_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function src_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function src_createClass(Constructor, protoProps, staticProps) { if (protoProps) src_defineProperties(Constructor.prototype, protoProps); if (staticProps) src_defineProperties(Constructor, staticProps); return Constructor; }

function src_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var src_OSDAnnotorious = /*#__PURE__*/function () {
  function OSDAnnotorious(viewer, conf) {
    var _this = this;

    src_classCallCheck(this, OSDAnnotorious);

    src_defineProperty(this, "handleAnnotationCreated", function (annotation, overrideId) {
      return _this._emitter.emit('createAnnotation', annotation.underlying, overrideId);
    });

    src_defineProperty(this, "handleAnnotationDeleted", function (annotation) {
      return _this._emitter.emit('deleteAnnotation', annotation.underlying);
    });

    src_defineProperty(this, "handleAnnotationSelected", function (annotation, elem) {
      return _this._emitter.emit('selectAnnotation', annotation.underlying, elem);
    });

    src_defineProperty(this, "handleAnnotationUpdated", function (annotation, previous) {
      return _this._emitter.emit('updateAnnotation', annotation.underlying, previous.underlying);
    });

    src_defineProperty(this, "handleCancelSelected", function (annotation) {
      return _this._emitter.emit('cancelSelected', annotation.underlying);
    });

    src_defineProperty(this, "handleClickAnnotation", function (annotation, elem) {
      return _this._emitter.emit('clickAnnotation', annotation.underlying, elem);
    });

    src_defineProperty(this, "handleSelectionCreated", function (selection) {
      return _this._emitter.emit('createSelection', selection.underlying);
    });

    src_defineProperty(this, "handleSelectionStarted", function (pt) {
      return _this._emitter.emit('startSelection', pt);
    });

    src_defineProperty(this, "handleSelectionTargetChanged", function (target) {
      return _this._emitter.emit('changeSelectionTarget', target);
    });

    src_defineProperty(this, "handleMouseEnterAnnotation", function (annotation, elem) {
      return _this._emitter.emit('mouseEnterAnnotation', annotation.underlying, elem);
    });

    src_defineProperty(this, "handleMouseLeaveAnnotation", function (annotation, elem) {
      return _this._emitter.emit('mouseLeaveAnnotation', annotation.underlying, elem);
    });

    src_defineProperty(this, "_wrap", function (annotationOrId) {
      return (annotationOrId === null || annotationOrId === void 0 ? void 0 : annotationOrId.type) === 'Annotation' ? new WebAnnotation_WebAnnotation(annotationOrId) : annotationOrId;
    });

    src_defineProperty(this, "addAnnotation", function (annotation) {
      return _this._app.current.addAnnotation(new WebAnnotation_WebAnnotation(annotation));
    });

    src_defineProperty(this, "addDrawingTool", function (plugin) {
      return _this._app.current.addDrawingTool(plugin);
    });

    src_defineProperty(this, "cancelSelected", function () {
      return _this._app.current.cancelSelected();
    });

    src_defineProperty(this, "clearAnnotations", function () {
      return _this.setAnnotations([]);
    });

    src_defineProperty(this, "clearAuthInfo", function () {
      return _this._env.user = null;
    });

    src_defineProperty(this, "destroy", function () {
      return compat_module["default"].unmountComponentAtNode(_this.appContainerEl);
    });

    src_defineProperty(this, "fitBounds", function (annotationOrId, immediately) {
      return _this._app.current.fitBounds(_this._wrap(annotationOrId), immediately);
    });

    src_defineProperty(this, "getAnnotations", function () {
      var annotations = _this._app.current.getAnnotations();

      return annotations.map(function (a) {
        return a.underlying;
      });
    });

    src_defineProperty(this, "getSelected", function () {
      var selected = _this._app.current.getSelected();

      return selected === null || selected === void 0 ? void 0 : selected.underlying;
    });

    src_defineProperty(this, "getSelectedImageSnippet", function () {
      return _this._app.current.getSelectedImageSnippet();
    });

    src_defineProperty(this, "listDrawingTools", function () {
      return _this._app.current.listDrawingTools();
    });

    src_defineProperty(this, "loadAnnotations", function (url) {
      return fetch(url).then(function (response) {
        return response.json();
      }).then(function (annotations) {
        _this.setAnnotations(annotations);

        return annotations;
      });
    });

    src_defineProperty(this, "off", function (event, callback) {
      return _this._emitter.off(event, callback);
    });

    src_defineProperty(this, "on", function (event, handler) {
      return _this._emitter.on(event, handler);
    });

    src_defineProperty(this, "once", function (event, handler) {
      return _this._emitter.once(event, handler);
    });

    src_defineProperty(this, "panTo", function (annotationOrId, immediately) {
      return _this._app.current.panTo(_this._wrap(annotationOrId), immediately);
    });

    src_defineProperty(this, "removeAnnotation", function (annotationOrId) {
      return _this._app.current.removeAnnotation(_this._wrap(annotationOrId));
    });

    src_defineProperty(this, "saveSelected", function () {
      return _this._app.current.saveSelected();
    });

    src_defineProperty(this, "selectAnnotation", function (annotationOrId) {
      var selected = _this._app.current.selectAnnotation(_this._wrap(annotationOrId));

      return selected === null || selected === void 0 ? void 0 : selected.underlying;
    });

    src_defineProperty(this, "setAnnotations", function (annotations) {
      var safe = annotations || []; // Allow null for clearning all current annotations

      var webannotations = safe.map(function (a) {
        return new WebAnnotation_WebAnnotation(a);
      });

      _this._app.current.setAnnotations(webannotations);
    });

    src_defineProperty(this, "setAuthInfo", function (authinfo) {
      return _this._env.user = authinfo;
    });

    src_defineProperty(this, "setDrawingEnabled", function (enable) {
      return _this._app.current.setDrawingEnabled(enable);
    });

    src_defineProperty(this, "setDrawingTool", function (shape) {
      return _this._app.current.setDrawingTool(shape);
    });

    src_defineProperty(this, "setVisible", function (visible) {
      return _this._app.current.setVisible(visible);
    });

    src_defineProperty(this, "setWidgets", function (widgets) {
      return _this._app.current.setWidgets(widgets);
    });

    src_defineProperty(this, "setServerTime", function (timestamp) {
      return _this._env.setServerTime(timestamp);
    });

    src_defineProperty(this, "updateSelected", function (annotation) {
      var updated = null;

      if (annotation.type === 'Annotation') {
        updated = new WebAnnotation_WebAnnotation(annotation);
      } else if (annotation.type === 'Selection') {
        updated = new Selection_Selection(annotation.target, annotation.body);
      }

      if (updated) _this._app.current.updateSelected(updated);
    });

    var config = conf || {}; // TODO .headless option is deprecated!

    config.disableEditor = config.disableEditor || config.headless;
    this._app = /*#__PURE__*/compat_module["default"].createRef();
    this._emitter = new tiny_emitter_default.a();
    this._env = Environment();
    this._element = viewer.element;
    if (!this._element.style.position) this._element.style.position = 'relative';
    utils_setLocale(config.locale, config.messages);
    this.appContainerEl = document.createElement('DIV');

    this._element.appendChild(this.appContainerEl);

    compat_module["default"].render( /*#__PURE__*/compat_module["default"].createElement(OpenSeadragonAnnotator_OpenSeadragonAnnotator, {
      ref: this._app,
      viewer: viewer,
      wrapperEl: this._element,
      config: config,
      env: this._env,
      onSelectionStarted: this.handleSelectionStarted,
      onSelectionCreated: this.handleSelectionCreated,
      onSelectionTargetChanged: this.handleSelectionTargetChanged,
      onAnnotationCreated: this.handleAnnotationCreated,
      onAnnotationSelected: this.handleAnnotationSelected,
      onAnnotationUpdated: this.handleAnnotationUpdated,
      onAnnotationDeleted: this.handleAnnotationDeleted,
      onCancelSelected: this.handleCancelSelected,
      onClickAnnotation: this.handleClickAnnotation,
      onMouseEnterAnnotation: this.handleMouseEnterAnnotation,
      onMouseLeaveAnnotation: this.handleMouseLeaveAnnotation
    }), this.appContainerEl);
  }
  /********************/

  /*  External events */

  /********************/


  src_createClass(OSDAnnotorious, [{
    key: "disableEditor",
    get: function get() {
      return this._app.current.disableEditor;
    },
    set: function set(disabled) {
      this._app.current.disableEditor = disabled;
    }
  }, {
    key: "disableSelect",
    get: function get() {
      return this._app.current.disableSelect;
    },
    set: function set(select) {
      this._app.current.disableSelect = select;
    }
  }, {
    key: "readOnly",
    get: function get() {
      return this._app.current.readOnly;
    },
    set: function set(readOnly) {
      this._app.current.readOnly = readOnly;
    }
  }]);

  return OSDAnnotorious;
}();

/* harmony default export */ var src = __webpack_exports__["default"] = (function (viewer, config) {
  return new src_OSDAnnotorious(viewer, config);
});

/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=openseadragon-annotorious.min.js.map